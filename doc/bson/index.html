<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="BSON, short for Binary JSON, is a binary-encoded serialization of JSON-like documents. Like JSON, BSON supports the embedding of documents and arrays within other documents and arrays. BSON also contains extensions that allow representation of data types that are not part of the JSON spec. For example, BSON has a datetime type and a binary data type."><title>bson - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="bson" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.0 (5680fa18f 2023-08-23) (built from a source tarball)" data-channel="1.72.0" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../bson/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../bson/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate bson</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 2.6.1</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">bson</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/bson/lib.rs.html#22-311">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>BSON, short for Binary JSON, is a binary-encoded serialization of JSON-like documents.
Like JSON, BSON supports the embedding of documents and arrays within other documents
and arrays. BSON also contains extensions that allow representation of data types that
are not part of the JSON spec. For example, BSON has a datetime type and a binary data type.</p>
<div class="example-wrap"><pre class="language-text"><code>// JSON equivalent
{&quot;hello&quot;: &quot;world&quot;}

// BSON encoding
\x16\x00\x00\x00                   // total document size
\x02                               // 0x02 = type String
hello\x00                          // field name
\x06\x00\x00\x00world\x00          // field value
\x00                               // 0x00 = type EOO (&#39;end of object&#39;)
</code></pre></div>
<p>BSON is the primary data representation for <a href="https://www.mongodb.com/">MongoDB</a>, and this crate is used in the
<a href="https://docs.rs/mongodb/latest/mongodb/"><code>mongodb</code></a> driver crate in its API and implementation.</p>
<p>For more information about BSON itself, see <a href="http://bsonspec.org">bsonspec.org</a>.</p>
<h3 id="installation"><a href="#installation">Installation</a></h3><h4 id="requirements"><a href="#requirements">Requirements</a></h4>
<ul>
<li>Rust 1.56+</li>
</ul>
<h4 id="importing"><a href="#importing">Importing</a></h4>
<p>This crate is available on <a href="https://crates.io/crates/bson">crates.io</a>. To use it in your application,
simply add it to your project’s <code>Cargo.toml</code>.</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
bson = &quot;2.6.0&quot;
</code></pre></div>
<p>Note that if you are using <code>bson</code> through the <code>mongodb</code> crate, you do not need to specify it in
your <code>Cargo.toml</code>, since the <code>mongodb</code> crate already re-exports it.</p>
<h5 id="feature-flags"><a href="#feature-flags">Feature Flags</a></h5><div><table><thead><tr><th style="text-align: left">Feature</th><th style="text-align: left">Description</th><th style="text-align: left">Default</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>chrono-0_4</code></td><td style="text-align: left">Enable support for v0.4 of the <a href="https://docs.rs/chrono/0.4"><code>chrono</code></a> crate in the public API.</td><td style="text-align: left">no</td></tr>
<tr><td style="text-align: left"><code>uuid-0_8</code></td><td style="text-align: left">Enable support for v0.8 of the <a href="https://docs.rs/uuid/0.8"><code>uuid</code></a> crate in the public API.</td><td style="text-align: left">no</td></tr>
<tr><td style="text-align: left"><code>uuid-1</code></td><td style="text-align: left">Enable support for v1.x of the <a href="https://docs.rs/uuid/1.x"><code>uuid</code></a> crate in the public API.</td><td style="text-align: left">no</td></tr>
<tr><td style="text-align: left"><code>time-0_3</code></td><td style="text-align: left">Enable support for v0.3 of the <a href="https://docs.rs/time/0.3"><code>time</code></a> crate in the public API.</td><td style="text-align: left">no</td></tr>
<tr><td style="text-align: left"><code>serde_with</code></td><td style="text-align: left">Enable <a href="https://docs.rs/serde_with/latest"><code>serde_with</code></a> integrations for <a href="struct.DateTime.html" title="struct bson::DateTime"><code>DateTime</code></a> and <a href="struct.Uuid.html" title="struct bson::Uuid"><code>Uuid</code></a>.</td><td style="text-align: left">no</td></tr>
</tbody></table>
</div><h3 id="bson-values"><a href="#bson-values">BSON values</a></h3>
<p>Many different types can be represented as a BSON value, including 32-bit and 64-bit signed
integers, 64 bit floating point numbers, strings, datetimes, embedded documents, and more. To
see a full list of possible BSON values, see the <a href="http://bsonspec.org/spec.html">BSON specification</a>. The various
possible BSON values are modeled in this crate by the <a href="enum.Bson.html"><code>Bson</code></a> enum.</p>
<h4 id="creating-bson-instances"><a href="#creating-bson-instances">Creating <code>Bson</code> instances</a></h4>
<p><a href="enum.Bson.html"><code>Bson</code></a> values can be instantiated directly or via the
<a href="macro.bson.html"><code>bson!</code></a> macro:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bson::{bson, Bson};

<span class="kw">let </span>string = Bson::String(<span class="string">&quot;hello world&quot;</span>.to_string());
<span class="kw">let </span>int = Bson::Int32(<span class="number">5</span>);
<span class="kw">let </span>array = Bson::Array(<span class="macro">vec!</span>[Bson::Int32(<span class="number">5</span>), Bson::Boolean(<span class="bool-val">false</span>)]);

<span class="kw">let </span>string: Bson = <span class="string">&quot;hello world&quot;</span>.into();
<span class="kw">let </span>int: Bson = <span class="number">5i32</span>.into();

<span class="kw">let </span>string = <span class="macro">bson!</span>(<span class="string">&quot;hello world&quot;</span>);
<span class="kw">let </span>int = <span class="macro">bson!</span>(<span class="number">5</span>);
<span class="kw">let </span>array = <span class="macro">bson!</span>([<span class="number">5</span>, <span class="bool-val">false</span>]);</code></pre></div>
<p><a href="macro.bson.html"><code>bson!</code></a> has supports both array and object literals, and it automatically
converts any values specified to <a href="enum.Bson.html"><code>Bson</code></a>, provided they are <code>Into&lt;Bson&gt;</code>.</p>
<h4 id="bson-value-unwrapping"><a href="#bson-value-unwrapping"><code>Bson</code> value unwrapping</a></h4>
<p><a href="enum.Bson.html"><code>Bson</code></a> has a number of helper methods for accessing the underlying native Rust
types. These helpers can be useful in circumstances in which the specific type of a BSON value
is known ahead of time.</p>
<p>e.g.:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bson::{bson, Bson};

<span class="kw">let </span>value = Bson::Int32(<span class="number">5</span>);
<span class="kw">let </span>int = value.as_i32(); <span class="comment">// Some(5)
</span><span class="kw">let </span>bool = value.as_bool(); <span class="comment">// None

</span><span class="kw">let </span>value = <span class="macro">bson!</span>([<span class="bool-val">true</span>]);
<span class="kw">let </span>array = value.as_array(); <span class="comment">// Some(&amp;Vec&lt;Bson&gt;)</span></code></pre></div>
<h3 id="bson-documents"><a href="#bson-documents">BSON documents</a></h3>
<p>BSON documents are ordered maps of UTF-8 encoded strings to BSON values. They are logically
similar to JSON objects in that they can contain subdocuments, arrays, and values of several
different types. This crate models BSON documents via the
<a href="document/struct.Document.html"><code>Document</code></a> struct.</p>
<h4 id="creating-documents"><a href="#creating-documents">Creating <code>Document</code>s</a></h4>
<p><a href="document/struct.Document.html"><code>Document</code></a>s can be created directly either from a byte
reader containing BSON data or via the <code>doc!</code> macro:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bson::{doc, Document};
<span class="kw">use </span>std::io::Read;

<span class="kw">let </span><span class="kw-2">mut </span>bytes = hex::decode(<span class="string">&quot;0C0000001069000100000000&quot;</span>).unwrap();
<span class="kw">let </span>doc = Document::from_reader(<span class="kw-2">&amp;mut </span>bytes.as_slice()).unwrap(); <span class="comment">// { &quot;i&quot;: 1 }

</span><span class="kw">let </span>doc = <span class="macro">doc! </span>{
   <span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>,
   <span class="string">&quot;int&quot;</span>: <span class="number">5</span>,
   <span class="string">&quot;subdoc&quot;</span>: { <span class="string">&quot;cat&quot;</span>: <span class="bool-val">true </span>},
};</code></pre></div>
<p><a href="macro.doc.html"><code>doc!</code></a> works similarly to <a href="macro.bson.html"><code>bson!</code></a>, except that it always
returns a <a href="document/struct.Document.html"><code>Document</code></a> rather than a <a href="enum.Bson.html"><code>Bson</code></a>.</p>
<h4 id="document-member-access"><a href="#document-member-access"><code>Document</code> member access</a></h4>
<p><a href="document/struct.Document.html"><code>Document</code></a> has a number of methods on it to facilitate member
access:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>bson::doc;

<span class="kw">let </span>doc = <span class="macro">doc! </span>{
   <span class="string">&quot;string&quot;</span>: <span class="string">&quot;string&quot;</span>,
   <span class="string">&quot;bool&quot;</span>: <span class="bool-val">true</span>,
   <span class="string">&quot;i32&quot;</span>: <span class="number">5</span>,
   <span class="string">&quot;doc&quot;</span>: { <span class="string">&quot;x&quot;</span>: <span class="bool-val">true </span>},
};

<span class="comment">// attempt get values as untyped Bson
</span><span class="kw">let </span>none = doc.get(<span class="string">&quot;asdfadsf&quot;</span>); <span class="comment">// None
</span><span class="kw">let </span>value = doc.get(<span class="string">&quot;string&quot;</span>); <span class="comment">// Some(&amp;Bson::String(&quot;string&quot;))

// attempt to get values with explicit typing
</span><span class="kw">let </span>string = doc.get_str(<span class="string">&quot;string&quot;</span>); <span class="comment">// Ok(&quot;string&quot;)
</span><span class="kw">let </span>subdoc = doc.get_document(<span class="string">&quot;doc&quot;</span>); <span class="comment">// Some(Document({ &quot;x&quot;: true }))
</span><span class="kw">let </span>error = doc.get_i64(<span class="string">&quot;i32&quot;</span>); <span class="comment">// Err(...)</span></code></pre></div>
<h3 id="modeling-bson-with-strongly-typed-data-structures"><a href="#modeling-bson-with-strongly-typed-data-structures">Modeling BSON with strongly typed data structures</a></h3>
<p>While it is possible to work with documents and BSON values directly, it will often introduce a
lot of boilerplate for verifying the necessary keys are present and their values are the correct
types. <a href="https://serde.rs/"><code>serde</code></a> provides a powerful way of mapping BSON data into Rust data structures largely
automatically, removing the need for all that boilerplate.</p>
<p>e.g.:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>serde::{Deserialize, Serialize};
<span class="kw">use </span>bson::{bson, Bson};

<span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Person {
    name: String,
    age: i32,
    phones: Vec&lt;String&gt;,
}

<span class="comment">// Some BSON input data as a [`Bson`].
</span><span class="kw">let </span>bson_data: Bson = <span class="macro">bson!</span>({
    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,
    <span class="string">&quot;age&quot;</span>: <span class="number">43</span>,
    <span class="string">&quot;phones&quot;</span>: [
        <span class="string">&quot;+44 1234567&quot;</span>,
        <span class="string">&quot;+44 2345678&quot;
    </span>]
});

<span class="comment">// Deserialize the Person struct from the BSON data, automatically
// verifying that the necessary keys are present and that they are of
// the correct types.
</span><span class="kw">let </span><span class="kw-2">mut </span>person: Person = bson::from_bson(bson_data).unwrap();

<span class="comment">// Do things just like with any other Rust data structure.
</span><span class="macro">println!</span>(<span class="string">&quot;Redacting {}&#39;s record.&quot;</span>, person.name);
person.name = <span class="string">&quot;REDACTED&quot;</span>.to_string();

<span class="comment">// Get a serialized version of the input data as a [`Bson`].
</span><span class="kw">let </span>redacted_bson = bson::to_bson(<span class="kw-2">&amp;</span>person).unwrap();</code></pre></div>
<p>Any types that implement <a href="../serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize"><code>Serialize</code></a> and <a href="../serde/de/trait.Deserialize.html" title="trait serde::de::Deserialize"><code>Deserialize</code></a> can be used in this way. Doing so helps
separate the “business logic” that operates over the data from the (de)serialization logic that
translates the data to/from its serialized form. This can lead to more clear and concise code
that is also less error prone.</p>
<h3 id="working-with-datetimes"><a href="#working-with-datetimes">Working with datetimes</a></h3>
<p>The BSON format includes a datetime type, which is modeled in this crate by the
<a href="struct.DateTime.html" title="struct bson::DateTime"><code>DateTime</code></a> struct, and the
<a href="../serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize"><code>Serialize</code></a> and <a href="../serde/de/trait.Deserialize.html" title="trait serde::de::Deserialize"><code>Deserialize</code></a> implementations for this struct produce and parse BSON datetimes
when serializing to or deserializing from BSON. The popular crate <a href="docs.rs/chrono"><code>chrono</code></a>
also provides a <a href="struct.DateTime.html" title="struct bson::DateTime"><code>DateTime</code></a> type, but its <a href="../serde/ser/trait.Serialize.html" title="trait serde::ser::Serialize"><code>Serialize</code></a> and <a href="../serde/de/trait.Deserialize.html" title="trait serde::de::Deserialize"><code>Deserialize</code></a> implementations operate
on strings instead, so when using it with BSON, the BSON datetime type is not used. To work
around this, the <code>chrono-0_4</code> feature flag can be enabled. This flag exposes a number of
convenient conversions between <a href="struct.DateTime.html" title="struct bson::DateTime"><code>bson::DateTime</code></a> and <a href="../chrono/datetime/struct.DateTime.html" title="struct chrono::datetime::DateTime"><code>chrono::DateTime</code></a>, including the
<a href="serde_helpers/chrono_datetime_as_bson_datetime/index.html" title="mod bson::serde_helpers::chrono_datetime_as_bson_datetime"><code>serde_helpers::chrono_datetime_as_bson_datetime</code></a>
serde helper, which can be used to (de)serialize <a href="../chrono/datetime/struct.DateTime.html" title="struct chrono::datetime::DateTime"><code>chrono::DateTime</code></a>s to/from BSON datetimes, and
the <code>From&lt;chrono::DateTime&gt;</code> implementation for <a href="enum.Bson.html" title="enum bson::Bson"><code>Bson</code></a>, which allows <a href="../chrono/datetime/struct.DateTime.html" title="struct chrono::datetime::DateTime"><code>chrono::DateTime</code></a> values
to be used in the <code>doc!</code> and <code>bson!</code> macros.</p>
<p>e.g.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>serde::{Serialize, Deserialize};
<span class="kw">use </span>bson::doc;

<span class="attr">#[derive(Serialize, Deserialize)]
</span><span class="kw">struct </span>Foo {
    <span class="comment">// serializes as a BSON datetime.
    </span>date_time: bson::DateTime,

    <span class="comment">// serializes as an RFC 3339 / ISO-8601 string.
    </span>chrono_datetime: chrono::DateTime&lt;chrono::Utc&gt;,

    <span class="comment">// serializes as a BSON datetime.
    // this requires the &quot;chrono-0_4&quot; feature flag
    </span><span class="attr">#[serde(with = <span class="string">&quot;bson::serde_helpers::chrono_datetime_as_bson_datetime&quot;</span>)]
    </span>chrono_as_bson: chrono::DateTime&lt;chrono::Utc&gt;,
}

<span class="comment">// this automatic conversion also requires the &quot;chrono-0_4&quot; feature flag
</span><span class="kw">let </span>query = <span class="macro">doc! </span>{
    <span class="string">&quot;created_at&quot;</span>: chrono::Utc::now(),
};</code></pre></div>
<h3 id="working-with-uuids"><a href="#working-with-uuids">Working with UUIDs</a></h3>
<p>See the module level documentation for the <a href="uuid/index.html" title="mod bson::uuid"><code>uuid</code></a> module.</p>
<h3 id="minimum-supported-rust-version-msrv"><a href="#minimum-supported-rust-version-msrv">Minimum supported Rust version (MSRV)</a></h3>
<p>The MSRV for this crate is currently 1.56.0. This will be rarely be increased, and if it ever is,
it will only happen in a minor or major version release.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="binary/index.html" title="mod bson::binary">binary</a></div></li><li><div class="item-name"><a class="mod" href="datetime/index.html" title="mod bson::datetime">datetime</a></div><div class="desc docblock-short">Module containing functionality related to BSON DateTimes.
For more information, see the documentation for the <a href="struct.DateTime.html" title="struct bson::DateTime"><code>DateTime</code></a> type.</div></li><li><div class="item-name"><a class="mod" href="de/index.html" title="mod bson::de">de</a></div><div class="desc docblock-short">Deserializer</div></li><li><div class="item-name"><a class="mod" href="decimal128/index.html" title="mod bson::decimal128">decimal128</a></div><div class="desc docblock-short"><a href="https://github.com/mongodb/specifications/blob/master/source/bson-decimal128/decimal128.rst">BSON Decimal128</a> data type representation</div></li><li><div class="item-name"><a class="mod" href="document/index.html" title="mod bson::document">document</a></div><div class="desc docblock-short">A BSON document represented as an associative HashMap with insertion ordering.</div></li><li><div class="item-name"><a class="mod" href="extjson/index.html" title="mod bson::extjson">extjson</a></div><div class="desc docblock-short">Deserialization and serialization of <a href="https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/">MongoDB Extended JSON v2</a></div></li><li><div class="item-name"><a class="mod" href="oid/index.html" title="mod bson::oid">oid</a></div><div class="desc docblock-short">Module containing functionality related to BSON ObjectIds.
For more information, see the documentation for the <a href="oid/struct.ObjectId.html" title="struct bson::oid::ObjectId"><code>ObjectId</code></a> type.</div></li><li><div class="item-name"><a class="mod" href="raw/index.html" title="mod bson::raw">raw</a></div><div class="desc docblock-short">An API for interacting with raw BSON bytes.</div></li><li><div class="item-name"><a class="mod" href="ser/index.html" title="mod bson::ser">ser</a></div><div class="desc docblock-short">Serializer</div></li><li><div class="item-name"><a class="mod" href="serde_helpers/index.html" title="mod bson::serde_helpers">serde_helpers</a></div><div class="desc docblock-short">Collection of helper functions for serializing to and deserializing from BSON using Serde</div></li><li><div class="item-name"><a class="mod" href="spec/index.html" title="mod bson::spec">spec</a></div><div class="desc docblock-short">Constants derived from the <a href="http://bsonspec.org/spec.html">BSON Specification Version 1.1</a>.</div></li><li><div class="item-name"><a class="mod" href="uuid/index.html" title="mod bson::uuid">uuid</a></div><div class="desc docblock-short">UUID support for BSON.</div></li></ul><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.bson.html" title="macro bson::bson">bson</a></div><div class="desc docblock-short">Construct a bson::BSON value from a literal.</div></li><li><div class="item-name"><a class="macro" href="macro.doc.html" title="macro bson::doc">doc</a></div><div class="desc docblock-short">Construct a bson::Document value.</div></li><li><div class="item-name"><a class="macro" href="macro.rawbson.html" title="macro bson::rawbson">rawbson</a></div><div class="desc docblock-short">Construct a <a href="raw/enum.RawBson.html" title="enum bson::raw::RawBson"><code>crate::RawBson</code></a> value from a literal.</div></li><li><div class="item-name"><a class="macro" href="macro.rawdoc.html" title="macro bson::rawdoc">rawdoc</a></div><div class="desc docblock-short">Construct a <a href="raw/struct.RawDocumentBuf.html" title="struct bson::raw::RawDocumentBuf"><code>crate::RawDocumentBuf</code></a> value.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Binary.html" title="struct bson::Binary">Binary</a></div><div class="desc docblock-short">Represents a BSON binary value.</div></li><li><div class="item-name"><a class="struct" href="struct.DateTime.html" title="struct bson::DateTime">DateTime</a></div><div class="desc docblock-short">Struct representing a BSON datetime.
Note: BSON datetimes have millisecond precision.</div></li><li><div class="item-name"><a class="struct" href="struct.DbPointer.html" title="struct bson::DbPointer">DbPointer</a></div><div class="desc docblock-short">Represents a DBPointer. (Deprecated)</div></li><li><div class="item-name"><a class="struct" href="struct.Decimal128.html" title="struct bson::Decimal128">Decimal128</a></div><div class="desc docblock-short">Struct representing a BSON Decimal128 type.</div></li><li><div class="item-name"><a class="struct" href="struct.Deserializer.html" title="struct bson::Deserializer">Deserializer</a></div><div class="desc docblock-short">Serde Deserializer</div></li><li><div class="item-name"><a class="struct" href="struct.DeserializerOptions.html" title="struct bson::DeserializerOptions">DeserializerOptions</a></div><div class="desc docblock-short">Options used to configure a <a href="de/struct.Deserializer.html" title="struct bson::de::Deserializer"><code>Deserializer</code></a>. These can also be passed into
<a href="fn.from_bson_with_options.html" title="fn bson::from_bson_with_options"><code>crate::from_bson_with_options</code></a> and <a href="fn.from_document_with_options.html" title="fn bson::from_document_with_options"><code>crate::from_document_with_options</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Document.html" title="struct bson::Document">Document</a></div><div class="desc docblock-short">A BSON document represented as an associative HashMap with insertion ordering.</div></li><li><div class="item-name"><a class="struct" href="struct.JavaScriptCodeWithScope.html" title="struct bson::JavaScriptCodeWithScope">JavaScriptCodeWithScope</a></div><div class="desc docblock-short">Represents a BSON code with scope value.</div></li><li><div class="item-name"><a class="struct" href="struct.RawArray.html" title="struct bson::RawArray">RawArray</a></div><div class="desc docblock-short">A slice of a BSON document containing a BSON array value (akin to <a href="https://doc.rust-lang.org/1.72.0/alloc/str/index.html" title="mod alloc::str"><code>std::str</code></a>). This can be
retrieved from a <a href="raw/struct.RawDocument.html" title="struct bson::raw::RawDocument"><code>RawDocument</code></a> via <a href="raw/struct.RawDocument.html#method.get" title="method bson::raw::RawDocument::get"><code>RawDocument::get</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.RawArrayBuf.html" title="struct bson::RawArrayBuf">RawArrayBuf</a></div><div class="desc docblock-short">An owned BSON array value (akin to <a href="https://doc.rust-lang.org/1.72.0/std/path/struct.PathBuf.html" title="struct std::path::PathBuf"><code>std::path::PathBuf</code></a>), backed by a buffer of raw BSON
bytes. This type can be used to construct owned array values, which can be used to append to
<a href="raw/struct.RawDocumentBuf.html" title="struct bson::raw::RawDocumentBuf"><code>RawDocumentBuf</code></a> or as a field in a <a href="../serde/de/trait.Deserialize.html" title="trait serde::de::Deserialize"><code>Deserialize</code></a> struct.</div></li><li><div class="item-name"><a class="struct" href="struct.RawBinaryRef.html" title="struct bson::RawBinaryRef">RawBinaryRef</a></div><div class="desc docblock-short">A BSON binary value referencing raw bytes stored elsewhere.</div></li><li><div class="item-name"><a class="struct" href="struct.RawDbPointerRef.html" title="struct bson::RawDbPointerRef">RawDbPointerRef</a></div><div class="desc docblock-short">A BSON DB pointer value referencing raw bytes stored elesewhere.</div></li><li><div class="item-name"><a class="struct" href="struct.RawDocument.html" title="struct bson::RawDocument">RawDocument</a></div><div class="desc docblock-short">A slice of a BSON document (akin to <a href="https://doc.rust-lang.org/1.72.0/alloc/str/index.html" title="mod alloc::str"><code>std::str</code></a>). This can be created from a
<a href="raw/struct.RawDocumentBuf.html" title="struct bson::raw::RawDocumentBuf"><code>RawDocumentBuf</code></a> or any type that contains valid BSON data, including static binary literals,
<a href="https://doc.rust-lang.org/1.72.0/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec"><code>Vec&lt;u8&gt;</code></a>, or arrays.</div></li><li><div class="item-name"><a class="struct" href="struct.RawDocumentBuf.html" title="struct bson::RawDocumentBuf">RawDocumentBuf</a></div><div class="desc docblock-short">An owned BSON document (akin to <a href="https://doc.rust-lang.org/1.72.0/std/path/struct.PathBuf.html" title="struct std::path::PathBuf"><code>std::path::PathBuf</code></a>), backed by a buffer of raw BSON bytes.
This can be created from a <code>Vec&lt;u8&gt;</code> or a <a href="struct.Document.html" title="struct bson::Document"><code>crate::Document</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.RawJavaScriptCodeWithScope.html" title="struct bson::RawJavaScriptCodeWithScope">RawJavaScriptCodeWithScope</a></div><div class="desc docblock-short">A BSON “code with scope” value backed by owned raw BSON.</div></li><li><div class="item-name"><a class="struct" href="struct.RawJavaScriptCodeWithScopeRef.html" title="struct bson::RawJavaScriptCodeWithScopeRef">RawJavaScriptCodeWithScopeRef</a></div><div class="desc docblock-short">A BSON “code with scope” value referencing raw bytes stored elsewhere.</div></li><li><div class="item-name"><a class="struct" href="struct.RawRegexRef.html" title="struct bson::RawRegexRef">RawRegexRef</a></div><div class="desc docblock-short">A BSON regex referencing raw bytes stored elsewhere.</div></li><li><div class="item-name"><a class="struct" href="struct.Regex.html" title="struct bson::Regex">Regex</a></div><div class="desc docblock-short">Represents a BSON regular expression value.</div></li><li><div class="item-name"><a class="struct" href="struct.Serializer.html" title="struct bson::Serializer">Serializer</a></div><div class="desc docblock-short">Serde Serializer</div></li><li><div class="item-name"><a class="struct" href="struct.SerializerOptions.html" title="struct bson::SerializerOptions">SerializerOptions</a></div><div class="desc docblock-short">Options used to configure a <a href="ser/struct.Serializer.html" title="struct bson::ser::Serializer"><code>Serializer</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Timestamp.html" title="struct bson::Timestamp">Timestamp</a></div><div class="desc docblock-short">Represents a BSON timestamp value.</div></li><li><div class="item-name"><a class="struct" href="struct.Uuid.html" title="struct bson::Uuid">Uuid</a></div><div class="desc docblock-short">A struct modeling a BSON UUID value (i.e. a Binary value with subtype 4).</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Bson.html" title="enum bson::Bson">Bson</a></div><div class="desc docblock-short">Possible BSON value types.</div></li><li><div class="item-name"><a class="enum" href="enum.RawBson.html" title="enum bson::RawBson">RawBson</a></div><div class="desc docblock-short">A BSON value backed by owned raw BSON bytes.</div></li><li><div class="item-name"><a class="enum" href="enum.RawBsonRef.html" title="enum bson::RawBsonRef">RawBsonRef</a></div><div class="desc docblock-short">A BSON value referencing raw bytes stored elsewhere.</div></li><li><div class="item-name"><a class="enum" href="enum.UuidRepresentation.html" title="enum bson::UuidRepresentation">UuidRepresentation</a></div><div class="desc docblock-short">Enum of the possible representations to use when converting between <a href="struct.Uuid.html" title="struct bson::Uuid"><code>Uuid</code></a> and <a href="struct.Binary.html" title="struct bson::Binary"><code>Binary</code></a>.
This enum is necessary because the different drivers used to have different ways of encoding
UUIDs, with the BSON subtype: 0x03 (UUID old).
If a UUID has been serialized with a particular representation, it MUST
be deserialized with the same representation.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.from_bson.html" title="fn bson::from_bson">from_bson</a></div><div class="desc docblock-short">Deserialize a <code>T</code> from the provided <a href="enum.Bson.html" title="enum bson::Bson"><code>Bson</code></a> value.</div></li><li><div class="item-name"><a class="fn" href="fn.from_bson_with_options.html" title="fn bson::from_bson_with_options">from_bson_with_options</a></div><div class="desc docblock-short">Deserialize a <code>T</code> from the provided <a href="enum.Bson.html" title="enum bson::Bson"><code>Bson</code></a> value, configuring the underlying
deserializer with the provided options.</div></li><li><div class="item-name"><a class="fn" href="fn.from_document.html" title="fn bson::from_document">from_document</a></div><div class="desc docblock-short">Deserialize a <code>T</code> from the provided <a href="struct.Document.html" title="struct bson::Document"><code>Document</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.from_document_with_options.html" title="fn bson::from_document_with_options">from_document_with_options</a></div><div class="desc docblock-short">Deserialize a <code>T</code> from the provided <a href="struct.Document.html" title="struct bson::Document"><code>Document</code></a>, configuring the underlying
deserializer with the provided options.</div></li><li><div class="item-name"><a class="fn" href="fn.from_reader.html" title="fn bson::from_reader">from_reader</a></div><div class="desc docblock-short">Deserialize an instance of type <code>T</code> from an I/O stream of BSON.</div></li><li><div class="item-name"><a class="fn" href="fn.from_reader_utf8_lossy.html" title="fn bson::from_reader_utf8_lossy">from_reader_utf8_lossy</a></div><div class="desc docblock-short">Deserialize an instance of type <code>T</code> from an I/O stream of BSON, replacing any invalid UTF-8
sequences with the Unicode replacement character.</div></li><li><div class="item-name"><a class="fn" href="fn.from_slice.html" title="fn bson::from_slice">from_slice</a></div><div class="desc docblock-short">Deserialize an instance of type <code>T</code> from a slice of BSON bytes.</div></li><li><div class="item-name"><a class="fn" href="fn.from_slice_utf8_lossy.html" title="fn bson::from_slice_utf8_lossy">from_slice_utf8_lossy</a></div><div class="desc docblock-short">Deserialize an instance of type <code>T</code> from a slice of BSON bytes, replacing any invalid UTF-8
sequences with the Unicode replacement character.</div></li><li><div class="item-name"><a class="fn" href="fn.to_bson.html" title="fn bson::to_bson">to_bson</a></div><div class="desc docblock-short">Encode a <code>T</code> Serializable into a <a href="enum.Bson.html" title="enum bson::Bson"><code>Bson</code></a> value.</div></li><li><div class="item-name"><a class="fn" href="fn.to_bson_with_options.html" title="fn bson::to_bson_with_options">to_bson_with_options</a></div><div class="desc docblock-short">Encode a <code>T</code> into a <a href="enum.Bson.html" title="enum bson::Bson"><code>Bson</code></a> value, configuring the underlying serializer with the provided
options.</div></li><li><div class="item-name"><a class="fn" href="fn.to_document.html" title="fn bson::to_document">to_document</a></div><div class="desc docblock-short">Encode a <code>T</code> Serializable into a BSON <a href="struct.Document.html" title="struct bson::Document"><code>Document</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.to_document_with_options.html" title="fn bson::to_document_with_options">to_document_with_options</a></div><div class="desc docblock-short">Encode a <code>T</code> into a <a href="struct.Document.html" title="struct bson::Document"><code>Document</code></a>, configuring the underlying serializer with the provided
options.</div></li><li><div class="item-name"><a class="fn" href="fn.to_raw_document_buf.html" title="fn bson::to_raw_document_buf">to_raw_document_buf</a></div><div class="desc docblock-short">Serialize the given <code>T</code> as a <a href="raw/struct.RawDocumentBuf.html" title="struct bson::raw::RawDocumentBuf"><code>RawDocumentBuf</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.to_vec.html" title="fn bson::to_vec">to_vec</a></div><div class="desc docblock-short">Serialize the given <code>T</code> as a BSON byte vector.</div></li></ul><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Array.html" title="type bson::Array">Array</a></div><div class="desc docblock-short">Alias for <code>Vec&lt;Bson&gt;</code>.</div></li></ul></section></div></main></body></html>