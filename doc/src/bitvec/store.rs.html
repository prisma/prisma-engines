<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.22.3/src/store.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>store.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../bitvec/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
</pre><pre class="rust"><code><span class="doccomment">/*! Memory modeling.

This module provides the [`BitStore`] trait, which contains all of the logic
required to perform memory accesses from a data structure handle.

# `bitvec` Memory Model

`bitvec` considers all memory within [`BitSlice`] regions as if it were composed
of discrete bits, each divisible and indipendent from its neighbors, just as the
Rust memory model considers elements `T` in a slice `[T]`. Much as ordinary byte
slices `[u8]` provide an API where each byte is distinct and independent from
its neighbors, but the underlying processor silicon clusters them in words and
cachelines, both the processor silicon *and* the Rust compiler require that bits
in a `BitSlice` be grouped into memory elements, and collectively subjected to
aliasing rules within their batch.

`bitvec` manages this through the [`BitStore`] trait. It is implemented on three
type families available from the Rust standard libraries:

- [unsigned integers]
- [atomic] unsigned integers
- [`Cell`] wrappers of unsigned integers

`bitvec` receives a memory region typed with one of these three families and
wraps it in one of its data structures based on [`BitSlice`]. The target
processor is responsible for handling any contention between memory elements;
this is irrelevant to the `bitvec` model. `bitvec` is solely responsible for
proving to the Rust compiler that all memory accesses through its types are
correctly managed according to the `&amp;`/`&amp;mut` shared/exclusion reference model,
and the [`UnsafeCell`] shared-mutation model.

Through [`BitStore`], `bitvec` is able to demonstrate that `&amp;mut BitSlice`
references to a region of *bits* have no other `BitSlice` references capable of
viewing those bits. However, `&amp;mut BitSlice` references *may* have other
`&amp;BitSlice` references capable of viewing the memory elements at locations that
it modifies, and the Rust compiler considers it undefined behavior for such
conditions to allow racing writes and reads without synchronization.

As such, [`BitStore`] provides a closed type-system graph that the [`BitSlice`]
API uses to mark events that can induce aliases to memory locations. When a
`&amp;mut BitSlice&lt;_, T&gt;` typed with an ordinary unsigned integer use any of the
APIs that call [`.split_at_mut()`], it transitions to
`&amp;mut BitSlice&lt;_, T::Alias&gt;`. The [`::Alias`] associated type is always a type
that manages aliasing references to a single memory location: either an [atomic]
unsigned integer `T` or a [`Cell`] of the unsigned integer `T`. The Rust
standard library guarantees that these types will behave correctly when multiple
references to a single location attempt to read from and write to it.

The [atomic] and [`Cell`] types stay as themselves when [`BitSlice`] introduces
aliasing conditions, as they are already alias-aware.

Lastly, the `bitvec` memory description model as implemented in the [`domain`]
module is able to perform the inverse transition: where it can demonstrate a
static awareness that the `&amp;`/`&amp;mut` exclusion rules are satisfied for a
particular element slice `[T]`, it may apply the [`::Unalias`] marker to undo
any `::Alias`ing, and present a type that has no more aliasing protection than
that with which the memory region was initially declared.

Namely, this means that the [atomic] and [`Cell`] wrappers will never be removed
from a region that had them before it was given to `bitvec`, while a region of
ordinary integers may regain the ability to be viewed without synchrony guards
if `bitvec` can prove safety in the [`domain`] module.

In order to retain `bitvec`’s promise that an `&amp;mut BitSlice&lt;_, T&gt;` has the sole
right of observation for all bits in its region, the unsigned integers alias to
a crate-internal wrapper over the alias-capable standard-library types. This
wrapper forbids mutation through shared references, so two [`BitSlice`]
references that alias a memory location, but do not overlap in bits, may not be
coërced to interfere with each other.

[atomic]: core::sync::atomic
[unsigned integers]: core::primitive
[`BitSlice`]: crate::slice::BitSlice
[`BitStore`]: crate::store::BitStore
[`Cell`]: core::cell::Cell
[`UnsafeCell`]: core::cell::UnsafeCell
[`domain`]: crate::domain
[`::Alias`]: crate::store::BitStore::Alias
[`::Unalias`]: crate::store::BitStore::Unalias
[`.split_at_mut()`]: crate::slice::BitSlice::split_at_mut
!*/</span>

<span class="kw">use</span> <span class="ident">core</span>::{
	<span class="ident">cell::Cell</span>,
	<span class="ident">fmt::Debug</span>,
};

<span class="kw">use</span> <span class="ident">tap::pipe::Pipe</span>;

<span class="kw">use</span> <span class="kw">crate</span>::{
	<span class="ident">access</span>::<span class="kw-2">*</span>,
	<span class="ident">index</span>::{
		<span class="ident">BitIdx</span>,
		<span class="ident">BitMask</span>,
	},
	<span class="ident">mem</span>::{
		<span class="self">self</span>,
		<span class="ident">BitRegister</span>,
	},
	<span class="ident">order::BitOrder</span>,
};

<span class="doccomment">/** Common interface for memory regions.

This trait is used to describe how [`BitSlice`] regions interact with the memory
bus when reading to or writing from locations. It manages the behavior required
when locations are contended for write permissions by multiple handles, and
ensures that Rust’s `&amp;`/`&amp;mut` shared/exclusion system, as well as its
[`UnsafeCell`] shared-mutation system, are upheld for individual bits as well as
for the memory operations that power the slice.

This trait is publicly implemented on the unsigned integers that implement
[`BitRegister`], their [`Cell`] wrappers, and (if present) their [atomic]
variants. You may freely construct [`BitSlice`] regions over elements or slices
of any of these types.

Shared [`BitSlice`] references (`&amp;BitSlice&lt;_, T: BitStore&gt;`) permit multiple
handles to view the bits they describe. When `T` is a [`Cell`] or [atom], these
handles may use the methods [`.set_aliased()`] and [`.set_aliased_unchecked()`]
to modify memory; when `T` is an ordinary integer, they may not.

Exclusive [`BitSlice`] references (`&amp;mut BitSlice&lt;_, T: BitStore&gt;`) do not allow
any other handle to view the bits they describe. However, other handles may view
the **memory locations** containing their bits! When `T` is a [`Cell`] or
[atom], no special behavior occurs. When `T` is an ordinary integer, [`bitvec`]
detects the creation of multiple `&amp;mut BitSlice&lt;_, T&gt;` handles that do not alias
bits but *do* alias memory, and enforces that these handles use `Cell` or atomic
behavior to access the underlying memory, even though individual bits in the
slices are not contended.

# Integer Width Restricitons

Currently, [`bitvec`] is only tested on 32- and 64- bit architectures. This
means that `u8`, `u16`, `u32`, and `usize` unconditionally implement `BitStore`,
but `u64` will only do so on 64-bit targets. This is a necessary restriction of
`bitvec` internals. Please comment on [Issue #76] if this affects you.

[Issue #76]: https://github.com/myrrlyn/bitvec/issues/76
[atom]: core::sync::atomic
[atomic]: core::sync::atomic
[`BitSlice`]: crate::slice::BitSlice
[`BitRegister`]: crate::mem::BitRegister
[`Cell`]: core::cell::Cell
[`UnsafeCell`]: core::cell::UnsafeCell
[`bitvec`]: crate
[`.set_aliased()`]: crate::slice::BitSlice::set_aliased
[`.set_aliased_unchecked()`]: crate::slice::BitSlice::set_aliased_unchecked
**/</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">BitStore</span>: <span class="lifetime">&#39;static</span> <span class="op">+</span> <span class="ident">seal::Sealed</span> <span class="op">+</span> <span class="ident">Debug</span> {
	<span class="doccomment">/// The register type used in the slice region underlying a [`BitSlice`]</span>
	<span class="doccomment">/// handle. It is always an unsigned integer.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitSlice`]: crate::slice::BitSlice</span>
	<span class="kw">type</span> <span class="ident">Mem</span>: <span class="ident">BitRegister</span> <span class="op">+</span> <span class="ident">BitStore</span><span class="op">&lt;</span><span class="ident">Mem</span> <span class="op">=</span> <span class="ident"><span class="self">Self</span>::Mem</span><span class="op">&gt;</span>;
	<span class="doccomment">/// A type that selects appropriate load/store instructions used for</span>
	<span class="doccomment">/// accessing the memory bus. It determines what instructions are used when</span>
	<span class="doccomment">/// moving a `Self::Mem` value between the processor and the memory system.</span>
	<span class="kw">type</span> <span class="ident">Access</span>: <span class="ident">BitAccess</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident"><span class="self">Self</span>::Mem</span><span class="op">&gt;</span> <span class="op">+</span> <span class="ident">BitStore</span><span class="op">&lt;</span><span class="ident">Mem</span> <span class="op">=</span> <span class="ident"><span class="self">Self</span>::Mem</span><span class="op">&gt;</span>;
	<span class="doccomment">/// A sibling `BitStore` implementor. It is used when a [`BitSlice`]</span>
	<span class="doccomment">/// introduces multiple handles that view the same memory location, and at</span>
	<span class="doccomment">/// least one of them has write permission to it.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitSlice`]: crate::slice::BitSlice</span>
	<span class="kw">type</span> <span class="ident">Alias</span>: <span class="ident">BitStore</span><span class="op">&lt;</span><span class="ident">Mem</span> <span class="op">=</span> <span class="ident"><span class="self">Self</span>::Mem</span><span class="op">&gt;</span>;
	<span class="doccomment">/// The inverse of `Alias`. It is used when a [`BitSlice`] removes the</span>
	<span class="doccomment">/// conditions that required a `T -&gt; T::Alias` transition.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitSlice`]: crate::slice::BitSlice</span>
	<span class="kw">type</span> <span class="ident">Unalias</span>: <span class="ident">BitStore</span><span class="op">&lt;</span><span class="ident">Mem</span> <span class="op">=</span> <span class="ident"><span class="self">Self</span>::Mem</span><span class="op">&gt;</span>;

	<span class="doccomment">/// Loads a value out of the memory system according to the `::Access`</span>
	<span class="doccomment">/// rules.</span>
	<span class="kw">fn</span> <span class="ident">load_value</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident"><span class="self">Self</span>::Mem</span>;

	<span class="doccomment">/// Stores a value into the memory system according to the `::Access` rules.</span>
	<span class="kw">fn</span> <span class="ident">store_value</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">value</span>: <span class="ident"><span class="self">Self</span>::Mem</span>);

	<span class="doccomment">/// Reads a single bit out of the memory system according to the `::Access`</span>
	<span class="doccomment">/// rules. This is lifted from [`BitAccess`] so that it can be used</span>
	<span class="doccomment">/// elsewhere without additional casts.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Type Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `O`: The ordering of bits within `Self::Mem` to use for looking up the</span>
	<span class="doccomment">///   bit at `index`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">/// - `index`: The semantic index of the bit in `*self` to read.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The value of the bit in `*self` at `index`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitAccess`]: crate::access::BitAccess</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">fn</span> <span class="ident">get_bit</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">index</span>: <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident"><span class="self">Self</span>::Mem</span><span class="op">&gt;</span>) -&gt; <span class="ident">bool</span>
	<span class="kw">where</span> <span class="ident">O</span>: <span class="ident">BitOrder</span> {
		<span class="self">self</span>.<span class="ident">load_value</span>()
			.<span class="ident">pipe</span>(<span class="ident">BitMask::new</span>)
			.<span class="ident">test</span>(<span class="ident">index</span>.<span class="ident">select</span>::<span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>())
	}

	<span class="doccomment">/// Require that all implementors are aligned to their width.</span>
	<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
	<span class="kw">const</span> <span class="ident">__ALIGNED_TO_SIZE</span>: [(); <span class="number">0</span>];

	<span class="doccomment">/// Require that the `::Alias` associated type has the same width and</span>
	<span class="doccomment">/// alignment as `Self`.</span>
	<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
	<span class="kw">const</span> <span class="ident">__ALIAS_WIDTH</span>: [(); <span class="number">0</span>];
}

<span class="doccomment">/// Batch implementation of `BitStore` on integers, safety wrappers, and `Cell`s</span>
<span class="macro">macro_rules!</span> <span class="ident">store</span> {
	( $(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">base</span>:<span class="ident">ty</span> =&gt; <span class="macro-nonterminal">$</span><span class="macro-nonterminal">safe</span>:<span class="ident">ty</span>),<span class="op">+</span> $(,)<span class="question-mark">?</span> ) =&gt; { $(
		<span class="kw">impl</span> <span class="ident">BitStore</span> <span class="kw">for</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">base</span> {
			<span class="kw">type</span> <span class="ident">Mem</span> <span class="op">=</span> <span class="self">Self</span>;
			<span class="doccomment">/// The unsigned integers will only be `BitStore` type parameters</span>
			<span class="doccomment">/// for handles to unaliased memory, following the normal Rust</span>
			<span class="doccomment">/// reference rules.</span>
			<span class="kw">type</span> <span class="ident">Access</span> <span class="op">=</span> <span class="ident">Cell</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">base</span><span class="op">&gt;</span>;
			<span class="kw">type</span> <span class="ident">Alias</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">safe</span>;
			<span class="kw">type</span> <span class="ident">Unalias</span> <span class="op">=</span> <span class="self">Self</span>;

			<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
			<span class="kw">fn</span> <span class="ident">load_value</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident"><span class="self">Self</span>::Mem</span> {
				<span class="kw-2">*</span><span class="self">self</span>
			}

			<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
			<span class="kw">fn</span> <span class="ident">store_value</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">value</span>: <span class="ident"><span class="self">Self</span>::Mem</span>) {
				<span class="kw-2">*</span><span class="self">self</span> <span class="op">=</span> <span class="ident">value</span>;
			}

			<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
			<span class="kw">const</span> <span class="ident">__ALIGNED_TO_SIZE</span>: [(); <span class="number">0</span>]
				<span class="op">=</span> [(); <span class="ident">mem::aligned_to_size</span>::<span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span>()];

			<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
			<span class="kw">const</span> <span class="ident">__ALIAS_WIDTH</span>: [(); <span class="number">0</span>]
				<span class="op">=</span> [(); <span class="ident">mem::cmp_layout</span>::<span class="op">&lt;</span><span class="self">Self</span>, <span class="ident"><span class="self">Self</span>::Alias</span><span class="op">&gt;</span>()];
		}

		<span class="doccomment">/// This type is only ever produced by calling [`.split_at_mut()`] on</span>
		<span class="doccomment">/// [`BitSlice&lt;_, T&gt;`] where `T` is an unsigned integer. It cannot be</span>
		<span class="doccomment">/// constructed as a base data source.</span>
		<span class="doccomment">///</span>
		<span class="doccomment">/// [`BitSlice&lt;_, T&gt;`]: crate::slice::BitSlice</span>
		<span class="doccomment">/// [`.split_at_mut()`]: crate::slice::BitSlice::split_at_mut</span>
		<span class="kw">impl</span> <span class="ident">BitStore</span> <span class="kw">for</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">safe</span> {
			<span class="kw">type</span> <span class="ident">Mem</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">base</span>;
			<span class="kw">type</span> <span class="ident">Access</span> <span class="op">=</span> <span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">BitSafe</span><span class="op">&gt;</span><span class="ident">::Rad</span>;
			<span class="kw">type</span> <span class="ident">Alias</span> <span class="op">=</span> <span class="self">Self</span>;
			<span class="kw">type</span> <span class="ident">Unalias</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">base</span>;

			<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
			<span class="kw">fn</span> <span class="ident">load_value</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident"><span class="self">Self</span>::Mem</span> {
				<span class="self">self</span>.<span class="ident">load</span>()
			}

			<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
			<span class="kw">fn</span> <span class="ident">store_value</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">value</span>: <span class="ident"><span class="self">Self</span>::Mem</span>) {
				<span class="self">self</span>.<span class="ident">store</span>(<span class="ident">value</span>);
			}

			<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
			<span class="kw">const</span> <span class="ident">__ALIGNED_TO_SIZE</span>: [(); <span class="number">0</span>]
				<span class="op">=</span> [(); <span class="ident">mem::aligned_to_size</span>::<span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span>()];

			<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
			<span class="kw">const</span> <span class="ident">__ALIAS_WIDTH</span>: [(); <span class="number">0</span>]
				<span class="op">=</span> [(); <span class="ident">mem::cmp_layout</span>::<span class="op">&lt;</span><span class="self">Self</span>, <span class="ident"><span class="self">Self</span>::Unalias</span><span class="op">&gt;</span>()];
		}

		<span class="kw">impl</span> <span class="ident">BitStore</span> <span class="kw">for</span> <span class="ident">Cell</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">base</span><span class="op">&gt;</span> {
			<span class="kw">type</span> <span class="ident">Mem</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">base</span>;
			<span class="kw">type</span> <span class="ident">Access</span> <span class="op">=</span> <span class="self">Self</span>;
			<span class="kw">type</span> <span class="ident">Alias</span> <span class="op">=</span> <span class="self">Self</span>;
			<span class="kw">type</span> <span class="ident">Unalias</span> <span class="op">=</span> <span class="self">Self</span>;

			<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
			<span class="kw">fn</span> <span class="ident">load_value</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident"><span class="self">Self</span>::Mem</span> {
				<span class="self">self</span>.<span class="ident">get</span>()
			}

			<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
			<span class="kw">fn</span> <span class="ident">store_value</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">value</span>: <span class="ident"><span class="self">Self</span>::Mem</span>) {
				<span class="self">self</span>.<span class="ident">set</span>(<span class="ident">value</span>);
			}

			<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
			<span class="kw">const</span> <span class="ident">__ALIGNED_TO_SIZE</span>: [(); <span class="number">0</span>]
				<span class="op">=</span> [(); <span class="ident">mem::aligned_to_size</span>::<span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span>()];

			<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
			<span class="kw">const</span> <span class="ident">__ALIAS_WIDTH</span>: [(); <span class="number">0</span>] <span class="op">=</span> [];
		}

		<span class="kw">impl</span> <span class="ident">seal::Sealed</span> <span class="kw">for</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">base</span> {}
		<span class="kw">impl</span> <span class="ident">seal::Sealed</span> <span class="kw">for</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">safe</span> {}
		<span class="kw">impl</span> <span class="ident">seal::Sealed</span> <span class="kw">for</span> <span class="ident">Cell</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">base</span><span class="op">&gt;</span> {}
	)<span class="op">+</span> };
}

<span class="macro">store!</span> {
	<span class="ident">u8</span> =&gt; <span class="ident">BitSafeU8</span>,
	<span class="ident">u16</span> =&gt; <span class="ident">BitSafeU16</span>,
	<span class="ident">u32</span> =&gt; <span class="ident">BitSafeU32</span>,
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_pointer_width</span> <span class="op">=</span> <span class="string">&quot;64&quot;</span>)]</span>
<span class="macro">store!</span>(<span class="ident">u64</span> =&gt; <span class="ident">BitSafeU64</span>);

<span class="macro">store!</span>(<span class="ident">usize</span> =&gt; <span class="ident">BitSafeUsize</span>);

<span class="macro">macro_rules!</span> <span class="ident">atomic_store</span> {
	($(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">w</span>:<span class="ident">tt</span> , <span class="macro-nonterminal">$</span><span class="macro-nonterminal">base</span>:<span class="ident">ty</span> =&gt; <span class="macro-nonterminal">$</span><span class="macro-nonterminal">atom</span>:<span class="ident">ident</span>);<span class="op">+</span> $(;)<span class="question-mark">?</span>) =&gt; { $(
		<span class="macro">radium::if_atomic!</span>(<span class="kw">if</span> <span class="ident">atomic</span>(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">w</span>) {
			<span class="kw">use</span> <span class="ident">core::sync::atomic</span>::<span class="macro-nonterminal">$</span><span class="macro-nonterminal">atom</span>;

			<span class="kw">impl</span> <span class="ident">BitStore</span> <span class="kw">for</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">atom</span> {
				<span class="kw">type</span> <span class="ident">Mem</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">base</span>;
				<span class="kw">type</span> <span class="ident">Access</span> <span class="op">=</span> <span class="self">Self</span>;
				<span class="kw">type</span> <span class="ident">Alias</span> <span class="op">=</span> <span class="self">Self</span>;
				<span class="kw">type</span> <span class="ident">Unalias</span> <span class="op">=</span> <span class="self">Self</span>;

				<span class="attribute">#[<span class="ident">inline</span>]</span>
				<span class="kw">fn</span> <span class="ident">load_value</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident"><span class="self">Self</span>::Mem</span> {
					<span class="self">self</span>.<span class="ident">load</span>(<span class="ident">core::sync::atomic::Ordering::Relaxed</span>)
				}

				<span class="attribute">#[<span class="ident">inline</span>]</span>
				<span class="kw">fn</span> <span class="ident">store_value</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">value</span>: <span class="ident"><span class="self">Self</span>::Mem</span>) {
					<span class="self">self</span>.<span class="ident">store</span>(<span class="ident">value</span>, <span class="ident">core::sync::atomic::Ordering::Relaxed</span>);
				}

				<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
				<span class="kw">const</span> <span class="ident">__ALIGNED_TO_SIZE</span>: [(); <span class="number">0</span>]
					<span class="op">=</span> [(); <span class="ident">mem::aligned_to_size</span>::<span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span>()];

				<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
				<span class="kw">const</span> <span class="ident">__ALIAS_WIDTH</span>: [(); <span class="number">0</span>] <span class="op">=</span> [];
			}

			<span class="kw">impl</span> <span class="ident">seal::Sealed</span> <span class="kw">for</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">atom</span> {}
		});
	)<span class="op">+</span> };
}

<span class="macro">atomic_store!</span> {
	<span class="number">8</span>, <span class="ident">u8</span> =&gt; <span class="ident">AtomicU8</span>;
	<span class="number">16</span>, <span class="ident">u16</span> =&gt; <span class="ident">AtomicU16</span>;
	<span class="number">32</span>, <span class="ident">u32</span> =&gt; <span class="ident">AtomicU32</span>;
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_pointer_width</span> <span class="op">=</span> <span class="string">&quot;64&quot;</span>)]</span>
<span class="macro">atomic_store!</span>(<span class="number">64</span>, <span class="ident">u64</span> =&gt; <span class="ident">AtomicU64</span>);

<span class="macro">atomic_store!</span>(<span class="ident">size</span>, <span class="ident">usize</span> =&gt; <span class="ident">AtomicUsize</span>);

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">any</span>(<span class="ident">target_pointer_width</span> <span class="op">=</span> <span class="string">&quot;32&quot;</span>, <span class="ident">target_pointer_width</span> <span class="op">=</span> <span class="string">&quot;64&quot;</span>)))]</span>
<span class="macro">compile_fail!</span>(<span class="macro">concat!</span>(
	<span class="string">&quot;This architecture is currently not supported. File an issue at &quot;</span>,
	<span class="macro">env!</span>(<span class="string">&quot;CARGO_PKG_REPOSITORY&quot;</span>)
));

<span class="doccomment">/// Enclose the `Sealed` trait against client use.</span>
<span class="kw">mod</span> <span class="ident">seal</span> {
	<span class="doccomment">/// Marker trait to seal `BitStore` against downstream implementation.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This trait is public in the module, so that other modules in the crate</span>
	<span class="doccomment">/// can use it, but so long as it is not exported by the crate root and this</span>
	<span class="doccomment">/// module is private, this trait effectively forbids downstream</span>
	<span class="doccomment">/// implementation of the `BitStore` trait.</span>
	<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
	<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">Sealed</span> {}
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
<span class="kw">mod</span> <span class="ident">tests</span> {
	<span class="kw">use</span> <span class="ident">core::cell::Cell</span>;

	<span class="kw">use</span> <span class="ident">static_assertions</span>::<span class="kw-2">*</span>;

	<span class="kw">use</span> <span class="kw">super</span>::<span class="kw-2">*</span>;
	<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::prelude</span>::<span class="kw-2">*</span>;

	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="kw">fn</span> <span class="ident">load_store</span>() {
		<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">word</span> <span class="op">=</span> <span class="number">0usize</span>;

		<span class="ident">word</span>.<span class="ident">store_value</span>(<span class="number">39usize</span>);
		<span class="macro">assert_eq!</span>(<span class="ident">word</span>.<span class="ident">load_value</span>(), <span class="number">39usize</span>);

		<span class="kw">let</span> <span class="ident">safe</span>: <span class="kw-2">&amp;mut</span> <span class="ident">BitSafeUsize</span> <span class="op">=</span>
			<span class="kw">unsafe</span> { <span class="kw-2">&amp;mut</span> <span class="kw-2">*</span>(<span class="kw-2">&amp;mut</span> <span class="ident">word</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="kw">_</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="kw">_</span>) };
		<span class="ident">safe</span>.<span class="ident">store_value</span>(<span class="number">57usize</span>);
		<span class="macro">assert_eq!</span>(<span class="ident">safe</span>.<span class="ident">load_value</span>(), <span class="number">57</span>);

		<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cell</span> <span class="op">=</span> <span class="ident">Cell::new</span>(<span class="number">0usize</span>);
		<span class="ident">cell</span>.<span class="ident">store_value</span>(<span class="number">39</span>);
		<span class="macro">assert_eq!</span>(<span class="ident">cell</span>.<span class="ident">load_value</span>(), <span class="number">39</span>);

		<span class="macro">radium::if_atomic!</span>(<span class="kw">if</span> <span class="ident">atomic</span>(<span class="ident">size</span>) {
			<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">atom</span> <span class="op">=</span> <span class="ident">AtomicUsize::new</span>(<span class="number">0</span>);
			<span class="ident">atom</span>.<span class="ident">store_value</span>(<span class="number">39</span>);
			<span class="macro">assert_eq!</span>(<span class="ident">atom</span>.<span class="ident">load_value</span>(), <span class="number">39usize</span>);
		});
	}

	<span class="doccomment">/// Unaliased `BitSlice`s are universally threadsafe, because they satisfy</span>
	<span class="doccomment">/// Rust’s unysnchronized mutation rules.</span>
	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="kw">fn</span> <span class="ident">unaliased_send_sync</span>() {
		<span class="macro">assert_impl_all!</span>(<span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">u8</span><span class="op">&gt;</span>: <span class="ident">Send</span>, <span class="ident">Sync</span>);
		<span class="macro">assert_impl_all!</span>(<span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">u16</span><span class="op">&gt;</span>: <span class="ident">Send</span>, <span class="ident">Sync</span>);
		<span class="macro">assert_impl_all!</span>(<span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">u32</span><span class="op">&gt;</span>: <span class="ident">Send</span>, <span class="ident">Sync</span>);
		<span class="macro">assert_impl_all!</span>(<span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">usize</span><span class="op">&gt;</span>: <span class="ident">Send</span>, <span class="ident">Sync</span>);

		<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_pointer_width</span> <span class="op">=</span> <span class="string">&quot;64&quot;</span>)]</span>
		<span class="macro">assert_impl_all!</span>(<span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">u64</span><span class="op">&gt;</span>: <span class="ident">Send</span>, <span class="ident">Sync</span>);
	}

	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="kw">fn</span> <span class="ident">cell_unsend_unsync</span>() {
		<span class="macro">assert_not_impl_any!</span>(<span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span><span class="op">&gt;</span>: <span class="ident">Send</span>, <span class="ident">Sync</span>);
		<span class="macro">assert_not_impl_any!</span>(<span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span><span class="op">&gt;</span>: <span class="ident">Send</span>, <span class="ident">Sync</span>);
		<span class="macro">assert_not_impl_any!</span>(<span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span><span class="op">&gt;</span>: <span class="ident">Send</span>, <span class="ident">Sync</span>);
		<span class="macro">assert_not_impl_any!</span>(<span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span><span class="op">&gt;</span>: <span class="ident">Send</span>, <span class="ident">Sync</span>);
		<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_pointer_width</span> <span class="op">=</span> <span class="string">&quot;64&quot;</span>)]</span>
		<span class="macro">assert_not_impl_any!</span>(<span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">u64</span><span class="op">&gt;</span><span class="op">&gt;</span>: <span class="ident">Send</span>, <span class="ident">Sync</span>);
	}

	<span class="doccomment">/// In non-atomic builds, aliased `BitSlice`s become universally</span>
	<span class="doccomment">/// thread-unsafe. An `&amp;mut BitSlice` is an `&amp;Cell`, and `&amp;Cell` cannot be</span>
	<span class="doccomment">/// sent across threads.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This test cannot be meaningfully expressed in atomic builds, because the</span>
	<span class="doccomment">/// atomiticy of a `BitSafeUN` type is target-specific, and expressed in</span>
	<span class="doccomment">/// `radium` rather than in `bitvec`.</span>
	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;atomic&quot;</span>))]</span>
	<span class="kw">fn</span> <span class="ident">aliased_nonatomic_unsend_unsync</span>() {
		<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::access</span>::<span class="kw-2">*</span>;

		<span class="macro">assert_not_impl_any!</span>(<span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">BitSafeU8</span><span class="op">&gt;</span>: <span class="ident">Send</span>, <span class="ident">Sync</span>);
		<span class="macro">assert_not_impl_any!</span>(<span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">BitSafeU16</span><span class="op">&gt;</span>: <span class="ident">Send</span>, <span class="ident">Sync</span>);
		<span class="macro">assert_not_impl_any!</span>(<span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">BitSafeU32</span><span class="op">&gt;</span>: <span class="ident">Send</span>, <span class="ident">Sync</span>);
		<span class="macro">assert_not_impl_any!</span>(<span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">BitSafeUsize</span><span class="op">&gt;</span>: <span class="ident">Send</span>, <span class="ident">Sync</span>);

		<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_pointer_width</span> <span class="op">=</span> <span class="string">&quot;64&quot;</span>)]</span>
		<span class="macro">assert_not_impl_any!</span>(<span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="ident">BitSafeU64</span><span class="op">&gt;</span>: <span class="ident">Send</span>, <span class="ident">Sync</span>);
	}
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="bitvec" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>