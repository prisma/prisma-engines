<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.22.3/src/slice.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>slice.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../bitvec/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
<span id="609">609</span>
<span id="610">610</span>
<span id="611">611</span>
<span id="612">612</span>
<span id="613">613</span>
<span id="614">614</span>
<span id="615">615</span>
<span id="616">616</span>
<span id="617">617</span>
<span id="618">618</span>
<span id="619">619</span>
<span id="620">620</span>
<span id="621">621</span>
<span id="622">622</span>
<span id="623">623</span>
<span id="624">624</span>
<span id="625">625</span>
<span id="626">626</span>
<span id="627">627</span>
<span id="628">628</span>
<span id="629">629</span>
<span id="630">630</span>
<span id="631">631</span>
<span id="632">632</span>
<span id="633">633</span>
<span id="634">634</span>
<span id="635">635</span>
<span id="636">636</span>
<span id="637">637</span>
<span id="638">638</span>
<span id="639">639</span>
<span id="640">640</span>
<span id="641">641</span>
<span id="642">642</span>
<span id="643">643</span>
<span id="644">644</span>
<span id="645">645</span>
<span id="646">646</span>
<span id="647">647</span>
<span id="648">648</span>
<span id="649">649</span>
<span id="650">650</span>
<span id="651">651</span>
<span id="652">652</span>
<span id="653">653</span>
<span id="654">654</span>
<span id="655">655</span>
<span id="656">656</span>
<span id="657">657</span>
<span id="658">658</span>
<span id="659">659</span>
<span id="660">660</span>
<span id="661">661</span>
<span id="662">662</span>
<span id="663">663</span>
<span id="664">664</span>
<span id="665">665</span>
<span id="666">666</span>
<span id="667">667</span>
<span id="668">668</span>
<span id="669">669</span>
<span id="670">670</span>
<span id="671">671</span>
<span id="672">672</span>
<span id="673">673</span>
<span id="674">674</span>
<span id="675">675</span>
<span id="676">676</span>
<span id="677">677</span>
<span id="678">678</span>
<span id="679">679</span>
<span id="680">680</span>
<span id="681">681</span>
<span id="682">682</span>
<span id="683">683</span>
<span id="684">684</span>
<span id="685">685</span>
<span id="686">686</span>
<span id="687">687</span>
<span id="688">688</span>
<span id="689">689</span>
<span id="690">690</span>
<span id="691">691</span>
<span id="692">692</span>
<span id="693">693</span>
<span id="694">694</span>
<span id="695">695</span>
<span id="696">696</span>
<span id="697">697</span>
<span id="698">698</span>
<span id="699">699</span>
<span id="700">700</span>
<span id="701">701</span>
<span id="702">702</span>
<span id="703">703</span>
<span id="704">704</span>
<span id="705">705</span>
<span id="706">706</span>
<span id="707">707</span>
<span id="708">708</span>
<span id="709">709</span>
<span id="710">710</span>
<span id="711">711</span>
<span id="712">712</span>
<span id="713">713</span>
<span id="714">714</span>
<span id="715">715</span>
<span id="716">716</span>
<span id="717">717</span>
<span id="718">718</span>
<span id="719">719</span>
<span id="720">720</span>
<span id="721">721</span>
<span id="722">722</span>
<span id="723">723</span>
<span id="724">724</span>
<span id="725">725</span>
<span id="726">726</span>
<span id="727">727</span>
<span id="728">728</span>
<span id="729">729</span>
<span id="730">730</span>
<span id="731">731</span>
<span id="732">732</span>
<span id="733">733</span>
<span id="734">734</span>
<span id="735">735</span>
<span id="736">736</span>
<span id="737">737</span>
<span id="738">738</span>
<span id="739">739</span>
<span id="740">740</span>
<span id="741">741</span>
<span id="742">742</span>
<span id="743">743</span>
<span id="744">744</span>
<span id="745">745</span>
<span id="746">746</span>
<span id="747">747</span>
<span id="748">748</span>
<span id="749">749</span>
<span id="750">750</span>
<span id="751">751</span>
<span id="752">752</span>
<span id="753">753</span>
<span id="754">754</span>
<span id="755">755</span>
<span id="756">756</span>
<span id="757">757</span>
<span id="758">758</span>
<span id="759">759</span>
<span id="760">760</span>
<span id="761">761</span>
<span id="762">762</span>
<span id="763">763</span>
<span id="764">764</span>
<span id="765">765</span>
<span id="766">766</span>
<span id="767">767</span>
<span id="768">768</span>
<span id="769">769</span>
<span id="770">770</span>
<span id="771">771</span>
<span id="772">772</span>
<span id="773">773</span>
<span id="774">774</span>
<span id="775">775</span>
<span id="776">776</span>
<span id="777">777</span>
<span id="778">778</span>
<span id="779">779</span>
<span id="780">780</span>
<span id="781">781</span>
<span id="782">782</span>
<span id="783">783</span>
<span id="784">784</span>
<span id="785">785</span>
<span id="786">786</span>
<span id="787">787</span>
<span id="788">788</span>
<span id="789">789</span>
<span id="790">790</span>
<span id="791">791</span>
<span id="792">792</span>
<span id="793">793</span>
<span id="794">794</span>
<span id="795">795</span>
<span id="796">796</span>
<span id="797">797</span>
<span id="798">798</span>
<span id="799">799</span>
<span id="800">800</span>
<span id="801">801</span>
<span id="802">802</span>
<span id="803">803</span>
<span id="804">804</span>
<span id="805">805</span>
<span id="806">806</span>
<span id="807">807</span>
<span id="808">808</span>
<span id="809">809</span>
<span id="810">810</span>
<span id="811">811</span>
<span id="812">812</span>
<span id="813">813</span>
<span id="814">814</span>
<span id="815">815</span>
<span id="816">816</span>
<span id="817">817</span>
<span id="818">818</span>
<span id="819">819</span>
<span id="820">820</span>
<span id="821">821</span>
<span id="822">822</span>
<span id="823">823</span>
<span id="824">824</span>
<span id="825">825</span>
<span id="826">826</span>
<span id="827">827</span>
<span id="828">828</span>
<span id="829">829</span>
<span id="830">830</span>
<span id="831">831</span>
<span id="832">832</span>
<span id="833">833</span>
<span id="834">834</span>
<span id="835">835</span>
<span id="836">836</span>
<span id="837">837</span>
<span id="838">838</span>
<span id="839">839</span>
<span id="840">840</span>
<span id="841">841</span>
<span id="842">842</span>
<span id="843">843</span>
<span id="844">844</span>
<span id="845">845</span>
<span id="846">846</span>
<span id="847">847</span>
<span id="848">848</span>
<span id="849">849</span>
<span id="850">850</span>
<span id="851">851</span>
<span id="852">852</span>
<span id="853">853</span>
<span id="854">854</span>
<span id="855">855</span>
<span id="856">856</span>
<span id="857">857</span>
<span id="858">858</span>
<span id="859">859</span>
<span id="860">860</span>
<span id="861">861</span>
<span id="862">862</span>
<span id="863">863</span>
<span id="864">864</span>
<span id="865">865</span>
<span id="866">866</span>
<span id="867">867</span>
<span id="868">868</span>
<span id="869">869</span>
<span id="870">870</span>
<span id="871">871</span>
<span id="872">872</span>
<span id="873">873</span>
<span id="874">874</span>
<span id="875">875</span>
<span id="876">876</span>
<span id="877">877</span>
<span id="878">878</span>
<span id="879">879</span>
<span id="880">880</span>
<span id="881">881</span>
<span id="882">882</span>
<span id="883">883</span>
<span id="884">884</span>
<span id="885">885</span>
<span id="886">886</span>
<span id="887">887</span>
<span id="888">888</span>
<span id="889">889</span>
<span id="890">890</span>
<span id="891">891</span>
<span id="892">892</span>
<span id="893">893</span>
<span id="894">894</span>
<span id="895">895</span>
<span id="896">896</span>
<span id="897">897</span>
<span id="898">898</span>
<span id="899">899</span>
<span id="900">900</span>
<span id="901">901</span>
<span id="902">902</span>
<span id="903">903</span>
<span id="904">904</span>
<span id="905">905</span>
<span id="906">906</span>
<span id="907">907</span>
<span id="908">908</span>
<span id="909">909</span>
<span id="910">910</span>
<span id="911">911</span>
<span id="912">912</span>
<span id="913">913</span>
<span id="914">914</span>
<span id="915">915</span>
<span id="916">916</span>
<span id="917">917</span>
<span id="918">918</span>
<span id="919">919</span>
<span id="920">920</span>
<span id="921">921</span>
<span id="922">922</span>
<span id="923">923</span>
<span id="924">924</span>
<span id="925">925</span>
<span id="926">926</span>
<span id="927">927</span>
<span id="928">928</span>
<span id="929">929</span>
<span id="930">930</span>
<span id="931">931</span>
<span id="932">932</span>
<span id="933">933</span>
<span id="934">934</span>
<span id="935">935</span>
<span id="936">936</span>
<span id="937">937</span>
<span id="938">938</span>
<span id="939">939</span>
<span id="940">940</span>
<span id="941">941</span>
<span id="942">942</span>
<span id="943">943</span>
<span id="944">944</span>
<span id="945">945</span>
<span id="946">946</span>
<span id="947">947</span>
<span id="948">948</span>
<span id="949">949</span>
<span id="950">950</span>
<span id="951">951</span>
<span id="952">952</span>
<span id="953">953</span>
<span id="954">954</span>
<span id="955">955</span>
<span id="956">956</span>
<span id="957">957</span>
<span id="958">958</span>
<span id="959">959</span>
<span id="960">960</span>
<span id="961">961</span>
<span id="962">962</span>
<span id="963">963</span>
<span id="964">964</span>
<span id="965">965</span>
<span id="966">966</span>
<span id="967">967</span>
<span id="968">968</span>
<span id="969">969</span>
<span id="970">970</span>
<span id="971">971</span>
<span id="972">972</span>
<span id="973">973</span>
<span id="974">974</span>
<span id="975">975</span>
<span id="976">976</span>
<span id="977">977</span>
<span id="978">978</span>
<span id="979">979</span>
<span id="980">980</span>
<span id="981">981</span>
<span id="982">982</span>
<span id="983">983</span>
<span id="984">984</span>
<span id="985">985</span>
<span id="986">986</span>
<span id="987">987</span>
<span id="988">988</span>
<span id="989">989</span>
<span id="990">990</span>
<span id="991">991</span>
<span id="992">992</span>
<span id="993">993</span>
<span id="994">994</span>
<span id="995">995</span>
<span id="996">996</span>
<span id="997">997</span>
<span id="998">998</span>
<span id="999">999</span>
<span id="1000">1000</span>
<span id="1001">1001</span>
<span id="1002">1002</span>
<span id="1003">1003</span>
<span id="1004">1004</span>
<span id="1005">1005</span>
<span id="1006">1006</span>
<span id="1007">1007</span>
<span id="1008">1008</span>
<span id="1009">1009</span>
<span id="1010">1010</span>
<span id="1011">1011</span>
<span id="1012">1012</span>
<span id="1013">1013</span>
<span id="1014">1014</span>
<span id="1015">1015</span>
<span id="1016">1016</span>
<span id="1017">1017</span>
<span id="1018">1018</span>
<span id="1019">1019</span>
<span id="1020">1020</span>
<span id="1021">1021</span>
<span id="1022">1022</span>
<span id="1023">1023</span>
<span id="1024">1024</span>
<span id="1025">1025</span>
<span id="1026">1026</span>
<span id="1027">1027</span>
<span id="1028">1028</span>
<span id="1029">1029</span>
<span id="1030">1030</span>
<span id="1031">1031</span>
<span id="1032">1032</span>
<span id="1033">1033</span>
<span id="1034">1034</span>
<span id="1035">1035</span>
<span id="1036">1036</span>
<span id="1037">1037</span>
<span id="1038">1038</span>
<span id="1039">1039</span>
<span id="1040">1040</span>
<span id="1041">1041</span>
<span id="1042">1042</span>
<span id="1043">1043</span>
<span id="1044">1044</span>
<span id="1045">1045</span>
<span id="1046">1046</span>
<span id="1047">1047</span>
<span id="1048">1048</span>
<span id="1049">1049</span>
<span id="1050">1050</span>
<span id="1051">1051</span>
<span id="1052">1052</span>
<span id="1053">1053</span>
<span id="1054">1054</span>
<span id="1055">1055</span>
<span id="1056">1056</span>
<span id="1057">1057</span>
<span id="1058">1058</span>
<span id="1059">1059</span>
<span id="1060">1060</span>
<span id="1061">1061</span>
<span id="1062">1062</span>
<span id="1063">1063</span>
<span id="1064">1064</span>
<span id="1065">1065</span>
<span id="1066">1066</span>
<span id="1067">1067</span>
<span id="1068">1068</span>
<span id="1069">1069</span>
<span id="1070">1070</span>
<span id="1071">1071</span>
<span id="1072">1072</span>
<span id="1073">1073</span>
<span id="1074">1074</span>
<span id="1075">1075</span>
<span id="1076">1076</span>
<span id="1077">1077</span>
<span id="1078">1078</span>
<span id="1079">1079</span>
<span id="1080">1080</span>
<span id="1081">1081</span>
<span id="1082">1082</span>
<span id="1083">1083</span>
<span id="1084">1084</span>
<span id="1085">1085</span>
<span id="1086">1086</span>
<span id="1087">1087</span>
<span id="1088">1088</span>
<span id="1089">1089</span>
<span id="1090">1090</span>
<span id="1091">1091</span>
<span id="1092">1092</span>
<span id="1093">1093</span>
<span id="1094">1094</span>
<span id="1095">1095</span>
<span id="1096">1096</span>
<span id="1097">1097</span>
<span id="1098">1098</span>
<span id="1099">1099</span>
<span id="1100">1100</span>
<span id="1101">1101</span>
<span id="1102">1102</span>
<span id="1103">1103</span>
<span id="1104">1104</span>
<span id="1105">1105</span>
<span id="1106">1106</span>
<span id="1107">1107</span>
<span id="1108">1108</span>
<span id="1109">1109</span>
<span id="1110">1110</span>
<span id="1111">1111</span>
<span id="1112">1112</span>
<span id="1113">1113</span>
<span id="1114">1114</span>
<span id="1115">1115</span>
<span id="1116">1116</span>
<span id="1117">1117</span>
<span id="1118">1118</span>
<span id="1119">1119</span>
<span id="1120">1120</span>
<span id="1121">1121</span>
<span id="1122">1122</span>
<span id="1123">1123</span>
<span id="1124">1124</span>
<span id="1125">1125</span>
<span id="1126">1126</span>
<span id="1127">1127</span>
<span id="1128">1128</span>
<span id="1129">1129</span>
<span id="1130">1130</span>
<span id="1131">1131</span>
<span id="1132">1132</span>
<span id="1133">1133</span>
<span id="1134">1134</span>
<span id="1135">1135</span>
<span id="1136">1136</span>
<span id="1137">1137</span>
<span id="1138">1138</span>
<span id="1139">1139</span>
<span id="1140">1140</span>
<span id="1141">1141</span>
<span id="1142">1142</span>
<span id="1143">1143</span>
<span id="1144">1144</span>
<span id="1145">1145</span>
<span id="1146">1146</span>
<span id="1147">1147</span>
<span id="1148">1148</span>
<span id="1149">1149</span>
<span id="1150">1150</span>
<span id="1151">1151</span>
<span id="1152">1152</span>
<span id="1153">1153</span>
<span id="1154">1154</span>
<span id="1155">1155</span>
<span id="1156">1156</span>
<span id="1157">1157</span>
<span id="1158">1158</span>
<span id="1159">1159</span>
<span id="1160">1160</span>
<span id="1161">1161</span>
<span id="1162">1162</span>
<span id="1163">1163</span>
<span id="1164">1164</span>
<span id="1165">1165</span>
<span id="1166">1166</span>
<span id="1167">1167</span>
<span id="1168">1168</span>
<span id="1169">1169</span>
<span id="1170">1170</span>
<span id="1171">1171</span>
<span id="1172">1172</span>
<span id="1173">1173</span>
<span id="1174">1174</span>
<span id="1175">1175</span>
<span id="1176">1176</span>
<span id="1177">1177</span>
<span id="1178">1178</span>
<span id="1179">1179</span>
<span id="1180">1180</span>
<span id="1181">1181</span>
<span id="1182">1182</span>
<span id="1183">1183</span>
<span id="1184">1184</span>
<span id="1185">1185</span>
<span id="1186">1186</span>
<span id="1187">1187</span>
<span id="1188">1188</span>
<span id="1189">1189</span>
<span id="1190">1190</span>
<span id="1191">1191</span>
<span id="1192">1192</span>
<span id="1193">1193</span>
<span id="1194">1194</span>
<span id="1195">1195</span>
<span id="1196">1196</span>
<span id="1197">1197</span>
<span id="1198">1198</span>
<span id="1199">1199</span>
<span id="1200">1200</span>
<span id="1201">1201</span>
<span id="1202">1202</span>
<span id="1203">1203</span>
<span id="1204">1204</span>
<span id="1205">1205</span>
<span id="1206">1206</span>
<span id="1207">1207</span>
<span id="1208">1208</span>
<span id="1209">1209</span>
<span id="1210">1210</span>
<span id="1211">1211</span>
<span id="1212">1212</span>
<span id="1213">1213</span>
<span id="1214">1214</span>
<span id="1215">1215</span>
<span id="1216">1216</span>
<span id="1217">1217</span>
<span id="1218">1218</span>
<span id="1219">1219</span>
<span id="1220">1220</span>
<span id="1221">1221</span>
<span id="1222">1222</span>
<span id="1223">1223</span>
<span id="1224">1224</span>
<span id="1225">1225</span>
<span id="1226">1226</span>
<span id="1227">1227</span>
<span id="1228">1228</span>
<span id="1229">1229</span>
<span id="1230">1230</span>
<span id="1231">1231</span>
<span id="1232">1232</span>
<span id="1233">1233</span>
<span id="1234">1234</span>
<span id="1235">1235</span>
<span id="1236">1236</span>
<span id="1237">1237</span>
<span id="1238">1238</span>
<span id="1239">1239</span>
<span id="1240">1240</span>
<span id="1241">1241</span>
<span id="1242">1242</span>
<span id="1243">1243</span>
<span id="1244">1244</span>
<span id="1245">1245</span>
<span id="1246">1246</span>
<span id="1247">1247</span>
<span id="1248">1248</span>
<span id="1249">1249</span>
<span id="1250">1250</span>
<span id="1251">1251</span>
<span id="1252">1252</span>
<span id="1253">1253</span>
<span id="1254">1254</span>
<span id="1255">1255</span>
<span id="1256">1256</span>
<span id="1257">1257</span>
<span id="1258">1258</span>
<span id="1259">1259</span>
<span id="1260">1260</span>
<span id="1261">1261</span>
<span id="1262">1262</span>
<span id="1263">1263</span>
<span id="1264">1264</span>
<span id="1265">1265</span>
<span id="1266">1266</span>
<span id="1267">1267</span>
<span id="1268">1268</span>
<span id="1269">1269</span>
<span id="1270">1270</span>
<span id="1271">1271</span>
<span id="1272">1272</span>
<span id="1273">1273</span>
<span id="1274">1274</span>
<span id="1275">1275</span>
<span id="1276">1276</span>
<span id="1277">1277</span>
<span id="1278">1278</span>
<span id="1279">1279</span>
<span id="1280">1280</span>
<span id="1281">1281</span>
<span id="1282">1282</span>
<span id="1283">1283</span>
<span id="1284">1284</span>
<span id="1285">1285</span>
<span id="1286">1286</span>
<span id="1287">1287</span>
<span id="1288">1288</span>
<span id="1289">1289</span>
<span id="1290">1290</span>
<span id="1291">1291</span>
<span id="1292">1292</span>
<span id="1293">1293</span>
<span id="1294">1294</span>
<span id="1295">1295</span>
<span id="1296">1296</span>
<span id="1297">1297</span>
<span id="1298">1298</span>
<span id="1299">1299</span>
<span id="1300">1300</span>
<span id="1301">1301</span>
<span id="1302">1302</span>
<span id="1303">1303</span>
<span id="1304">1304</span>
<span id="1305">1305</span>
<span id="1306">1306</span>
<span id="1307">1307</span>
<span id="1308">1308</span>
<span id="1309">1309</span>
<span id="1310">1310</span>
<span id="1311">1311</span>
<span id="1312">1312</span>
<span id="1313">1313</span>
<span id="1314">1314</span>
<span id="1315">1315</span>
<span id="1316">1316</span>
<span id="1317">1317</span>
<span id="1318">1318</span>
<span id="1319">1319</span>
<span id="1320">1320</span>
<span id="1321">1321</span>
<span id="1322">1322</span>
<span id="1323">1323</span>
<span id="1324">1324</span>
<span id="1325">1325</span>
<span id="1326">1326</span>
<span id="1327">1327</span>
<span id="1328">1328</span>
<span id="1329">1329</span>
<span id="1330">1330</span>
<span id="1331">1331</span>
<span id="1332">1332</span>
<span id="1333">1333</span>
<span id="1334">1334</span>
<span id="1335">1335</span>
<span id="1336">1336</span>
<span id="1337">1337</span>
<span id="1338">1338</span>
<span id="1339">1339</span>
<span id="1340">1340</span>
<span id="1341">1341</span>
<span id="1342">1342</span>
<span id="1343">1343</span>
<span id="1344">1344</span>
<span id="1345">1345</span>
<span id="1346">1346</span>
<span id="1347">1347</span>
<span id="1348">1348</span>
<span id="1349">1349</span>
<span id="1350">1350</span>
<span id="1351">1351</span>
<span id="1352">1352</span>
<span id="1353">1353</span>
<span id="1354">1354</span>
<span id="1355">1355</span>
<span id="1356">1356</span>
<span id="1357">1357</span>
<span id="1358">1358</span>
<span id="1359">1359</span>
<span id="1360">1360</span>
<span id="1361">1361</span>
<span id="1362">1362</span>
<span id="1363">1363</span>
<span id="1364">1364</span>
<span id="1365">1365</span>
<span id="1366">1366</span>
<span id="1367">1367</span>
<span id="1368">1368</span>
<span id="1369">1369</span>
<span id="1370">1370</span>
<span id="1371">1371</span>
<span id="1372">1372</span>
<span id="1373">1373</span>
<span id="1374">1374</span>
<span id="1375">1375</span>
<span id="1376">1376</span>
<span id="1377">1377</span>
<span id="1378">1378</span>
<span id="1379">1379</span>
<span id="1380">1380</span>
<span id="1381">1381</span>
<span id="1382">1382</span>
<span id="1383">1383</span>
<span id="1384">1384</span>
<span id="1385">1385</span>
<span id="1386">1386</span>
<span id="1387">1387</span>
<span id="1388">1388</span>
<span id="1389">1389</span>
<span id="1390">1390</span>
<span id="1391">1391</span>
<span id="1392">1392</span>
<span id="1393">1393</span>
<span id="1394">1394</span>
<span id="1395">1395</span>
<span id="1396">1396</span>
<span id="1397">1397</span>
<span id="1398">1398</span>
<span id="1399">1399</span>
<span id="1400">1400</span>
<span id="1401">1401</span>
<span id="1402">1402</span>
<span id="1403">1403</span>
<span id="1404">1404</span>
<span id="1405">1405</span>
<span id="1406">1406</span>
<span id="1407">1407</span>
<span id="1408">1408</span>
<span id="1409">1409</span>
<span id="1410">1410</span>
<span id="1411">1411</span>
<span id="1412">1412</span>
<span id="1413">1413</span>
<span id="1414">1414</span>
<span id="1415">1415</span>
<span id="1416">1416</span>
<span id="1417">1417</span>
<span id="1418">1418</span>
<span id="1419">1419</span>
<span id="1420">1420</span>
<span id="1421">1421</span>
<span id="1422">1422</span>
<span id="1423">1423</span>
<span id="1424">1424</span>
<span id="1425">1425</span>
<span id="1426">1426</span>
<span id="1427">1427</span>
<span id="1428">1428</span>
<span id="1429">1429</span>
<span id="1430">1430</span>
<span id="1431">1431</span>
<span id="1432">1432</span>
<span id="1433">1433</span>
<span id="1434">1434</span>
<span id="1435">1435</span>
<span id="1436">1436</span>
<span id="1437">1437</span>
<span id="1438">1438</span>
<span id="1439">1439</span>
<span id="1440">1440</span>
<span id="1441">1441</span>
<span id="1442">1442</span>
<span id="1443">1443</span>
<span id="1444">1444</span>
<span id="1445">1445</span>
<span id="1446">1446</span>
<span id="1447">1447</span>
<span id="1448">1448</span>
<span id="1449">1449</span>
<span id="1450">1450</span>
<span id="1451">1451</span>
<span id="1452">1452</span>
<span id="1453">1453</span>
<span id="1454">1454</span>
<span id="1455">1455</span>
<span id="1456">1456</span>
<span id="1457">1457</span>
<span id="1458">1458</span>
<span id="1459">1459</span>
<span id="1460">1460</span>
<span id="1461">1461</span>
<span id="1462">1462</span>
<span id="1463">1463</span>
<span id="1464">1464</span>
<span id="1465">1465</span>
<span id="1466">1466</span>
<span id="1467">1467</span>
<span id="1468">1468</span>
<span id="1469">1469</span>
<span id="1470">1470</span>
<span id="1471">1471</span>
<span id="1472">1472</span>
<span id="1473">1473</span>
<span id="1474">1474</span>
<span id="1475">1475</span>
<span id="1476">1476</span>
<span id="1477">1477</span>
<span id="1478">1478</span>
<span id="1479">1479</span>
<span id="1480">1480</span>
<span id="1481">1481</span>
<span id="1482">1482</span>
<span id="1483">1483</span>
<span id="1484">1484</span>
<span id="1485">1485</span>
<span id="1486">1486</span>
<span id="1487">1487</span>
<span id="1488">1488</span>
<span id="1489">1489</span>
<span id="1490">1490</span>
<span id="1491">1491</span>
<span id="1492">1492</span>
<span id="1493">1493</span>
<span id="1494">1494</span>
<span id="1495">1495</span>
<span id="1496">1496</span>
<span id="1497">1497</span>
<span id="1498">1498</span>
<span id="1499">1499</span>
<span id="1500">1500</span>
<span id="1501">1501</span>
<span id="1502">1502</span>
<span id="1503">1503</span>
<span id="1504">1504</span>
<span id="1505">1505</span>
<span id="1506">1506</span>
<span id="1507">1507</span>
<span id="1508">1508</span>
<span id="1509">1509</span>
<span id="1510">1510</span>
<span id="1511">1511</span>
<span id="1512">1512</span>
<span id="1513">1513</span>
<span id="1514">1514</span>
<span id="1515">1515</span>
<span id="1516">1516</span>
<span id="1517">1517</span>
<span id="1518">1518</span>
<span id="1519">1519</span>
<span id="1520">1520</span>
<span id="1521">1521</span>
<span id="1522">1522</span>
<span id="1523">1523</span>
<span id="1524">1524</span>
<span id="1525">1525</span>
<span id="1526">1526</span>
<span id="1527">1527</span>
<span id="1528">1528</span>
<span id="1529">1529</span>
<span id="1530">1530</span>
<span id="1531">1531</span>
<span id="1532">1532</span>
<span id="1533">1533</span>
<span id="1534">1534</span>
<span id="1535">1535</span>
<span id="1536">1536</span>
<span id="1537">1537</span>
<span id="1538">1538</span>
<span id="1539">1539</span>
<span id="1540">1540</span>
<span id="1541">1541</span>
<span id="1542">1542</span>
<span id="1543">1543</span>
<span id="1544">1544</span>
<span id="1545">1545</span>
<span id="1546">1546</span>
<span id="1547">1547</span>
<span id="1548">1548</span>
<span id="1549">1549</span>
<span id="1550">1550</span>
<span id="1551">1551</span>
<span id="1552">1552</span>
<span id="1553">1553</span>
<span id="1554">1554</span>
<span id="1555">1555</span>
<span id="1556">1556</span>
<span id="1557">1557</span>
<span id="1558">1558</span>
<span id="1559">1559</span>
<span id="1560">1560</span>
<span id="1561">1561</span>
<span id="1562">1562</span>
<span id="1563">1563</span>
<span id="1564">1564</span>
<span id="1565">1565</span>
<span id="1566">1566</span>
<span id="1567">1567</span>
<span id="1568">1568</span>
<span id="1569">1569</span>
<span id="1570">1570</span>
<span id="1571">1571</span>
<span id="1572">1572</span>
<span id="1573">1573</span>
<span id="1574">1574</span>
<span id="1575">1575</span>
<span id="1576">1576</span>
<span id="1577">1577</span>
<span id="1578">1578</span>
<span id="1579">1579</span>
<span id="1580">1580</span>
<span id="1581">1581</span>
<span id="1582">1582</span>
<span id="1583">1583</span>
<span id="1584">1584</span>
<span id="1585">1585</span>
<span id="1586">1586</span>
<span id="1587">1587</span>
<span id="1588">1588</span>
<span id="1589">1589</span>
<span id="1590">1590</span>
<span id="1591">1591</span>
<span id="1592">1592</span>
<span id="1593">1593</span>
<span id="1594">1594</span>
<span id="1595">1595</span>
<span id="1596">1596</span>
<span id="1597">1597</span>
<span id="1598">1598</span>
<span id="1599">1599</span>
<span id="1600">1600</span>
<span id="1601">1601</span>
<span id="1602">1602</span>
<span id="1603">1603</span>
<span id="1604">1604</span>
<span id="1605">1605</span>
<span id="1606">1606</span>
<span id="1607">1607</span>
<span id="1608">1608</span>
<span id="1609">1609</span>
<span id="1610">1610</span>
<span id="1611">1611</span>
<span id="1612">1612</span>
<span id="1613">1613</span>
<span id="1614">1614</span>
<span id="1615">1615</span>
<span id="1616">1616</span>
<span id="1617">1617</span>
<span id="1618">1618</span>
<span id="1619">1619</span>
<span id="1620">1620</span>
<span id="1621">1621</span>
<span id="1622">1622</span>
<span id="1623">1623</span>
<span id="1624">1624</span>
<span id="1625">1625</span>
<span id="1626">1626</span>
<span id="1627">1627</span>
<span id="1628">1628</span>
<span id="1629">1629</span>
<span id="1630">1630</span>
<span id="1631">1631</span>
<span id="1632">1632</span>
<span id="1633">1633</span>
<span id="1634">1634</span>
<span id="1635">1635</span>
<span id="1636">1636</span>
<span id="1637">1637</span>
<span id="1638">1638</span>
<span id="1639">1639</span>
<span id="1640">1640</span>
<span id="1641">1641</span>
<span id="1642">1642</span>
<span id="1643">1643</span>
<span id="1644">1644</span>
<span id="1645">1645</span>
<span id="1646">1646</span>
<span id="1647">1647</span>
<span id="1648">1648</span>
<span id="1649">1649</span>
<span id="1650">1650</span>
<span id="1651">1651</span>
<span id="1652">1652</span>
<span id="1653">1653</span>
<span id="1654">1654</span>
<span id="1655">1655</span>
<span id="1656">1656</span>
<span id="1657">1657</span>
<span id="1658">1658</span>
<span id="1659">1659</span>
<span id="1660">1660</span>
<span id="1661">1661</span>
<span id="1662">1662</span>
<span id="1663">1663</span>
<span id="1664">1664</span>
<span id="1665">1665</span>
<span id="1666">1666</span>
<span id="1667">1667</span>
<span id="1668">1668</span>
<span id="1669">1669</span>
<span id="1670">1670</span>
<span id="1671">1671</span>
<span id="1672">1672</span>
<span id="1673">1673</span>
<span id="1674">1674</span>
<span id="1675">1675</span>
<span id="1676">1676</span>
<span id="1677">1677</span>
<span id="1678">1678</span>
<span id="1679">1679</span>
<span id="1680">1680</span>
<span id="1681">1681</span>
<span id="1682">1682</span>
<span id="1683">1683</span>
<span id="1684">1684</span>
<span id="1685">1685</span>
<span id="1686">1686</span>
<span id="1687">1687</span>
<span id="1688">1688</span>
<span id="1689">1689</span>
<span id="1690">1690</span>
<span id="1691">1691</span>
<span id="1692">1692</span>
<span id="1693">1693</span>
<span id="1694">1694</span>
<span id="1695">1695</span>
<span id="1696">1696</span>
<span id="1697">1697</span>
<span id="1698">1698</span>
<span id="1699">1699</span>
<span id="1700">1700</span>
<span id="1701">1701</span>
<span id="1702">1702</span>
<span id="1703">1703</span>
<span id="1704">1704</span>
<span id="1705">1705</span>
<span id="1706">1706</span>
<span id="1707">1707</span>
<span id="1708">1708</span>
<span id="1709">1709</span>
<span id="1710">1710</span>
<span id="1711">1711</span>
<span id="1712">1712</span>
<span id="1713">1713</span>
<span id="1714">1714</span>
<span id="1715">1715</span>
<span id="1716">1716</span>
<span id="1717">1717</span>
<span id="1718">1718</span>
<span id="1719">1719</span>
<span id="1720">1720</span>
<span id="1721">1721</span>
<span id="1722">1722</span>
<span id="1723">1723</span>
<span id="1724">1724</span>
<span id="1725">1725</span>
<span id="1726">1726</span>
<span id="1727">1727</span>
<span id="1728">1728</span>
<span id="1729">1729</span>
<span id="1730">1730</span>
<span id="1731">1731</span>
<span id="1732">1732</span>
<span id="1733">1733</span>
<span id="1734">1734</span>
<span id="1735">1735</span>
<span id="1736">1736</span>
<span id="1737">1737</span>
<span id="1738">1738</span>
<span id="1739">1739</span>
<span id="1740">1740</span>
<span id="1741">1741</span>
<span id="1742">1742</span>
<span id="1743">1743</span>
<span id="1744">1744</span>
<span id="1745">1745</span>
<span id="1746">1746</span>
<span id="1747">1747</span>
<span id="1748">1748</span>
<span id="1749">1749</span>
<span id="1750">1750</span>
<span id="1751">1751</span>
<span id="1752">1752</span>
<span id="1753">1753</span>
<span id="1754">1754</span>
<span id="1755">1755</span>
<span id="1756">1756</span>
<span id="1757">1757</span>
<span id="1758">1758</span>
<span id="1759">1759</span>
<span id="1760">1760</span>
<span id="1761">1761</span>
<span id="1762">1762</span>
<span id="1763">1763</span>
<span id="1764">1764</span>
<span id="1765">1765</span>
<span id="1766">1766</span>
<span id="1767">1767</span>
<span id="1768">1768</span>
<span id="1769">1769</span>
<span id="1770">1770</span>
<span id="1771">1771</span>
<span id="1772">1772</span>
<span id="1773">1773</span>
<span id="1774">1774</span>
<span id="1775">1775</span>
<span id="1776">1776</span>
<span id="1777">1777</span>
<span id="1778">1778</span>
<span id="1779">1779</span>
<span id="1780">1780</span>
<span id="1781">1781</span>
<span id="1782">1782</span>
<span id="1783">1783</span>
<span id="1784">1784</span>
<span id="1785">1785</span>
<span id="1786">1786</span>
<span id="1787">1787</span>
<span id="1788">1788</span>
<span id="1789">1789</span>
<span id="1790">1790</span>
<span id="1791">1791</span>
<span id="1792">1792</span>
<span id="1793">1793</span>
<span id="1794">1794</span>
<span id="1795">1795</span>
<span id="1796">1796</span>
<span id="1797">1797</span>
<span id="1798">1798</span>
<span id="1799">1799</span>
<span id="1800">1800</span>
<span id="1801">1801</span>
<span id="1802">1802</span>
<span id="1803">1803</span>
<span id="1804">1804</span>
<span id="1805">1805</span>
<span id="1806">1806</span>
<span id="1807">1807</span>
<span id="1808">1808</span>
<span id="1809">1809</span>
<span id="1810">1810</span>
<span id="1811">1811</span>
<span id="1812">1812</span>
<span id="1813">1813</span>
<span id="1814">1814</span>
<span id="1815">1815</span>
<span id="1816">1816</span>
<span id="1817">1817</span>
<span id="1818">1818</span>
<span id="1819">1819</span>
<span id="1820">1820</span>
<span id="1821">1821</span>
<span id="1822">1822</span>
<span id="1823">1823</span>
<span id="1824">1824</span>
<span id="1825">1825</span>
<span id="1826">1826</span>
<span id="1827">1827</span>
<span id="1828">1828</span>
<span id="1829">1829</span>
<span id="1830">1830</span>
<span id="1831">1831</span>
<span id="1832">1832</span>
<span id="1833">1833</span>
<span id="1834">1834</span>
<span id="1835">1835</span>
<span id="1836">1836</span>
<span id="1837">1837</span>
<span id="1838">1838</span>
<span id="1839">1839</span>
<span id="1840">1840</span>
<span id="1841">1841</span>
<span id="1842">1842</span>
<span id="1843">1843</span>
<span id="1844">1844</span>
<span id="1845">1845</span>
<span id="1846">1846</span>
<span id="1847">1847</span>
<span id="1848">1848</span>
<span id="1849">1849</span>
<span id="1850">1850</span>
<span id="1851">1851</span>
<span id="1852">1852</span>
<span id="1853">1853</span>
<span id="1854">1854</span>
<span id="1855">1855</span>
<span id="1856">1856</span>
<span id="1857">1857</span>
<span id="1858">1858</span>
<span id="1859">1859</span>
<span id="1860">1860</span>
<span id="1861">1861</span>
<span id="1862">1862</span>
<span id="1863">1863</span>
<span id="1864">1864</span>
<span id="1865">1865</span>
<span id="1866">1866</span>
<span id="1867">1867</span>
<span id="1868">1868</span>
<span id="1869">1869</span>
<span id="1870">1870</span>
<span id="1871">1871</span>
<span id="1872">1872</span>
<span id="1873">1873</span>
<span id="1874">1874</span>
<span id="1875">1875</span>
<span id="1876">1876</span>
<span id="1877">1877</span>
<span id="1878">1878</span>
<span id="1879">1879</span>
<span id="1880">1880</span>
<span id="1881">1881</span>
<span id="1882">1882</span>
<span id="1883">1883</span>
<span id="1884">1884</span>
<span id="1885">1885</span>
<span id="1886">1886</span>
<span id="1887">1887</span>
<span id="1888">1888</span>
<span id="1889">1889</span>
<span id="1890">1890</span>
<span id="1891">1891</span>
<span id="1892">1892</span>
<span id="1893">1893</span>
<span id="1894">1894</span>
<span id="1895">1895</span>
<span id="1896">1896</span>
<span id="1897">1897</span>
<span id="1898">1898</span>
<span id="1899">1899</span>
<span id="1900">1900</span>
<span id="1901">1901</span>
<span id="1902">1902</span>
<span id="1903">1903</span>
<span id="1904">1904</span>
<span id="1905">1905</span>
<span id="1906">1906</span>
<span id="1907">1907</span>
<span id="1908">1908</span>
<span id="1909">1909</span>
<span id="1910">1910</span>
<span id="1911">1911</span>
<span id="1912">1912</span>
<span id="1913">1913</span>
<span id="1914">1914</span>
<span id="1915">1915</span>
<span id="1916">1916</span>
<span id="1917">1917</span>
<span id="1918">1918</span>
<span id="1919">1919</span>
<span id="1920">1920</span>
<span id="1921">1921</span>
<span id="1922">1922</span>
<span id="1923">1923</span>
<span id="1924">1924</span>
<span id="1925">1925</span>
<span id="1926">1926</span>
<span id="1927">1927</span>
<span id="1928">1928</span>
<span id="1929">1929</span>
<span id="1930">1930</span>
<span id="1931">1931</span>
<span id="1932">1932</span>
<span id="1933">1933</span>
<span id="1934">1934</span>
<span id="1935">1935</span>
<span id="1936">1936</span>
<span id="1937">1937</span>
<span id="1938">1938</span>
<span id="1939">1939</span>
<span id="1940">1940</span>
<span id="1941">1941</span>
<span id="1942">1942</span>
<span id="1943">1943</span>
<span id="1944">1944</span>
<span id="1945">1945</span>
<span id="1946">1946</span>
<span id="1947">1947</span>
<span id="1948">1948</span>
<span id="1949">1949</span>
<span id="1950">1950</span>
<span id="1951">1951</span>
<span id="1952">1952</span>
<span id="1953">1953</span>
<span id="1954">1954</span>
<span id="1955">1955</span>
<span id="1956">1956</span>
<span id="1957">1957</span>
<span id="1958">1958</span>
<span id="1959">1959</span>
<span id="1960">1960</span>
<span id="1961">1961</span>
<span id="1962">1962</span>
<span id="1963">1963</span>
<span id="1964">1964</span>
<span id="1965">1965</span>
<span id="1966">1966</span>
<span id="1967">1967</span>
<span id="1968">1968</span>
<span id="1969">1969</span>
<span id="1970">1970</span>
<span id="1971">1971</span>
<span id="1972">1972</span>
<span id="1973">1973</span>
<span id="1974">1974</span>
<span id="1975">1975</span>
<span id="1976">1976</span>
<span id="1977">1977</span>
<span id="1978">1978</span>
<span id="1979">1979</span>
<span id="1980">1980</span>
<span id="1981">1981</span>
<span id="1982">1982</span>
<span id="1983">1983</span>
<span id="1984">1984</span>
<span id="1985">1985</span>
<span id="1986">1986</span>
<span id="1987">1987</span>
<span id="1988">1988</span>
<span id="1989">1989</span>
<span id="1990">1990</span>
<span id="1991">1991</span>
<span id="1992">1992</span>
<span id="1993">1993</span>
<span id="1994">1994</span>
<span id="1995">1995</span>
<span id="1996">1996</span>
<span id="1997">1997</span>
<span id="1998">1998</span>
<span id="1999">1999</span>
<span id="2000">2000</span>
<span id="2001">2001</span>
<span id="2002">2002</span>
<span id="2003">2003</span>
<span id="2004">2004</span>
<span id="2005">2005</span>
<span id="2006">2006</span>
<span id="2007">2007</span>
<span id="2008">2008</span>
<span id="2009">2009</span>
<span id="2010">2010</span>
<span id="2011">2011</span>
<span id="2012">2012</span>
<span id="2013">2013</span>
<span id="2014">2014</span>
<span id="2015">2015</span>
<span id="2016">2016</span>
<span id="2017">2017</span>
<span id="2018">2018</span>
<span id="2019">2019</span>
<span id="2020">2020</span>
<span id="2021">2021</span>
<span id="2022">2022</span>
<span id="2023">2023</span>
<span id="2024">2024</span>
<span id="2025">2025</span>
<span id="2026">2026</span>
<span id="2027">2027</span>
<span id="2028">2028</span>
<span id="2029">2029</span>
<span id="2030">2030</span>
<span id="2031">2031</span>
<span id="2032">2032</span>
<span id="2033">2033</span>
<span id="2034">2034</span>
<span id="2035">2035</span>
<span id="2036">2036</span>
<span id="2037">2037</span>
<span id="2038">2038</span>
<span id="2039">2039</span>
<span id="2040">2040</span>
<span id="2041">2041</span>
<span id="2042">2042</span>
<span id="2043">2043</span>
<span id="2044">2044</span>
<span id="2045">2045</span>
<span id="2046">2046</span>
<span id="2047">2047</span>
<span id="2048">2048</span>
<span id="2049">2049</span>
<span id="2050">2050</span>
<span id="2051">2051</span>
<span id="2052">2052</span>
<span id="2053">2053</span>
<span id="2054">2054</span>
<span id="2055">2055</span>
<span id="2056">2056</span>
<span id="2057">2057</span>
<span id="2058">2058</span>
<span id="2059">2059</span>
<span id="2060">2060</span>
<span id="2061">2061</span>
<span id="2062">2062</span>
<span id="2063">2063</span>
<span id="2064">2064</span>
<span id="2065">2065</span>
<span id="2066">2066</span>
<span id="2067">2067</span>
<span id="2068">2068</span>
<span id="2069">2069</span>
<span id="2070">2070</span>
<span id="2071">2071</span>
<span id="2072">2072</span>
<span id="2073">2073</span>
<span id="2074">2074</span>
<span id="2075">2075</span>
<span id="2076">2076</span>
<span id="2077">2077</span>
<span id="2078">2078</span>
<span id="2079">2079</span>
<span id="2080">2080</span>
<span id="2081">2081</span>
<span id="2082">2082</span>
<span id="2083">2083</span>
<span id="2084">2084</span>
<span id="2085">2085</span>
<span id="2086">2086</span>
<span id="2087">2087</span>
<span id="2088">2088</span>
<span id="2089">2089</span>
<span id="2090">2090</span>
<span id="2091">2091</span>
<span id="2092">2092</span>
<span id="2093">2093</span>
<span id="2094">2094</span>
<span id="2095">2095</span>
<span id="2096">2096</span>
<span id="2097">2097</span>
<span id="2098">2098</span>
<span id="2099">2099</span>
<span id="2100">2100</span>
<span id="2101">2101</span>
<span id="2102">2102</span>
<span id="2103">2103</span>
<span id="2104">2104</span>
<span id="2105">2105</span>
<span id="2106">2106</span>
<span id="2107">2107</span>
<span id="2108">2108</span>
<span id="2109">2109</span>
<span id="2110">2110</span>
<span id="2111">2111</span>
<span id="2112">2112</span>
<span id="2113">2113</span>
<span id="2114">2114</span>
<span id="2115">2115</span>
<span id="2116">2116</span>
<span id="2117">2117</span>
<span id="2118">2118</span>
<span id="2119">2119</span>
<span id="2120">2120</span>
<span id="2121">2121</span>
<span id="2122">2122</span>
<span id="2123">2123</span>
<span id="2124">2124</span>
<span id="2125">2125</span>
<span id="2126">2126</span>
<span id="2127">2127</span>
<span id="2128">2128</span>
<span id="2129">2129</span>
<span id="2130">2130</span>
<span id="2131">2131</span>
<span id="2132">2132</span>
<span id="2133">2133</span>
<span id="2134">2134</span>
<span id="2135">2135</span>
<span id="2136">2136</span>
<span id="2137">2137</span>
<span id="2138">2138</span>
<span id="2139">2139</span>
<span id="2140">2140</span>
<span id="2141">2141</span>
<span id="2142">2142</span>
<span id="2143">2143</span>
<span id="2144">2144</span>
<span id="2145">2145</span>
<span id="2146">2146</span>
<span id="2147">2147</span>
<span id="2148">2148</span>
<span id="2149">2149</span>
<span id="2150">2150</span>
<span id="2151">2151</span>
<span id="2152">2152</span>
<span id="2153">2153</span>
<span id="2154">2154</span>
<span id="2155">2155</span>
<span id="2156">2156</span>
<span id="2157">2157</span>
<span id="2158">2158</span>
<span id="2159">2159</span>
<span id="2160">2160</span>
<span id="2161">2161</span>
<span id="2162">2162</span>
<span id="2163">2163</span>
<span id="2164">2164</span>
<span id="2165">2165</span>
<span id="2166">2166</span>
<span id="2167">2167</span>
<span id="2168">2168</span>
<span id="2169">2169</span>
<span id="2170">2170</span>
<span id="2171">2171</span>
<span id="2172">2172</span>
<span id="2173">2173</span>
<span id="2174">2174</span>
<span id="2175">2175</span>
<span id="2176">2176</span>
<span id="2177">2177</span>
<span id="2178">2178</span>
<span id="2179">2179</span>
<span id="2180">2180</span>
<span id="2181">2181</span>
<span id="2182">2182</span>
<span id="2183">2183</span>
<span id="2184">2184</span>
<span id="2185">2185</span>
<span id="2186">2186</span>
<span id="2187">2187</span>
<span id="2188">2188</span>
<span id="2189">2189</span>
<span id="2190">2190</span>
<span id="2191">2191</span>
<span id="2192">2192</span>
<span id="2193">2193</span>
<span id="2194">2194</span>
<span id="2195">2195</span>
<span id="2196">2196</span>
<span id="2197">2197</span>
<span id="2198">2198</span>
<span id="2199">2199</span>
<span id="2200">2200</span>
<span id="2201">2201</span>
<span id="2202">2202</span>
<span id="2203">2203</span>
<span id="2204">2204</span>
<span id="2205">2205</span>
<span id="2206">2206</span>
<span id="2207">2207</span>
<span id="2208">2208</span>
<span id="2209">2209</span>
<span id="2210">2210</span>
<span id="2211">2211</span>
<span id="2212">2212</span>
<span id="2213">2213</span>
<span id="2214">2214</span>
<span id="2215">2215</span>
<span id="2216">2216</span>
<span id="2217">2217</span>
<span id="2218">2218</span>
<span id="2219">2219</span>
<span id="2220">2220</span>
<span id="2221">2221</span>
<span id="2222">2222</span>
<span id="2223">2223</span>
<span id="2224">2224</span>
<span id="2225">2225</span>
<span id="2226">2226</span>
<span id="2227">2227</span>
<span id="2228">2228</span>
<span id="2229">2229</span>
<span id="2230">2230</span>
<span id="2231">2231</span>
<span id="2232">2232</span>
<span id="2233">2233</span>
<span id="2234">2234</span>
<span id="2235">2235</span>
<span id="2236">2236</span>
<span id="2237">2237</span>
<span id="2238">2238</span>
<span id="2239">2239</span>
<span id="2240">2240</span>
<span id="2241">2241</span>
<span id="2242">2242</span>
<span id="2243">2243</span>
<span id="2244">2244</span>
<span id="2245">2245</span>
<span id="2246">2246</span>
<span id="2247">2247</span>
<span id="2248">2248</span>
<span id="2249">2249</span>
<span id="2250">2250</span>
<span id="2251">2251</span>
<span id="2252">2252</span>
<span id="2253">2253</span>
<span id="2254">2254</span>
<span id="2255">2255</span>
<span id="2256">2256</span>
<span id="2257">2257</span>
<span id="2258">2258</span>
<span id="2259">2259</span>
<span id="2260">2260</span>
<span id="2261">2261</span>
<span id="2262">2262</span>
<span id="2263">2263</span>
<span id="2264">2264</span>
<span id="2265">2265</span>
<span id="2266">2266</span>
<span id="2267">2267</span>
<span id="2268">2268</span>
<span id="2269">2269</span>
<span id="2270">2270</span>
<span id="2271">2271</span>
<span id="2272">2272</span>
<span id="2273">2273</span>
<span id="2274">2274</span>
<span id="2275">2275</span>
<span id="2276">2276</span>
<span id="2277">2277</span>
<span id="2278">2278</span>
<span id="2279">2279</span>
<span id="2280">2280</span>
<span id="2281">2281</span>
<span id="2282">2282</span>
<span id="2283">2283</span>
<span id="2284">2284</span>
<span id="2285">2285</span>
<span id="2286">2286</span>
<span id="2287">2287</span>
<span id="2288">2288</span>
<span id="2289">2289</span>
<span id="2290">2290</span>
<span id="2291">2291</span>
<span id="2292">2292</span>
<span id="2293">2293</span>
<span id="2294">2294</span>
<span id="2295">2295</span>
<span id="2296">2296</span>
<span id="2297">2297</span>
<span id="2298">2298</span>
<span id="2299">2299</span>
<span id="2300">2300</span>
<span id="2301">2301</span>
<span id="2302">2302</span>
<span id="2303">2303</span>
<span id="2304">2304</span>
<span id="2305">2305</span>
<span id="2306">2306</span>
<span id="2307">2307</span>
<span id="2308">2308</span>
<span id="2309">2309</span>
<span id="2310">2310</span>
<span id="2311">2311</span>
<span id="2312">2312</span>
<span id="2313">2313</span>
<span id="2314">2314</span>
<span id="2315">2315</span>
<span id="2316">2316</span>
<span id="2317">2317</span>
<span id="2318">2318</span>
<span id="2319">2319</span>
<span id="2320">2320</span>
<span id="2321">2321</span>
<span id="2322">2322</span>
<span id="2323">2323</span>
<span id="2324">2324</span>
<span id="2325">2325</span>
<span id="2326">2326</span>
<span id="2327">2327</span>
<span id="2328">2328</span>
<span id="2329">2329</span>
<span id="2330">2330</span>
<span id="2331">2331</span>
<span id="2332">2332</span>
<span id="2333">2333</span>
<span id="2334">2334</span>
<span id="2335">2335</span>
<span id="2336">2336</span>
<span id="2337">2337</span>
<span id="2338">2338</span>
<span id="2339">2339</span>
<span id="2340">2340</span>
<span id="2341">2341</span>
<span id="2342">2342</span>
<span id="2343">2343</span>
<span id="2344">2344</span>
<span id="2345">2345</span>
<span id="2346">2346</span>
<span id="2347">2347</span>
<span id="2348">2348</span>
<span id="2349">2349</span>
<span id="2350">2350</span>
<span id="2351">2351</span>
<span id="2352">2352</span>
<span id="2353">2353</span>
<span id="2354">2354</span>
<span id="2355">2355</span>
<span id="2356">2356</span>
<span id="2357">2357</span>
<span id="2358">2358</span>
<span id="2359">2359</span>
<span id="2360">2360</span>
<span id="2361">2361</span>
<span id="2362">2362</span>
<span id="2363">2363</span>
<span id="2364">2364</span>
<span id="2365">2365</span>
<span id="2366">2366</span>
<span id="2367">2367</span>
<span id="2368">2368</span>
<span id="2369">2369</span>
<span id="2370">2370</span>
<span id="2371">2371</span>
<span id="2372">2372</span>
<span id="2373">2373</span>
<span id="2374">2374</span>
<span id="2375">2375</span>
<span id="2376">2376</span>
<span id="2377">2377</span>
<span id="2378">2378</span>
<span id="2379">2379</span>
<span id="2380">2380</span>
<span id="2381">2381</span>
<span id="2382">2382</span>
<span id="2383">2383</span>
<span id="2384">2384</span>
<span id="2385">2385</span>
<span id="2386">2386</span>
<span id="2387">2387</span>
<span id="2388">2388</span>
<span id="2389">2389</span>
<span id="2390">2390</span>
<span id="2391">2391</span>
<span id="2392">2392</span>
<span id="2393">2393</span>
<span id="2394">2394</span>
<span id="2395">2395</span>
<span id="2396">2396</span>
<span id="2397">2397</span>
<span id="2398">2398</span>
<span id="2399">2399</span>
<span id="2400">2400</span>
<span id="2401">2401</span>
<span id="2402">2402</span>
<span id="2403">2403</span>
<span id="2404">2404</span>
<span id="2405">2405</span>
<span id="2406">2406</span>
<span id="2407">2407</span>
<span id="2408">2408</span>
<span id="2409">2409</span>
<span id="2410">2410</span>
<span id="2411">2411</span>
<span id="2412">2412</span>
<span id="2413">2413</span>
<span id="2414">2414</span>
<span id="2415">2415</span>
<span id="2416">2416</span>
<span id="2417">2417</span>
<span id="2418">2418</span>
<span id="2419">2419</span>
<span id="2420">2420</span>
<span id="2421">2421</span>
<span id="2422">2422</span>
<span id="2423">2423</span>
<span id="2424">2424</span>
<span id="2425">2425</span>
<span id="2426">2426</span>
<span id="2427">2427</span>
<span id="2428">2428</span>
<span id="2429">2429</span>
<span id="2430">2430</span>
<span id="2431">2431</span>
<span id="2432">2432</span>
<span id="2433">2433</span>
<span id="2434">2434</span>
<span id="2435">2435</span>
<span id="2436">2436</span>
<span id="2437">2437</span>
<span id="2438">2438</span>
<span id="2439">2439</span>
<span id="2440">2440</span>
<span id="2441">2441</span>
<span id="2442">2442</span>
<span id="2443">2443</span>
<span id="2444">2444</span>
<span id="2445">2445</span>
<span id="2446">2446</span>
<span id="2447">2447</span>
<span id="2448">2448</span>
<span id="2449">2449</span>
<span id="2450">2450</span>
<span id="2451">2451</span>
<span id="2452">2452</span>
<span id="2453">2453</span>
<span id="2454">2454</span>
<span id="2455">2455</span>
<span id="2456">2456</span>
<span id="2457">2457</span>
<span id="2458">2458</span>
<span id="2459">2459</span>
<span id="2460">2460</span>
<span id="2461">2461</span>
<span id="2462">2462</span>
<span id="2463">2463</span>
<span id="2464">2464</span>
<span id="2465">2465</span>
<span id="2466">2466</span>
<span id="2467">2467</span>
<span id="2468">2468</span>
<span id="2469">2469</span>
<span id="2470">2470</span>
<span id="2471">2471</span>
<span id="2472">2472</span>
<span id="2473">2473</span>
<span id="2474">2474</span>
<span id="2475">2475</span>
<span id="2476">2476</span>
<span id="2477">2477</span>
<span id="2478">2478</span>
<span id="2479">2479</span>
<span id="2480">2480</span>
<span id="2481">2481</span>
<span id="2482">2482</span>
<span id="2483">2483</span>
<span id="2484">2484</span>
<span id="2485">2485</span>
<span id="2486">2486</span>
<span id="2487">2487</span>
<span id="2488">2488</span>
<span id="2489">2489</span>
<span id="2490">2490</span>
<span id="2491">2491</span>
<span id="2492">2492</span>
<span id="2493">2493</span>
<span id="2494">2494</span>
<span id="2495">2495</span>
<span id="2496">2496</span>
<span id="2497">2497</span>
<span id="2498">2498</span>
<span id="2499">2499</span>
<span id="2500">2500</span>
<span id="2501">2501</span>
<span id="2502">2502</span>
<span id="2503">2503</span>
<span id="2504">2504</span>
<span id="2505">2505</span>
<span id="2506">2506</span>
<span id="2507">2507</span>
<span id="2508">2508</span>
<span id="2509">2509</span>
<span id="2510">2510</span>
<span id="2511">2511</span>
<span id="2512">2512</span>
<span id="2513">2513</span>
<span id="2514">2514</span>
<span id="2515">2515</span>
<span id="2516">2516</span>
<span id="2517">2517</span>
<span id="2518">2518</span>
<span id="2519">2519</span>
<span id="2520">2520</span>
<span id="2521">2521</span>
<span id="2522">2522</span>
<span id="2523">2523</span>
<span id="2524">2524</span>
<span id="2525">2525</span>
<span id="2526">2526</span>
<span id="2527">2527</span>
<span id="2528">2528</span>
<span id="2529">2529</span>
<span id="2530">2530</span>
<span id="2531">2531</span>
<span id="2532">2532</span>
<span id="2533">2533</span>
<span id="2534">2534</span>
<span id="2535">2535</span>
<span id="2536">2536</span>
<span id="2537">2537</span>
<span id="2538">2538</span>
<span id="2539">2539</span>
<span id="2540">2540</span>
<span id="2541">2541</span>
<span id="2542">2542</span>
<span id="2543">2543</span>
<span id="2544">2544</span>
<span id="2545">2545</span>
<span id="2546">2546</span>
<span id="2547">2547</span>
<span id="2548">2548</span>
<span id="2549">2549</span>
<span id="2550">2550</span>
<span id="2551">2551</span>
<span id="2552">2552</span>
<span id="2553">2553</span>
<span id="2554">2554</span>
<span id="2555">2555</span>
<span id="2556">2556</span>
<span id="2557">2557</span>
<span id="2558">2558</span>
<span id="2559">2559</span>
<span id="2560">2560</span>
<span id="2561">2561</span>
<span id="2562">2562</span>
<span id="2563">2563</span>
<span id="2564">2564</span>
<span id="2565">2565</span>
<span id="2566">2566</span>
<span id="2567">2567</span>
<span id="2568">2568</span>
<span id="2569">2569</span>
<span id="2570">2570</span>
<span id="2571">2571</span>
<span id="2572">2572</span>
<span id="2573">2573</span>
<span id="2574">2574</span>
<span id="2575">2575</span>
<span id="2576">2576</span>
<span id="2577">2577</span>
<span id="2578">2578</span>
<span id="2579">2579</span>
<span id="2580">2580</span>
<span id="2581">2581</span>
<span id="2582">2582</span>
<span id="2583">2583</span>
<span id="2584">2584</span>
<span id="2585">2585</span>
<span id="2586">2586</span>
<span id="2587">2587</span>
<span id="2588">2588</span>
<span id="2589">2589</span>
<span id="2590">2590</span>
<span id="2591">2591</span>
<span id="2592">2592</span>
<span id="2593">2593</span>
<span id="2594">2594</span>
<span id="2595">2595</span>
<span id="2596">2596</span>
<span id="2597">2597</span>
<span id="2598">2598</span>
<span id="2599">2599</span>
<span id="2600">2600</span>
<span id="2601">2601</span>
<span id="2602">2602</span>
<span id="2603">2603</span>
<span id="2604">2604</span>
<span id="2605">2605</span>
<span id="2606">2606</span>
<span id="2607">2607</span>
<span id="2608">2608</span>
<span id="2609">2609</span>
<span id="2610">2610</span>
<span id="2611">2611</span>
<span id="2612">2612</span>
<span id="2613">2613</span>
<span id="2614">2614</span>
<span id="2615">2615</span>
<span id="2616">2616</span>
<span id="2617">2617</span>
<span id="2618">2618</span>
<span id="2619">2619</span>
<span id="2620">2620</span>
<span id="2621">2621</span>
<span id="2622">2622</span>
<span id="2623">2623</span>
<span id="2624">2624</span>
<span id="2625">2625</span>
<span id="2626">2626</span>
<span id="2627">2627</span>
<span id="2628">2628</span>
<span id="2629">2629</span>
<span id="2630">2630</span>
<span id="2631">2631</span>
<span id="2632">2632</span>
<span id="2633">2633</span>
<span id="2634">2634</span>
<span id="2635">2635</span>
<span id="2636">2636</span>
<span id="2637">2637</span>
<span id="2638">2638</span>
<span id="2639">2639</span>
<span id="2640">2640</span>
<span id="2641">2641</span>
<span id="2642">2642</span>
<span id="2643">2643</span>
<span id="2644">2644</span>
<span id="2645">2645</span>
<span id="2646">2646</span>
<span id="2647">2647</span>
<span id="2648">2648</span>
<span id="2649">2649</span>
<span id="2650">2650</span>
<span id="2651">2651</span>
<span id="2652">2652</span>
<span id="2653">2653</span>
<span id="2654">2654</span>
<span id="2655">2655</span>
<span id="2656">2656</span>
<span id="2657">2657</span>
<span id="2658">2658</span>
<span id="2659">2659</span>
<span id="2660">2660</span>
<span id="2661">2661</span>
<span id="2662">2662</span>
<span id="2663">2663</span>
<span id="2664">2664</span>
<span id="2665">2665</span>
<span id="2666">2666</span>
<span id="2667">2667</span>
<span id="2668">2668</span>
<span id="2669">2669</span>
<span id="2670">2670</span>
<span id="2671">2671</span>
<span id="2672">2672</span>
<span id="2673">2673</span>
<span id="2674">2674</span>
<span id="2675">2675</span>
<span id="2676">2676</span>
<span id="2677">2677</span>
<span id="2678">2678</span>
<span id="2679">2679</span>
<span id="2680">2680</span>
<span id="2681">2681</span>
<span id="2682">2682</span>
<span id="2683">2683</span>
<span id="2684">2684</span>
<span id="2685">2685</span>
<span id="2686">2686</span>
<span id="2687">2687</span>
<span id="2688">2688</span>
<span id="2689">2689</span>
<span id="2690">2690</span>
<span id="2691">2691</span>
<span id="2692">2692</span>
<span id="2693">2693</span>
<span id="2694">2694</span>
<span id="2695">2695</span>
<span id="2696">2696</span>
<span id="2697">2697</span>
<span id="2698">2698</span>
<span id="2699">2699</span>
<span id="2700">2700</span>
<span id="2701">2701</span>
<span id="2702">2702</span>
<span id="2703">2703</span>
<span id="2704">2704</span>
<span id="2705">2705</span>
<span id="2706">2706</span>
<span id="2707">2707</span>
<span id="2708">2708</span>
<span id="2709">2709</span>
<span id="2710">2710</span>
<span id="2711">2711</span>
<span id="2712">2712</span>
<span id="2713">2713</span>
<span id="2714">2714</span>
<span id="2715">2715</span>
<span id="2716">2716</span>
<span id="2717">2717</span>
<span id="2718">2718</span>
<span id="2719">2719</span>
<span id="2720">2720</span>
<span id="2721">2721</span>
<span id="2722">2722</span>
<span id="2723">2723</span>
<span id="2724">2724</span>
<span id="2725">2725</span>
<span id="2726">2726</span>
<span id="2727">2727</span>
<span id="2728">2728</span>
<span id="2729">2729</span>
<span id="2730">2730</span>
<span id="2731">2731</span>
<span id="2732">2732</span>
<span id="2733">2733</span>
<span id="2734">2734</span>
<span id="2735">2735</span>
<span id="2736">2736</span>
<span id="2737">2737</span>
<span id="2738">2738</span>
<span id="2739">2739</span>
<span id="2740">2740</span>
<span id="2741">2741</span>
<span id="2742">2742</span>
<span id="2743">2743</span>
<span id="2744">2744</span>
<span id="2745">2745</span>
<span id="2746">2746</span>
<span id="2747">2747</span>
<span id="2748">2748</span>
<span id="2749">2749</span>
<span id="2750">2750</span>
<span id="2751">2751</span>
<span id="2752">2752</span>
<span id="2753">2753</span>
<span id="2754">2754</span>
<span id="2755">2755</span>
<span id="2756">2756</span>
<span id="2757">2757</span>
<span id="2758">2758</span>
<span id="2759">2759</span>
<span id="2760">2760</span>
<span id="2761">2761</span>
<span id="2762">2762</span>
<span id="2763">2763</span>
<span id="2764">2764</span>
<span id="2765">2765</span>
<span id="2766">2766</span>
<span id="2767">2767</span>
<span id="2768">2768</span>
<span id="2769">2769</span>
<span id="2770">2770</span>
<span id="2771">2771</span>
<span id="2772">2772</span>
<span id="2773">2773</span>
<span id="2774">2774</span>
<span id="2775">2775</span>
<span id="2776">2776</span>
<span id="2777">2777</span>
<span id="2778">2778</span>
<span id="2779">2779</span>
<span id="2780">2780</span>
<span id="2781">2781</span>
<span id="2782">2782</span>
<span id="2783">2783</span>
<span id="2784">2784</span>
<span id="2785">2785</span>
<span id="2786">2786</span>
<span id="2787">2787</span>
<span id="2788">2788</span>
<span id="2789">2789</span>
<span id="2790">2790</span>
<span id="2791">2791</span>
<span id="2792">2792</span>
<span id="2793">2793</span>
<span id="2794">2794</span>
<span id="2795">2795</span>
<span id="2796">2796</span>
<span id="2797">2797</span>
<span id="2798">2798</span>
<span id="2799">2799</span>
<span id="2800">2800</span>
<span id="2801">2801</span>
<span id="2802">2802</span>
<span id="2803">2803</span>
<span id="2804">2804</span>
<span id="2805">2805</span>
<span id="2806">2806</span>
</pre><pre class="rust"><code><span class="doccomment">/*! A dynamically-sized view into individual bits of a memory region.

You can read the language’s [`slice` module documentation][std] here.

This module defines the [`BitSlice`] region, and all of its associated support
code.

[`BitSlice`] is the primary working type of this crate. It is a wrapper type
over `[T]` which enables you to view, manipulate, and take the address of
individual bits in memory. It behaves in every possible respect exactly like an
ordinary slice: it is dynamically-sized, and must be held by `&amp;` or `&amp;mut`
reference, just like `[T]`, and implements every inherent method and trait that
`[T]` does, to the absolute limits of what Rust permits.

The key to [`BitSlice`]’s powerful capability is that references to it use a
special encoding that store, in addition to the address of the base element and
the bit length, the index of the starting bit in the base element. This custom
reference encoding has some costs in what APIs are possible – for instance, Rust
forbids it from supporting `&amp;mut BitSlice[index] = bool` write indexing – but in
exchange, enables it to be *far* more capable than any other bit-slice crate in
existence.

Because of the volume of code that must be written to match the `[T]` standard
API, this module is organized very differently than the slice implementation in
the [`core`] and [`std`] distribution libraries.

- the root module `slice` contains new APIs that have no counterpart in `[T]`
- `slice/api` contains reïmplementations of the `[T]` inherent methods
- `slice/iter` implements all of the iteration capability
- `slice/ops` implements the traits in `core::ops`
- `slice/proxy` implements the proxy reference used in place of `&amp;mut bool`
- `slice/traits` implements all other traits not in `core::ops`
- lastly, `slice/tests` contains all the unit tests.

[`BitSlice`]: struct.BitSlice.html
[`core`]: core
[`std`]: std
[std]: https://doc.rust-lang.org/stable/std/slice
!*/</span>

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
<span class="kw">use</span> <span class="ident">alloc::vec::Vec</span>;
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
<span class="kw">use</span> <span class="ident">core::mem::ManuallyDrop</span>;
<span class="kw">use</span> <span class="ident">core</span>::{
	<span class="ident">marker::PhantomData</span>,
	<span class="ident">ops::RangeBounds</span>,
	<span class="ident">ptr</span>,
	<span class="ident">slice</span>,
};

<span class="kw">use</span> <span class="ident">funty</span>::{
	<span class="ident">IsInteger</span>,
	<span class="ident">IsNumber</span>,
};
<span class="kw">use</span> <span class="ident">radium::Radium</span>;
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
<span class="kw">use</span> <span class="ident">tap::pipe::Pipe</span>;

<span class="comment">//  Match the `core::slice` module topology.</span>
<span class="kw">pub</span> <span class="kw">use</span> <span class="self">self</span>::{
	<span class="ident">api</span>::{
		<span class="ident">from_mut</span>,
		<span class="ident">from_raw_parts</span>,
		<span class="ident">from_raw_parts_mut</span>,
		<span class="ident">from_ref</span>,
		<span class="ident">BitSliceIndex</span>,
	},
	<span class="ident">iter</span>::{
		<span class="ident">BitRefIter</span>,
		<span class="ident">BitValIter</span>,
		<span class="ident">Chunks</span>,
		<span class="ident">ChunksExact</span>,
		<span class="ident">ChunksExactMut</span>,
		<span class="ident">ChunksMut</span>,
		<span class="ident">Iter</span>,
		<span class="ident">IterMut</span>,
		<span class="ident">IterOnes</span>,
		<span class="ident">IterZeros</span>,
		<span class="ident">RChunks</span>,
		<span class="ident">RChunksExact</span>,
		<span class="ident">RChunksExactMut</span>,
		<span class="ident">RChunksMut</span>,
		<span class="ident">RSplit</span>,
		<span class="ident">RSplitMut</span>,
		<span class="ident">RSplitN</span>,
		<span class="ident">RSplitNMut</span>,
		<span class="ident">Split</span>,
		<span class="ident">SplitMut</span>,
		<span class="ident">SplitN</span>,
		<span class="ident">SplitNMut</span>,
		<span class="ident">Windows</span>,
	},
};
<span class="kw">use</span> <span class="kw">crate</span>::{
	<span class="ident">access::BitAccess</span>,
	<span class="ident">devel</span> <span class="kw">as</span> <span class="ident">dvl</span>,
	<span class="ident">domain</span>::{
		<span class="ident">BitDomain</span>,
		<span class="ident">BitDomainMut</span>,
		<span class="ident">Domain</span>,
		<span class="ident">DomainMut</span>,
	},
	<span class="ident">index::BitMask</span>,
	<span class="ident">mem::BitRegister</span>,
	<span class="ident">order</span>::{
		<span class="ident">BitOrder</span>,
		<span class="ident">Lsb0</span>,
		<span class="ident">Msb0</span>,
	},
	<span class="ident">ptr</span>::{
		<span class="ident">BitPtr</span>,
		<span class="ident">BitPtrRange</span>,
		<span class="ident">BitRef</span>,
		<span class="ident">BitSpan</span>,
		<span class="ident">BitSpanError</span>,
		<span class="ident">Const</span>,
		<span class="ident">Mut</span>,
	},
	<span class="ident">store::BitStore</span>,
};
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
<span class="kw">use</span> <span class="kw">crate</span>::{
	<span class="ident">ptr::AddressExt</span>,
	<span class="ident">vec::BitVec</span>,
};

<span class="kw">mod</span> <span class="ident">api</span>;
<span class="kw">mod</span> <span class="ident">iter</span>;
<span class="kw">mod</span> <span class="ident">ops</span>;
<span class="kw">mod</span> <span class="ident">specialization</span>;
<span class="kw">mod</span> <span class="ident">traits</span>;

<span class="doccomment">/** A slice of individual bits, anywhere in memory.

`BitSlice&lt;O, T&gt;` is an unsized region type; you interact with it through
`&amp;BitSlice&lt;O, T&gt;` and `&amp;mut BitSlice&lt;O, T&gt;` references, which work exactly like
all other Rust references. As with the standard slice’s relationship to arrays
and vectors, this is [`bitvec`]’s primary working type, but you will probably
hold it through one of the provided [`BitArray`], [`BitBox`], or [`BitVec`]
containers.

`BitSlice` is conceptually a `[bool]` slice, and provides a nearly complete
mirror of `[bool]`’s API.

Every bit-vector crate can give you an opaque type that hides shift/mask
calculations from you. `BitSlice` does far more than this: it offers you the
full Rust guarantees about reference behavior, including lifetime tracking,
mutability and aliasing awareness, and explicit memory control, *as well as* the
full set of tools and APIs available to the standard `[bool]` slice type.
`BitSlice` can arbitrarily split and subslice, just like `[bool]`. You can write
a linear consuming function and keep the patterns you already know.

For example, to trim all the bits off either edge that match a condition, you
could write

```rust
use bitvec::prelude::*;

fn trim&lt;O: BitOrder, T: BitStore&gt;(
  bits: &amp;BitSlice&lt;O, T&gt;,
  to_trim: bool,
) -&gt; &amp;BitSlice&lt;O, T&gt; {
  let stop = |b: &amp;bool| *b != to_trim;
  let front = bits.iter().by_ref().position(stop).unwrap_or(0);
  let back = bits.iter().by_ref().rposition(stop).map_or(0, |p| p + 1);
  &amp;bits[front .. back]
}
# assert_eq!(trim(bits![0, 0, 1, 1, 0, 1, 0], false), bits![1, 1, 0, 1]);
```

to get behavior something like
`trim(&amp;BitSlice[0, 0, 1, 1, 0, 1, 0], false) == &amp;BitSlice[1, 1, 0, 1]`.

# Documentation

All APIs that mirror something in the standard library will have an `Original`
section linking to the corresponding item. All APIs that have a different
signature or behavior than the original will have an `API Differences` section
explaining what has changed, and how to adapt your existing code to the change.

These sections look like this:

# Original

[`slice`](https://doc.rust-lang.org/stable/std/primitive.slice.html)

# API Differences

The slice type `[bool]` has no type parameters. `BitSlice&lt;O, T&gt;` has two: one
for the memory type used as backing storage, and one for the order of bits
within that memory type.

`&amp;BitSlice&lt;O, T&gt;` is capable of producing `&amp;bool` references to read bits out
of its memory, but is not capable of producing `&amp;mut bool` references to write
bits *into* its memory. Any `[bool]` API that would produce a `&amp;mut bool` will
instead produce a [`BitRef&lt;Mut, O, T&gt;`] proxy reference.

# Behavior

`BitSlice` is a wrapper over `[T]`. It describes a region of memory, and must be
handled indirectly. This is most commonly through the reference types
`&amp;BitSlice` and `&amp;mut BitSlice`, which borrow memory owned by some other value
in the program. These buffers can be directly owned by the sibling types
[`BitBox`], which behaves like [`Box&lt;[T]&gt;`](alloc::boxed::Box), and [`BitVec`],
which behaves like [`Vec&lt;T&gt;`]. It cannot be used as the type parameter to a
standard-library-provided handle type.

The `BitSlice` region provides access to each individual bit in the region, as
if each bit had a memory address that you could use to dereference it. It packs
each logical bit into exactly one bit of storage memory, just like
[`std::bitset`] and [`std::vector&lt;bool&gt;`] in C++.

# Type Parameters

`BitSlice` has two type parameters which propagate through nearly every public
API in the crate. These are very important to its operation, and your choice
of type arguments informs nearly every part of this library’s behavior.

## `T: BitStore`

[`BitStore`] is the simpler of the two parameters. It refers to the integer type
used to hold bits. It must be one of the Rust unsigned integer fundamentals:
`u8`, `u16`, `u32`, `usize`, and on 64-bit systems only, `u64`. In addition, it
can also be an alias-safed wrapper over them (see the [`access`] module) in
order to permit bit-slices to share underlying memory without interfering with
each other.

`BitSlice` references can only be constructed over the integers, not over their
aliasing wrappers. `BitSlice` will only use aliasing types in its `T` slots when
you invoke APIs that produce them, such as [`.split_at_mut()`].

The default type argument is `usize`.

The argument you choose is used as the basis of a `[T]` slice, over which the
`BitSlice` view type is placed. `BitSlice&lt;_, T&gt;` is subject to all of the rules
about alignment that `[T]` is. If you are working with in-memory representation
formats, chances are that you already have a `T` type with which you’ve been
working, and should use it here.

If you are only using this crate to discard the seven wasted bits per `bool`
of a collection of `bool`s, and are not too concerned about the in-memory
representation, then you should use the default type argument of `usize`. This
is because most processors work best when moving an entire `usize` between
memory and the processor itself, and using a smaller type may cause it to slow
down.

## `O: BitOrder`

[`BitOrder`] is the more complex parameter. It has a default argument which,
like `usize`, is the good-enough choice when you do not explicitly need to
control the representation of bits in memory.

This parameter determines how to index the bits within a single memory element
`T`. Computers all agree that in a slice of elements `T`, the element with the
lower index has a lower memory address than the element with the higher index.
But the individual bits within an element do not have addresses, and so there is
no uniform standard of which bit is the zeroth, which is the first, which is the
penultimate, and which is the last.

To make matters even more confusing, there are two predominant ideas of
in-element ordering that often *correlate* with the in-element *byte* ordering
of integer types, but are in fact wholly unrelated! [`bitvec`] provides these
two main orders as types for you, and if you need a different one, it also
provides the tools you need to make your own.

### Least Significant Bit Comes First

This ordering, named the [`Lsb0`] type, indexes bits within an element by
placing the `0` index at the least significant bit (numeric value `1`) and the
final index at the most significant bit (numeric value [`T::MIN`][minval] for
signed integers on most machines).

For example, this is the ordering used by most C compilers to lay out bit-field
struct members on little-endian **byte**-ordered machines.

### Most Significant Bit Comes First

This ordering, named the [`Msb0`] type, indexes bits within an element by
placing the `0` index at the most significant bit (numeric value
[`T::MIN`][minval] for most signed integers) and the final index at the least
significant bit (numeric value `1`).

For example, this is the ordering used by the [TCP wire format], and by most C
compilers to lay out bit-field struct members on big-endian **byte**-ordered
machines.

### Default Ordering

The default ordering is [`Lsb0`], as it typically produces shorter object code
than [`Msb0`] does. If you are implementing a collection, then `Lsb0` is likely
the more performant ordering; if you are implementing a buffer protocol, then
your choice of ordering is dictated by the protocol definition.

# Safety

`BitSlice` is designed to never introduce new memory unsafety that you did not
provide yourself, either before or during the use of this crate. Bugs do, and
have, occured, and you are encouraged to submit any discovered flaw as a defect
report.

The `&amp;BitSlice` reference type uses a private encoding scheme to hold all the
information needed in its stack value. This encoding is **not** part of the
public API of the library, and is not binary-compatible with `&amp;[T]`.
Furthermore, in order to satisfy Rust’s requirements about alias conditions,
`BitSlice` performs type transformations on the `T` parameter to ensure that it
never creates the potential for undefined behavior.

You must never attempt to type-cast a reference to `BitSlice` in any way. You
must not use [`mem::transmute`] with `BitSlice` anywhere in its type arguments.
You must not use `as`-casting to convert between `*BitSlice` and any other type.
You must not attempt to modify the binary representation of a `&amp;BitSlice`
reference value. These actions will all lead to runtime memory unsafety, are
(hopefully) likely to induce a program crash, and may possibly cause undefined
behavior at compile-time.

Everything in the `BitSlice` public API, even the `unsafe` parts, are guaranteed
to have no more unsafety than their equivalent parts in the standard library.
All `unsafe` APIs will have documentation explicitly detailing what the API
requires you to uphold in order for it to function safely and correctly. All
safe APIs will do so themselves.

# Performance

Like the standard library’s `[T]` slice, `BitSlice` is designed to be very easy
to use safely, while supporting `unsafe` when necessary. Rust has a powerful
optimizing engine, and `BitSlice` will frequently be compiled to have zero
runtime cost. Where it is slower, it will not be significantly slower than a
manual replacement.

As the machine instructions operate on registers rather than bits, your choice
of [`T: BitStore`] type parameter can influence your slice’s performance. Using
larger register types means that slices can gallop over completely-filled
interior elements faster, while narrower register types permit more graceful
handling of subslicing and aliased splits.

# Construction

`BitSlice` views of memory can be constructed over borrowed data in a number of
ways. As this is a reference-only type, it can only ever be built by borrowing
an existing memory buffer and taking temporary control of your program’s view of
the region.

## Macro Constructor

`BitSlice` buffers can be constructed at compile-time through the [`bits!`]
macro. This macro accepts a superset of the [`vec!`] arguments, and creates an
appropriate buffer in the local scope. The macro expands to a borrowed
[`BitArray`] temporary; currently, it cannot be assigned to a `static` binding.

```rust
use bitvec::prelude::*;

let immut = bits![Lsb0, u8; 0, 1, 0, 0, 1, 0, 0, 1];
let mutable: &amp;mut BitSlice&lt;_, _&gt; = bits![mut Msb0, u8; 0; 8];

assert_ne!(immut, mutable);
mutable.clone_from_bitslice(immut);
assert_eq!(immut, mutable);
```

## Borrowing Constructors

The functions [`from_element`], [`from_element_mut`], [`from_slice`], and
[`from_slice_mut`] take references to existing memory, and construct
`BitSlice` references over them. These are the most basic ways to borrow memory
and view it as bits.

```rust
use bitvec::prelude::*;

let data = [0u16; 3];
let local_borrow = BitSlice::&lt;Lsb0, _&gt;::from_slice(&amp;data);

let mut data = [0u8; 5];
let local_mut = BitSlice::&lt;Lsb0, _&gt;::from_slice_mut(&amp;mut data);
```

## Trait Method Constructors

The [`BitView`] trait implements [`.view_bits::&lt;O&gt;()`] and
[`.view_bits_mut::&lt;O&gt;()`] methods on elements, arrays not larger than 64
elements, and slices. This trait, imported in the crate prelude, is *probably*
the easiest way for you to borrow memory.

```rust
use bitvec::prelude::*;

let data = [0u32; 5];
let trait_view = data.view_bits::&lt;Lsb0&gt;();

let mut data = 0usize;
let trait_mut = data.view_bits_mut::&lt;Msb0&gt;();
```

## Owned Bit Slices

If you wish to take ownership of a memory region and enforce that it is always
viewed as a `BitSlice` by default, you can use one of the [`BitArray`],
[`BitBox`], or [`BitVec`] types, rather than pairing ordinary buffer types with
the borrowing constructors.

```rust
use bitvec::prelude::*;

let slice = bits![0; 27];
let array = bitarr![LocalBits, u8; 0; 10];
# #[cfg(feature = &quot;alloc&quot;)] fn allocs() {
let boxed = bitbox![0; 10];
let vec = bitvec![0; 20];
# } #[cfg(feature = &quot;alloc&quot;)] allocs();

// arrays always round up
assert_eq!(array.as_bitslice(), slice[.. 16]);
# #[cfg(feature = &quot;alloc&quot;)] fn allocs2() {
# let slice = bits![0; 27];
# let boxed = bitbox![0; 10];
# let vec = bitvec![0; 20];
assert_eq!(boxed.as_bitslice(), slice[.. 10]);
assert_eq!(vec.as_bitslice(), slice[.. 20]);
# } #[cfg(feature = &quot;alloc&quot;)] allocs2();
```

[TCP wire format]: https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure
[minval]: https://doc.rust-lang.org/stable/std/primitive.usize.html#associatedconstant.MIN

[`BitArray`]: crate::array::BitArray
[`BitBox`]: crate::boxed::BitBox
[`BitRef&lt;Mut, O, T&gt;`]: crate::ptr::BitRef
[`BitOrder`]: crate::order::BitOrder
[`BitStore`]: crate::store::BitStore
[`BitVec`]: crate::vec::BitVec
[`BitView`]: crate::view::BitView
[`Cell&lt;T&gt;`]: core::cell::Cell
[`Lsb0`]: crate::order::Lsb0
[`Msb0`]: crate::order::Msb0
[`T: BitStore`]: crate::store::BitStore
[`Vec&lt;T&gt;`]: alloc::vec::Vec

[`access`]: crate::access
[`bits!`]: macro@crate::bits
[`bitvec`]: crate
[`bitvec::prelude::LocalBits`]: crate::order::LocalBits
[`from_element`]: Self::from_element
[`from_element_mut`]: Self::from_element_mut
[`from_slice`]: Self::from_slice
[`from_slice_mut`]: Self::from_slice_mut
[`mem::transmute`]: core::mem::transmute
[`std::bitset`]: https://en.cppreference.com/w/cpp/utility/bitset
[`std::vector&lt;bool&gt;`]: https://en.cppreference.com/w/cpp/container/vector_bool
[`vec!`]: macro@alloc::vec

[`.split_at_mut()`]: Self::split_at_mut
[`.view_bits::&lt;O&gt;()`]: crate::view::BitView::view_bits
[`.view_bits_mut::&lt;O&gt;()`]: crate::view::BitView::view_bits_mut
**/</span>
<span class="attribute">#[<span class="ident">repr</span>(<span class="ident">transparent</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span> <span class="op">=</span> <span class="ident">Lsb0</span>, <span class="ident">T</span> <span class="op">=</span> <span class="ident">usize</span><span class="op">&gt;</span>
<span class="kw">where</span>
	<span class="ident">O</span>: <span class="ident">BitOrder</span>,
	<span class="ident">T</span>: <span class="ident">BitStore</span>,
{
	<span class="doccomment">/// The ordering of bits within a register `T`.</span>
	<span class="ident">_ord</span>: <span class="ident">PhantomData</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>,
	<span class="doccomment">/// The register type used for storage.</span>
	<span class="ident">_typ</span>: <span class="ident">PhantomData</span><span class="op">&lt;</span>[<span class="ident">T</span>]<span class="op">&gt;</span>,
	<span class="doccomment">/// Indicate that this is a newtype wrapper over a wholly-untyped slice.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This is necessary in order for the Rust compiler to remove restrictions</span>
	<span class="doccomment">/// on the possible values of references to this slice `&amp;BitSlice` and</span>
	<span class="doccomment">/// `&amp;mut BitSlice`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Rust has firm requirements that *any* reference that is directly usable</span>
	<span class="doccomment">/// to dereference a real value must conform to its rules about address</span>
	<span class="doccomment">/// liveness, type alignment, and for slices, trustworthy length. It is</span>
	<span class="doccomment">/// undefined behavior for a slice reference *to a dereferencable type* to</span>
	<span class="doccomment">/// violate any of these restrictions.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// However, the value of a reference to a zero-sized type has *no* such</span>
	<span class="doccomment">/// restrictions, because that reference can never perform direct memory</span>
	<span class="doccomment">/// access. The compiler will accept any value in a slot typed as `&amp;[()]`,</span>
	<span class="doccomment">/// because the values in it will never be used for a load or store</span>
	<span class="doccomment">/// instruction. If this were `[T]`, then Rust would make the pointer</span>
	<span class="doccomment">/// encoding used to manage values of `&amp;BitSlice` become undefined behavior.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// See the `ptr` module for information on the encoding used.</span>
	<span class="ident">_mem</span>: [()],
}

<span class="doccomment">/// General-purpose functions not present on `[T]`.</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
	<span class="ident">O</span>: <span class="ident">BitOrder</span>,
	<span class="ident">T</span>: <span class="ident">BitStore</span>,
{
	<span class="doccomment">/// Constructs a shared `&amp;BitSlice` reference over a shared element.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The [`BitView`] trait, implemented on all [`BitStore`] implementors,</span>
	<span class="doccomment">/// provides a method [`.view_bits::&lt;O&gt;()`] which delegates to this function</span>
	<span class="doccomment">/// and may be more convenient for you to write.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `elem`: A shared reference to a memory element.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// A shared `&amp;BitSlice` over the `elem` element.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let elem = 0u8;</span>
	<span class="doccomment">/// let bits = BitSlice::&lt;Lsb0, _&gt;::from_element(&amp;elem);</span>
	<span class="doccomment">/// assert_eq!(bits.len(), 8);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitStore`]: crate::store::BitStore</span>
	<span class="doccomment">/// [`BitView`]: crate::view::BitView</span>
	<span class="doccomment">/// [`.view_bits::&lt;O&gt;()`]: crate::view::BitView::view_bits</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">from_element</span>(<span class="ident">elem</span>: <span class="kw-2">&amp;</span><span class="ident">T</span>) -&gt; <span class="kw-2">&amp;</span><span class="self">Self</span> {
		<span class="kw">unsafe</span> { <span class="ident">BitPtr::from_ref</span>(<span class="ident">elem</span>).<span class="ident">span_unchecked</span>(<span class="ident">T::Mem::BITS</span> <span class="kw">as</span> <span class="ident">usize</span>) }
			.<span class="ident">to_bitslice_ref</span>()
	}

	<span class="doccomment">/// Constructs an exclusive `&amp;mut BitSlice` reference over an element.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The [`BitView`] trait, implemented on all [`BitStore`] implementors,</span>
	<span class="doccomment">/// provides a method [`.view_bits_mut::&lt;O&gt;()`] which delegates to this</span>
	<span class="doccomment">/// function and may be more convenient for you to write.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `elem`: An exclusive reference to a memory element.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// An exclusive `&amp;mut BitSlice` over the `elem` element.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Note that the original `elem` reference will be inaccessible for the</span>
	<span class="doccomment">/// duration of the returned slice handle’s lifetime.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let mut elem = 0u16;</span>
	<span class="doccomment">/// let bits = BitSlice::&lt;Msb0, _&gt;::from_element_mut(&amp;mut elem);</span>
	<span class="doccomment">/// bits.set(15, true);</span>
	<span class="doccomment">/// assert!(bits.get(15).unwrap());</span>
	<span class="doccomment">/// assert_eq!(elem, 1);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitStore`]: crate::store::BitStore</span>
	<span class="doccomment">/// [`BitView`]: crate::view::BitView</span>
	<span class="doccomment">/// [`.view_bits_mut::&lt;O&gt;()`]: crate::view::BitView::view_bits_mut</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">from_element_mut</span>(<span class="ident">elem</span>: <span class="kw-2">&amp;mut</span> <span class="ident">T</span>) -&gt; <span class="kw-2">&amp;mut</span> <span class="self">Self</span> {
		<span class="kw">unsafe</span> { <span class="ident">BitPtr::from_mut</span>(<span class="ident">elem</span>).<span class="ident">span_unchecked</span>(<span class="ident">T::Mem::BITS</span> <span class="kw">as</span> <span class="ident">usize</span>) }
			.<span class="ident">to_bitslice_mut</span>()
	}

	<span class="doccomment">/// Constructs a shared `&amp;BitSlice` reference over a slice.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The [`BitView`] trait, implemented on all `[T]` slices, provides a</span>
	<span class="doccomment">/// method [`.view_bits::&lt;O&gt;()`] which delegates to this function and may be</span>
	<span class="doccomment">/// more convenient for you to write.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `slice`: A shared reference over a sequence of memory elements.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// A `&amp;BitSlice` view of the provided slice. The error condition is only</span>
	<span class="doccomment">/// encountered if the source slice is too long to be encoded in a</span>
	<span class="doccomment">/// `&amp;BitSlice` handle, but such a slice is likely impossible to produce</span>
	<span class="doccomment">/// without causing errors long before calling this function.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Conditions</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The produced `&amp;BitSlice` handle always begins at the zeroth bit of the</span>
	<span class="doccomment">/// zeroth element in `slice`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let slice = &amp;[0u8, 1];</span>
	<span class="doccomment">/// let bits = BitSlice::&lt;Msb0, _&gt;::from_slice(slice).unwrap();</span>
	<span class="doccomment">/// assert!(bits[15]);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// An example showing this function failing would require a slice exceeding</span>
	<span class="doccomment">/// `!0usize &gt;&gt; 3` bytes in size, which is infeasible to produce.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitView`]: crate::view::BitView</span>
	<span class="doccomment">/// [`MAX_ELTS`]: Self::MAX_ELTS</span>
	<span class="doccomment">/// [`.view_bits::&lt;O&gt;()`]: crate::view::BitView::view_bits</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">from_slice</span>(<span class="ident">slice</span>: <span class="kw-2">&amp;</span>[<span class="ident">T</span>]) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="self">Self</span>, <span class="ident">BitSpanError</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span><span class="op">&gt;</span> {
		<span class="kw">let</span> <span class="ident">elts</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">len</span>();
		<span class="comment">//  Starting at the zeroth bit makes this counter an exclusive cap, not</span>
		<span class="comment">//  an inclusive cap. This is also pretty much impossible to hit.</span>
		<span class="kw">if</span> <span class="ident">elts</span> <span class="op">&gt;</span><span class="op">=</span> <span class="ident"><span class="self">Self</span>::MAX_ELTS</span> {
			<span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">BitSpanError::TooLong</span>(
				<span class="ident">elts</span>.<span class="ident">saturating_mul</span>(<span class="ident">T::Mem::BITS</span> <span class="kw">as</span> <span class="ident">usize</span>),
			));
		}
		<span class="prelude-val">Ok</span>(<span class="kw">unsafe</span> { <span class="ident"><span class="self">Self</span>::from_slice_unchecked</span>(<span class="ident">slice</span>) })
	}

	<span class="doccomment">/// Constructs an exclusive `&amp;mut BitSlice` reference over a slice.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The [`BitView`] trait, implemented on all `[T]` slices, provides a</span>
	<span class="doccomment">/// method [`.view_bits_mut::&lt;O&gt;()`] which delegates to this function and</span>
	<span class="doccomment">/// may be more convenient for you to write.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `slice`: An exclusive reference over a sequence of memory elements.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// A `&amp;mut BitSlice` view of the provided slice. The error condition is</span>
	<span class="doccomment">/// only encountered if the source slice is too long to be encoded in a</span>
	<span class="doccomment">/// `&amp;mut BitSlice` handle, but such a slice is likely impossible to produce</span>
	<span class="doccomment">/// without causing errors long before calling this function.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Note that the original `slice` reference will be inaccessible for the</span>
	<span class="doccomment">/// duration of the returned slice handle’s lifetime.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Conditions</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The produced `&amp;mut BitSlice` handle always begins at the zeroth bit of</span>
	<span class="doccomment">/// the zeroth element in `slice`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let mut slice = [0u8; 2];</span>
	<span class="doccomment">/// let bits = BitSlice::&lt;Lsb0, _&gt;::from_slice_mut(&amp;mut slice).unwrap();</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// assert!(!bits[0]);</span>
	<span class="doccomment">/// bits.set(0, true);</span>
	<span class="doccomment">/// assert!(bits[0]);</span>
	<span class="doccomment">/// assert_eq!(slice[0], 1);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This example attempts to construct a `&amp;mut BitSlice` handle from a slice</span>
	<span class="doccomment">/// that is too large to index. Either the `vec!` allocation will fail, or</span>
	<span class="doccomment">/// the bit-slice constructor will fail.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust,should_panic</span>
	<span class="doccomment">/// # #[cfg(feature = &quot;alloc&quot;)] {</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let mut data = vec![0usize; BitSlice::&lt;Lsb0, usize&gt;::MAX_ELTS];</span>
	<span class="doccomment">/// let bits = BitSlice::&lt;Lsb0, _&gt;::from_slice_mut(&amp;mut data[..]).unwrap();</span>
	<span class="doccomment">/// # }</span>
	<span class="doccomment">/// # #[cfg(not(feature = &quot;alloc&quot;))] panic!(&quot;No allocator present&quot;);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitView`]: crate::view::BitView</span>
	<span class="doccomment">/// [`MAX_ELTS`]: Self::MAX_ELTS</span>
	<span class="doccomment">/// [`.view_bits_mut::&lt;O&gt;()`]: crate::view::BitView::view_bits_mut</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">from_slice_mut</span>(
		<span class="ident">slice</span>: <span class="kw-2">&amp;mut</span> [<span class="ident">T</span>],
	) -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="kw-2">&amp;mut</span> <span class="self">Self</span>, <span class="ident">BitSpanError</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span><span class="op">&gt;</span> {
		<span class="kw">let</span> <span class="ident">elts</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">len</span>();
		<span class="kw">if</span> <span class="ident">elts</span> <span class="op">&gt;</span><span class="op">=</span> <span class="ident"><span class="self">Self</span>::MAX_ELTS</span> {
			<span class="kw">return</span> <span class="prelude-val">Err</span>(<span class="ident">BitSpanError::TooLong</span>(
				<span class="ident">elts</span>.<span class="ident">saturating_mul</span>(<span class="ident">T::Mem::BITS</span> <span class="kw">as</span> <span class="ident">usize</span>),
			));
		}
		<span class="prelude-val">Ok</span>(<span class="kw">unsafe</span> { <span class="ident"><span class="self">Self</span>::from_slice_unchecked_mut</span>(<span class="ident">slice</span>) })
	}

	<span class="doccomment">/// Converts a slice reference into a `BitSlice` reference without checking</span>
	<span class="doccomment">/// that its size can be safely used.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// If the `slice` length is longer than [`MAX_ELTS`], then the returned</span>
	<span class="doccomment">/// `BitSlice` will have its length severely truncated. This is not a safety</span>
	<span class="doccomment">/// violation, but it is behavior that callers must avoid to remain correct.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Prefer [`::from_slice()`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`MAX_ELTS`]: Self::MAX_ELTS</span>
	<span class="doccomment">/// [`::from_slice()`]: Self::from_slice</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">from_slice_unchecked</span>(<span class="ident">slice</span>: <span class="kw-2">&amp;</span>[<span class="ident">T</span>]) -&gt; <span class="kw-2">&amp;</span><span class="self">Self</span> {
		<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">len</span>().<span class="ident">wrapping_mul</span>(<span class="ident">T::Mem::BITS</span> <span class="kw">as</span> <span class="ident">usize</span>);
		<span class="ident">BitPtr::from_slice</span>(<span class="ident">slice</span>)
			.<span class="ident">span_unchecked</span>(<span class="ident">bits</span>)
			.<span class="ident">to_bitslice_ref</span>()
	}

	<span class="doccomment">/// Converts a slice reference into a `BitSlice` reference without checking</span>
	<span class="doccomment">/// that its size can be safely used.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// If the `slice` length is longer than [`MAX_ELTS`], then the returned</span>
	<span class="doccomment">/// `BitSlice` will have its length severely truncated. This is not a safety</span>
	<span class="doccomment">/// violation, but it is behavior that callers must avoid to remain correct.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Prefer [`::from_slice_mut()`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`MAX_ELTS`]: Self::MAX_ELTS</span>
	<span class="doccomment">/// [`::from_slice_mut()`]: Self::from_slice_mut</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">from_slice_unchecked_mut</span>(<span class="ident">slice</span>: <span class="kw-2">&amp;mut</span> [<span class="ident">T</span>]) -&gt; <span class="kw-2">&amp;mut</span> <span class="self">Self</span> {
		<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">slice</span>.<span class="ident">len</span>().<span class="ident">wrapping_mul</span>(<span class="ident">T::Mem::BITS</span> <span class="kw">as</span> <span class="ident">usize</span>);
		<span class="ident">BitPtr::from_mut_slice</span>(<span class="ident">slice</span>)
			.<span class="ident">span_unchecked</span>(<span class="ident">bits</span>)
			.<span class="ident">to_bitslice_mut</span>()
	}

	<span class="doccomment">/// Produces the empty slice reference.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This is equivalent to `&amp;[]` for ordinary slices.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits: &amp;BitSlice = BitSlice::empty();</span>
	<span class="doccomment">/// assert!(bits.is_empty());</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">empty</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>() -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">Self</span> {
		<span class="ident">BitSpan</span>::<span class="op">&lt;</span><span class="ident">Const</span>, <span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span><span class="ident">::EMPTY</span>.<span class="ident">to_bitslice_ref</span>()
	}

	<span class="doccomment">/// Produces the empty mutable slice reference.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This is equivalent to `&amp;mut []` for ordinary slices.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits: &amp;mut BitSlice = BitSlice::empty_mut();</span>
	<span class="doccomment">/// assert!(bits.is_empty());</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">empty_mut</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>() -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw-2">mut</span> <span class="self">Self</span> {
		<span class="ident">BitSpan::EMPTY</span>.<span class="ident">to_bitslice_mut</span>()
	}

	<span class="doccomment">/// Writes a new bit at a given index.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;mut self`</span>
	<span class="doccomment">/// - `index`: The bit index at which to write. It must be in the range `0</span>
	<span class="doccomment">///   .. self.len()`.</span>
	<span class="doccomment">/// - `value`: The value to be written; `true` for `1` or `false` for `0`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// If `index` is valid, then the bit to which it refers is set to `value`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Panics</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This method panics if `index` is not less than [`self.len()`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits = bits![mut 0];</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// assert!(!bits[0]);</span>
	<span class="doccomment">/// bits.set(0, true);</span>
	<span class="doccomment">/// assert!(bits[0]);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This example panics when it attempts to set a bit that is out of bounds.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust,should_panic</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits = bits![mut 0];</span>
	<span class="doccomment">/// bits.set(1, false);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`self.len()`]: Self::len</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">index</span>: <span class="ident">usize</span>, <span class="ident">value</span>: <span class="ident">bool</span>) {
		<span class="self">self</span>.<span class="ident">assert_in_bounds</span>(<span class="ident">index</span>, <span class="number">0</span> .. <span class="self">self</span>.<span class="ident">len</span>());
		<span class="kw">unsafe</span> {
			<span class="self">self</span>.<span class="ident">set_unchecked</span>(<span class="ident">index</span>, <span class="ident">value</span>);
		}
	}

	<span class="doccomment">/// Tests if *any* bit in the slice is set (logical `∨`).</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Truth Table</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```text</span>
	<span class="doccomment">/// 0 0 =&gt; 0</span>
	<span class="doccomment">/// 0 1 =&gt; 1</span>
	<span class="doccomment">/// 1 0 =&gt; 1</span>
	<span class="doccomment">/// 1 1 =&gt; 1</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Whether any bit in the slice domain is set. The empty slice returns</span>
	<span class="doccomment">/// `false`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits = bits![0, 1, 0, 0];</span>
	<span class="doccomment">/// assert!(bits[.. 2].any());</span>
	<span class="doccomment">/// assert!(!bits[2 ..].any());</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">any</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">bool</span> {
		<span class="kw">match</span> <span class="self">self</span>.<span class="ident">domain</span>() {
			<span class="ident">Domain::Enclave</span> { <span class="ident">head</span>, <span class="ident">elem</span>, <span class="ident">tail</span> } =&gt; {
				<span class="ident">O::mask</span>(<span class="ident">head</span>, <span class="ident">tail</span>) <span class="op">&amp;</span> <span class="ident">elem</span>.<span class="ident">load_value</span>() <span class="op">!</span><span class="op">=</span> <span class="ident">BitMask::ZERO</span>
			},
			<span class="ident">Domain::Region</span> { <span class="ident">head</span>, <span class="ident">body</span>, <span class="ident">tail</span> } =&gt; {
				<span class="ident">head</span>.<span class="ident">map_or</span>(<span class="bool-val">false</span>, <span class="op">|</span>(<span class="ident">head</span>, <span class="ident">elem</span>)<span class="op">|</span> {
					<span class="ident">O::mask</span>(<span class="ident">head</span>, <span class="prelude-val">None</span>) <span class="op">&amp;</span> <span class="ident">elem</span>.<span class="ident">load_value</span>() <span class="op">!</span><span class="op">=</span> <span class="ident">BitMask::ZERO</span>
				}) <span class="op">|</span><span class="op">|</span> <span class="ident">body</span>.<span class="ident">iter</span>().<span class="ident">any</span>(<span class="op">|</span><span class="ident">e</span><span class="op">|</span> <span class="ident">e</span>.<span class="ident">load_value</span>() <span class="op">!</span><span class="op">=</span> <span class="ident">T::Mem::ZERO</span>)
					<span class="op">|</span><span class="op">|</span> <span class="ident">tail</span>.<span class="ident">map_or</span>(<span class="bool-val">false</span>, <span class="op">|</span>(<span class="ident">elem</span>, <span class="ident">tail</span>)<span class="op">|</span> {
						<span class="ident">O::mask</span>(<span class="prelude-val">None</span>, <span class="ident">tail</span>) <span class="op">&amp;</span> <span class="ident">elem</span>.<span class="ident">load_value</span>() <span class="op">!</span><span class="op">=</span> <span class="ident">BitMask::ZERO</span>
					})
			},
		}
	}

	<span class="doccomment">/// Tests if *all* bits in the slice domain are set (logical `∧`).</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Truth Table</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```text</span>
	<span class="doccomment">/// 0 0 =&gt; 0</span>
	<span class="doccomment">/// 0 1 =&gt; 0</span>
	<span class="doccomment">/// 1 0 =&gt; 0</span>
	<span class="doccomment">/// 1 1 =&gt; 1</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Whether all bits in the slice domain are set. The empty slice returns</span>
	<span class="doccomment">/// `true`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits = bits![1, 1, 0, 1];</span>
	<span class="doccomment">/// assert!(bits[.. 2].all());</span>
	<span class="doccomment">/// assert!(!bits[2 ..].all());</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">all</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">bool</span> {
		<span class="kw">match</span> <span class="self">self</span>.<span class="ident">domain</span>() {
			<span class="ident">Domain::Enclave</span> { <span class="ident">head</span>, <span class="ident">elem</span>, <span class="ident">tail</span> } =&gt; {
				<span class="comment">/* Due to a bug in `rustc`, calling `.value()` on the two
				`BitMask` types, to use `T::Mem | T::Mem == T::Mem`, causes type
				resolution failure and only discovers the
				`for&lt;&#39;a&gt; BitOr&lt;&amp;&#39;a Self&gt;` implementation in the trait bounds
				`T::Mem: BitMemory: IsUnsigned: BitOr&lt;Self&gt; + for&lt;&#39;a&gt; BitOr&lt;&amp;&#39;a Self&gt;`.

				Until this is fixed, routing through the `BitMask`
				implementation suffices. The by-val and by-ref operator traits
				are at the same position in the bounds chain, making this quite
				a strange bug.
				*/</span>
				<span class="op">!</span><span class="ident">O::mask</span>(<span class="ident">head</span>, <span class="ident">tail</span>) <span class="op">|</span> <span class="ident">elem</span>.<span class="ident">load_value</span>() <span class="op">==</span> <span class="ident">BitMask::ALL</span>
			},
			<span class="ident">Domain::Region</span> { <span class="ident">head</span>, <span class="ident">body</span>, <span class="ident">tail</span> } =&gt; {
				<span class="ident">head</span>.<span class="ident">map_or</span>(<span class="bool-val">true</span>, <span class="op">|</span>(<span class="ident">head</span>, <span class="ident">elem</span>)<span class="op">|</span> {
					<span class="op">!</span><span class="ident">O::mask</span>(<span class="ident">head</span>, <span class="prelude-val">None</span>) <span class="op">|</span> <span class="ident">elem</span>.<span class="ident">load_value</span>() <span class="op">==</span> <span class="ident">BitMask::ALL</span>
				}) <span class="op">&amp;&amp;</span> <span class="ident">body</span>
					.<span class="ident">iter</span>()
					.<span class="ident">map</span>(<span class="ident">BitStore::load_value</span>)
					.<span class="ident">all</span>(<span class="op">|</span><span class="ident">e</span><span class="op">|</span> <span class="ident">e</span> <span class="op">==</span> <span class="ident">T::Mem::ALL</span>)
					<span class="op">&amp;&amp;</span> <span class="ident">tail</span>.<span class="ident">map_or</span>(<span class="bool-val">true</span>, <span class="op">|</span>(<span class="ident">elem</span>, <span class="ident">tail</span>)<span class="op">|</span> {
						<span class="op">!</span><span class="ident">O::mask</span>(<span class="prelude-val">None</span>, <span class="ident">tail</span>) <span class="op">|</span> <span class="ident">elem</span>.<span class="ident">load_value</span>() <span class="op">==</span> <span class="ident">BitMask::ALL</span>
					})
			},
		}
	}

	<span class="doccomment">/// Tests if *all* bits in the slice are unset (logical `¬∨`).</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Truth Table</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```text</span>
	<span class="doccomment">/// 0 0 =&gt; 1</span>
	<span class="doccomment">/// 0 1 =&gt; 0</span>
	<span class="doccomment">/// 1 0 =&gt; 0</span>
	<span class="doccomment">/// 1 1 =&gt; 0</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Whether all bits in the slice domain are unset.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits = bits![0, 1, 0, 0];</span>
	<span class="doccomment">/// assert!(!bits[.. 2].not_any());</span>
	<span class="doccomment">/// assert!(bits[2 ..].not_any());</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">not_any</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">bool</span> {
		<span class="op">!</span><span class="self">self</span>.<span class="ident">any</span>()
	}

	<span class="doccomment">/// Tests if *any* bit in the slice is unset (logical `¬∧`).</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Truth Table</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```text</span>
	<span class="doccomment">/// 0 0 =&gt; 1</span>
	<span class="doccomment">/// 0 1 =&gt; 1</span>
	<span class="doccomment">/// 1 0 =&gt; 1</span>
	<span class="doccomment">/// 1 1 =&gt; 0</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Whether any bit in the slice domain is unset.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits = bits![1, 1, 0, 1];</span>
	<span class="doccomment">/// assert!(!bits[.. 2].not_all());</span>
	<span class="doccomment">/// assert!(bits[2 ..].not_all());</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">not_all</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">bool</span> {
		<span class="op">!</span><span class="self">self</span>.<span class="ident">all</span>()
	}

	<span class="doccomment">/// Tests whether the slice has some, but not all, bits set and some, but</span>
	<span class="doccomment">/// not all, bits unset.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This is `false` if either [`.all()`] or [`.not_any()`] are `true`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Truth Table</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```text</span>
	<span class="doccomment">/// 0 0 =&gt; 0</span>
	<span class="doccomment">/// 0 1 =&gt; 1</span>
	<span class="doccomment">/// 1 0 =&gt; 1</span>
	<span class="doccomment">/// 1 1 =&gt; 0</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Whether the slice domain has mixed content. The empty slice returns</span>
	<span class="doccomment">/// `false`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let data = 0b111_000_10u8;</span>
	<span class="doccomment">/// let bits = bits![1, 1, 0, 0, 1, 0];</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// assert!(!bits[.. 2].some());</span>
	<span class="doccomment">/// assert!(!bits[2 .. 4].some());</span>
	<span class="doccomment">/// assert!(bits.some());</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`.all()`]: Self::all</span>
	<span class="doccomment">/// [`.not_any()`]: Self::not_any</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">some</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">bool</span> {
		<span class="self">self</span>.<span class="ident">any</span>() <span class="op">&amp;&amp;</span> <span class="self">self</span>.<span class="ident">not_all</span>()
	}

	<span class="doccomment">/// Counts the number of bits set to `1` in the slice contents.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The number of bits in the slice domain that are set to `1`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Basic usage:</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits = bits![1, 1, 0, 0];</span>
	<span class="doccomment">/// assert_eq!(bits[.. 2].count_ones(), 2);</span>
	<span class="doccomment">/// assert_eq!(bits[2 ..].count_ones(), 0);</span>
	<span class="doccomment">/// ```</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">count_ones</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">usize</span> {
		<span class="kw">match</span> <span class="self">self</span>.<span class="ident">domain</span>() {
			<span class="ident">Domain::Enclave</span> { <span class="ident">head</span>, <span class="ident">elem</span>, <span class="ident">tail</span> } =&gt; (<span class="ident">O::mask</span>(<span class="ident">head</span>, <span class="ident">tail</span>)
				<span class="op">&amp;</span> <span class="ident">elem</span>.<span class="ident">load_value</span>())
			.<span class="ident">into_inner</span>()
			.<span class="ident">count_ones</span>() <span class="kw">as</span> <span class="ident">usize</span>,
			<span class="ident">Domain::Region</span> { <span class="ident">head</span>, <span class="ident">body</span>, <span class="ident">tail</span> } =&gt; {
				<span class="ident">head</span>.<span class="ident">map_or</span>(<span class="number">0</span>, <span class="op">|</span>(<span class="ident">head</span>, <span class="ident">elem</span>)<span class="op">|</span> {
					(<span class="ident">O::mask</span>(<span class="ident">head</span>, <span class="prelude-val">None</span>) <span class="op">&amp;</span> <span class="ident">elem</span>.<span class="ident">load_value</span>())
						.<span class="ident">into_inner</span>()
						.<span class="ident">count_ones</span>() <span class="kw">as</span> <span class="ident">usize</span>
				}) <span class="op">+</span> <span class="ident">body</span>
					.<span class="ident">iter</span>()
					.<span class="ident">map</span>(<span class="ident">BitStore::load_value</span>)
					.<span class="ident">map</span>(<span class="op">|</span><span class="ident">e</span><span class="op">|</span> <span class="ident">e</span>.<span class="ident">count_ones</span>() <span class="kw">as</span> <span class="ident">usize</span>)
					.<span class="ident">sum</span>::<span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span>() <span class="op">+</span> <span class="ident">tail</span>.<span class="ident">map_or</span>(<span class="number">0</span>, <span class="op">|</span>(<span class="ident">elem</span>, <span class="ident">tail</span>)<span class="op">|</span> {
					(<span class="ident">O::mask</span>(<span class="prelude-val">None</span>, <span class="ident">tail</span>) <span class="op">&amp;</span> <span class="ident">elem</span>.<span class="ident">load_value</span>())
						.<span class="ident">into_inner</span>()
						.<span class="ident">count_ones</span>() <span class="kw">as</span> <span class="ident">usize</span>
				})
			},
		}
	}

	<span class="doccomment">/// Counts the number of bits cleared to `0` in the slice contents.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The number of bits in the slice domain that are cleared to `0`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Basic usage:</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits = bits![1, 1, 0, 0];</span>
	<span class="doccomment">/// assert_eq!(bits[.. 2].count_zeros(), 0);</span>
	<span class="doccomment">/// assert_eq!(bits[2 ..].count_zeros(), 2);</span>
	<span class="doccomment">/// ```</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">count_zeros</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">usize</span> {
		<span class="kw">match</span> <span class="self">self</span>.<span class="ident">domain</span>() {
			<span class="ident">Domain::Enclave</span> { <span class="ident">head</span>, <span class="ident">elem</span>, <span class="ident">tail</span> } =&gt; (<span class="op">!</span><span class="ident">O::mask</span>(<span class="ident">head</span>, <span class="ident">tail</span>)
				<span class="op">|</span> <span class="ident">elem</span>.<span class="ident">load_value</span>())
			.<span class="ident">into_inner</span>()
			.<span class="ident">count_zeros</span>() <span class="kw">as</span> <span class="ident">usize</span>,
			<span class="ident">Domain::Region</span> { <span class="ident">head</span>, <span class="ident">body</span>, <span class="ident">tail</span> } =&gt; {
				<span class="ident">head</span>.<span class="ident">map_or</span>(<span class="number">0</span>, <span class="op">|</span>(<span class="ident">head</span>, <span class="ident">elem</span>)<span class="op">|</span> {
					(<span class="op">!</span><span class="ident">O::mask</span>(<span class="ident">head</span>, <span class="prelude-val">None</span>) <span class="op">|</span> <span class="ident">elem</span>.<span class="ident">load_value</span>())
						.<span class="ident">into_inner</span>()
						.<span class="ident">count_zeros</span>() <span class="kw">as</span> <span class="ident">usize</span>
				}) <span class="op">+</span> <span class="ident">body</span>
					.<span class="ident">iter</span>()
					.<span class="ident">map</span>(<span class="ident">BitStore::load_value</span>)
					.<span class="ident">map</span>(<span class="op">|</span><span class="ident">e</span><span class="op">|</span> <span class="ident">e</span>.<span class="ident">count_zeros</span>() <span class="kw">as</span> <span class="ident">usize</span>)
					.<span class="ident">sum</span>::<span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span>() <span class="op">+</span> <span class="ident">tail</span>.<span class="ident">map_or</span>(<span class="number">0</span>, <span class="op">|</span>(<span class="ident">elem</span>, <span class="ident">tail</span>)<span class="op">|</span> {
					(<span class="op">!</span><span class="ident">O::mask</span>(<span class="prelude-val">None</span>, <span class="ident">tail</span>) <span class="op">|</span> <span class="ident">elem</span>.<span class="ident">load_value</span>())
						.<span class="ident">into_inner</span>()
						.<span class="ident">count_zeros</span>() <span class="kw">as</span> <span class="ident">usize</span>
				})
			},
		}
	}

	<span class="doccomment">/// Enumerates all bits in a `BitSlice` that are set to `1`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits = bits![0, 1, 0, 0, 1, 0, 0, 0, 1];</span>
	<span class="doccomment">/// let mut indices = [1, 4, 8].iter().copied();</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let mut iter_ones = bits.iter_ones();</span>
	<span class="doccomment">/// let mut compose = bits.iter()</span>
	<span class="doccomment">///   .copied()</span>
	<span class="doccomment">///   .enumerate()</span>
	<span class="doccomment">///   .filter_map(|(idx, bit)| if bit { Some(idx) } else { None });</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// for ((a, b), c) in iter_ones.zip(compose).zip(indices) {</span>
	<span class="doccomment">///   assert_eq!(a, b);</span>
	<span class="doccomment">///   assert_eq!(b, c);</span>
	<span class="doccomment">/// }</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">iter_ones</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">IterOnes</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> {
		<span class="ident">IterOnes::new</span>(<span class="self">self</span>)
	}

	<span class="doccomment">/// Enumerates all bits in a `BitSlice` that are cleared to `0`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits = bits![1, 0, 1, 1, 0, 1, 1, 1, 0];</span>
	<span class="doccomment">/// let mut indices = [1, 4, 8].iter().copied();</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let mut iter_zeros = bits.iter_zeros();</span>
	<span class="doccomment">/// let mut compose = bits.iter()</span>
	<span class="doccomment">///   .copied()</span>
	<span class="doccomment">///   .enumerate()</span>
	<span class="doccomment">///   .filter_map(|(idx, bit)| if !bit { Some(idx) } else { None });</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// for ((a, b), c) in iter_zeros.zip(compose).zip(indices) {</span>
	<span class="doccomment">///   assert_eq!(a, b);</span>
	<span class="doccomment">///   assert_eq!(b, c);</span>
	<span class="doccomment">/// }</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">iter_zeros</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">IterZeros</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> {
		<span class="ident">IterZeros::new</span>(<span class="self">self</span>)
	}

	<span class="doccomment">/// Gets the index of the first bit in the bit-slice set to `1`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// assert!(bits![].first_one().is_none());</span>
	<span class="doccomment">/// assert_eq!(bits![0, 0, 1].first_one().unwrap(), 2);</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">first_one</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> {
		<span class="self">self</span>.<span class="ident">iter_ones</span>().<span class="ident">next</span>()
	}

	<span class="doccomment">/// Gets the index of the first bit in the bit-slice set to `0`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// assert!(bits![].first_zero().is_none());</span>
	<span class="doccomment">/// assert_eq!(bits![1, 1, 0].first_zero().unwrap(), 2);</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">first_zero</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> {
		<span class="self">self</span>.<span class="ident">iter_zeros</span>().<span class="ident">next</span>()
	}

	<span class="doccomment">/// Gets the index of the last bit in the bit-slice set to `1`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// assert!(bits![].last_one().is_none());</span>
	<span class="doccomment">/// assert_eq!(bits![1, 0, 0, 1].last_one().unwrap(), 3);</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">last_one</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> {
		<span class="self">self</span>.<span class="ident">iter_ones</span>().<span class="ident">next_back</span>()
	}

	<span class="doccomment">/// Gets the index of the last bit in the bit-slice set to `0`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// assert!(bits![].last_zero().is_none());</span>
	<span class="doccomment">/// assert_eq!(bits![0, 1, 1, 0].last_zero().unwrap(), 3);</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">last_zero</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> {
		<span class="self">self</span>.<span class="ident">iter_zeros</span>().<span class="ident">next_back</span>()
	}

	<span class="doccomment">/// Counts the number of bits from the start of the bit-slice to the first</span>
	<span class="doccomment">/// bit set to `0`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This returns `0` if the bit-slice is empty.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// assert_eq!(bits![].leading_ones(), 0);</span>
	<span class="doccomment">/// assert_eq!(bits![0].leading_ones(), 0);</span>
	<span class="doccomment">/// assert_eq!(bits![1, 0, 1, 1].leading_ones(), 1);</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">leading_ones</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">usize</span> {
		<span class="self">self</span>.<span class="ident">first_zero</span>().<span class="ident">unwrap_or_default</span>()
	}

	<span class="doccomment">/// Counts the number of bits from the start of the bit-slice to the first</span>
	<span class="doccomment">/// bit set to `1`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This returns `0` if the bit-slice is empty.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// assert_eq!(bits![].leading_zeros(), 0);</span>
	<span class="doccomment">/// assert_eq!(bits![1].leading_zeros(), 0);</span>
	<span class="doccomment">/// assert_eq!(bits![0, 1, 0, 0].leading_zeros(), 1);</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">leading_zeros</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">usize</span> {
		<span class="self">self</span>.<span class="ident">first_one</span>().<span class="ident">unwrap_or_default</span>()
	}

	<span class="doccomment">/// Counts the number of bits from the end of the bit-slice to the last bit</span>
	<span class="doccomment">/// set to `0`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This returns `0` if the bit-slice is empty.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// assert_eq!(bits![].trailing_ones(), 0);</span>
	<span class="doccomment">/// assert_eq!(bits![0].trailing_ones(), 0);</span>
	<span class="doccomment">/// assert_eq!(bits![1, 0, 1, 1].trailing_ones(), 2);</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">trailing_ones</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">usize</span> {
		<span class="self">self</span>.<span class="ident">last_zero</span>()
			.<span class="ident">map</span>(<span class="op">|</span><span class="ident">idx</span><span class="op">|</span> <span class="self">self</span>.<span class="ident">len</span>() <span class="op">-</span> <span class="number">1</span> <span class="op">-</span> <span class="ident">idx</span>)
			.<span class="ident">unwrap_or_default</span>()
	}

	<span class="doccomment">/// Counts the number of bits from the end of the bit-slice to the last bit</span>
	<span class="doccomment">/// set to `1`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This returns `0` if the bit-slice is empty.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// assert_eq!(bits![].trailing_zeros(), 0);</span>
	<span class="doccomment">/// assert_eq!(bits![1].trailing_zeros(), 0);</span>
	<span class="doccomment">/// assert_eq!(bits![0, 1, 0, 0].trailing_zeros(), 2);</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">trailing_zeros</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">usize</span> {
		<span class="self">self</span>.<span class="ident">last_one</span>()
			.<span class="ident">map</span>(<span class="op">|</span><span class="ident">idx</span><span class="op">|</span> <span class="self">self</span>.<span class="ident">len</span>() <span class="op">-</span> <span class="number">1</span> <span class="op">-</span> <span class="ident">idx</span>)
			.<span class="ident">unwrap_or_default</span>()
	}

	<span class="doccomment">/// Copies the bits from `src` into `self`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The length of `src` must be the same as `self.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// If `src` has the same type arguments as `self`, it can be more</span>
	<span class="doccomment">/// performant to use [`.copy_from_bitslice()`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Original</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`slice::clone_from_bitslice`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.clone_from_bitslice)</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # API Differences</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This method is renamed, as it takes a bit slice rather than an element</span>
	<span class="doccomment">/// slice.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Panics</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function will panic if the two slices have different lengths.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Cloning two bits from a slice into another:</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let src = bits![Msb0, u16; 1; 4];</span>
	<span class="doccomment">/// let dst = bits![mut Lsb0, u8; 0; 2];</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// dst.clone_from_bitslice(&amp;src[2 ..]);</span>
	<span class="doccomment">/// assert_eq!(dst, bits![1; 2]);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Rust enforces that there can only be one mutable reference with no</span>
	<span class="doccomment">/// immutable references to a particular piece of data in a particular</span>
	<span class="doccomment">/// scope. Because of this, attempting to use clone_from_slice on a single</span>
	<span class="doccomment">/// slice will result in a compile failure:</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust,compile_fail</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let slice = bits![mut 0, 0, 0, 1, 1];</span>
	<span class="doccomment">/// slice[.. 2].clone_from_bitslice(&amp;slice[3 ..]); // compile fail!</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// To work around this, we can use [`.split_at_mut()`] to create two</span>
	<span class="doccomment">/// distinct sub-slices from a slice:</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let slice = bits![mut 0, 0, 0, 1, 1];</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// {</span>
	<span class="doccomment">///   let (left, right) = slice.split_at_mut(2);</span>
	<span class="doccomment">///   left.clone_from_bitslice(&amp;right[1 ..]);</span>
	<span class="doccomment">/// }</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// assert_eq!(slice, bits![1, 1, 0, 1, 1]);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Performance</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// If `self` and `src` use the same type arguments, this specializes to</span>
	<span class="doccomment">/// [`.copy_from_bitslice()`]; if you know statically that this is the case,</span>
	<span class="doccomment">/// prefer to call that method directly and avoid the cost of detection at</span>
	<span class="doccomment">/// runtime. Otherwise, this is a bit-by-bit crawl across both slices, which</span>
	<span class="doccomment">/// is a slow process.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`.copy_from_bitslice()`]: Self::copy_from_bitslice</span>
	<span class="doccomment">/// [`.split_at_mut()`]: Self::split_at_mut</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">clone_from_bitslice</span><span class="op">&lt;</span><span class="ident">O2</span>, <span class="ident">T2</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">src</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O2</span>, <span class="ident">T2</span><span class="op">&gt;</span>)
	<span class="kw">where</span>
		<span class="ident">O2</span>: <span class="ident">BitOrder</span>,
		<span class="ident">T2</span>: <span class="ident">BitStore</span>,
	{
		<span class="macro">assert_eq!</span>(
			<span class="self">self</span>.<span class="ident">len</span>(),
			<span class="ident">src</span>.<span class="ident">len</span>(),
			<span class="string">&quot;Cloning between slices requires equal lengths&quot;</span>
		);

		<span class="kw">if</span> <span class="ident">dvl::match_types</span>::<span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span>, <span class="ident">O2</span>, <span class="ident">T2</span><span class="op">&gt;</span>() {
			<span class="kw">let</span> <span class="ident">that</span> <span class="op">=</span> <span class="ident">src</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="kw">_</span>;
			<span class="kw">unsafe</span> {
				<span class="self">self</span>.<span class="ident">copy_from_bitslice</span>(<span class="kw-2">&amp;</span><span class="kw-2">*</span><span class="ident">that</span>);
			}
		}
		<span class="kw">else</span> {
			<span class="kw">for</span> (<span class="ident">to</span>, <span class="ident">from</span>) <span class="kw">in</span>
				<span class="self">self</span>.<span class="ident">as_mut_bitptr_range</span>().<span class="ident">zip</span>(<span class="ident">src</span>.<span class="ident">as_bitptr_range</span>())
			{
				<span class="kw">unsafe</span> {
					<span class="ident">to</span>.<span class="ident">write</span>(<span class="ident">from</span>.<span class="ident">read</span>());
				}
			}
		}
	}

	<span class="doccomment">/// Copies all bits from `src` into `self`, using a memcpy wherever</span>
	<span class="doccomment">/// possible.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The length of `src` must be same as `self`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// If `src` does not use the same type arguments as `self`, use</span>
	<span class="doccomment">/// [`.clone_from_bitslice()`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Original</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`slice::copy_from_slice`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.copy_from_slice)</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # API Differences</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This method is renamed, as it takes a bit slice rather than an element</span>
	<span class="doccomment">/// slice.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Panics</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function will panic if the two slices have different lengths.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Copying two bits from a slice into another:</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let src = bits![1; 4];</span>
	<span class="doccomment">/// let dst = bits![mut 0; 2];</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// // Because the slices have to be the same length,</span>
	<span class="doccomment">/// // we slice the source slice from four bits to</span>
	<span class="doccomment">/// // two. It will panic if we don&#39;t do this.</span>
	<span class="doccomment">/// dst.clone_from_bitslice(&amp;src[2..]);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Rust enforces that there can only be one mutable reference with no</span>
	<span class="doccomment">/// immutable references to a particular piece of data in a particular</span>
	<span class="doccomment">/// scope. Because of this, attempting to use [.copy_from_slice()] on a</span>
	<span class="doccomment">/// single slice will result in a compile failure:</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust,compile_fail</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let slice = bits![mut 0, 0, 0, 1, 1];</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// slice[.. 2].copy_from_bitslice(&amp;bits[3 ..]); // compile fail!</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// To work around this, we can use [`.split_at_mut()`] to create two</span>
	<span class="doccomment">/// distinct sub-slices from a slice:</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let slice = bits![mut 0, 0, 0, 1, 1];</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// {</span>
	<span class="doccomment">///   let (left, right) = slice.split_at_mut(2);</span>
	<span class="doccomment">///   left.copy_from_bitslice(&amp;right[1 ..]);</span>
	<span class="doccomment">/// }</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// assert_eq!(slice, bits![1, 1, 0, 1, 1]);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`.clone_from_bitslice()`]: Self::clone_from_bitslice</span>
	<span class="doccomment">/// [`.split_at_mut()`]: Self::split_at_mut</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">copy_from_bitslice</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">src</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>) {
		<span class="macro">assert_eq!</span>(
			<span class="self">self</span>.<span class="ident">len</span>(),
			<span class="ident">src</span>.<span class="ident">len</span>(),
			<span class="string">&quot;Copying between slices requires equal lengths&quot;</span>
		);

		<span class="kw">let</span> (<span class="ident">d_head</span>, <span class="ident">s_head</span>) <span class="op">=</span>
			(<span class="self">self</span>.<span class="ident">as_bitspan</span>().<span class="ident">head</span>(), <span class="ident">src</span>.<span class="ident">as_bitspan</span>().<span class="ident">head</span>());
		<span class="comment">//  Where the two slices have identical layouts (head index and length),</span>
		<span class="comment">//  the copy can be done by using the memory domains.</span>
		<span class="kw">if</span> <span class="ident">d_head</span> <span class="op">==</span> <span class="ident">s_head</span> {
			<span class="kw">match</span> (<span class="self">self</span>.<span class="ident">domain_mut</span>(), <span class="ident">src</span>.<span class="ident">domain</span>()) {
				(
					<span class="ident">DomainMut::Enclave</span> {
						<span class="ident">elem</span>: <span class="ident">d_elem</span>, <span class="ident">tail</span>, ..
					},
					<span class="ident">Domain::Enclave</span> { <span class="ident">elem</span>: <span class="ident">s_elem</span>, .. },
				) =&gt; {
					<span class="kw">let</span> <span class="ident">mask</span> <span class="op">=</span> <span class="ident">O::mask</span>(<span class="ident">d_head</span>, <span class="ident">tail</span>);
					<span class="ident">d_elem</span>.<span class="ident">clear_bits</span>(<span class="ident">mask</span>);
					<span class="ident">d_elem</span>.<span class="ident">set_bits</span>(<span class="ident">mask</span> <span class="op">&amp;</span> <span class="ident">s_elem</span>.<span class="ident">load_value</span>());
				},
				(
					<span class="ident">DomainMut::Region</span> {
						<span class="ident">head</span>: <span class="ident">d_head</span>,
						<span class="ident">body</span>: <span class="ident">d_body</span>,
						<span class="ident">tail</span>: <span class="ident">d_tail</span>,
					},
					<span class="ident">Domain::Region</span> {
						<span class="ident">head</span>: <span class="ident">s_head</span>,
						<span class="ident">body</span>: <span class="ident">s_body</span>,
						<span class="ident">tail</span>: <span class="ident">s_tail</span>,
					},
				) =&gt; {
					<span class="kw">if</span> <span class="kw">let</span> (<span class="prelude-val">Some</span>((<span class="ident">h_idx</span>, <span class="ident">dh_elem</span>)), <span class="prelude-val">Some</span>((<span class="kw">_</span>, <span class="ident">sh_elem</span>))) <span class="op">=</span>
						(<span class="ident">d_head</span>, <span class="ident">s_head</span>)
					{
						<span class="kw">let</span> <span class="ident">mask</span> <span class="op">=</span> <span class="ident">O::mask</span>(<span class="ident">h_idx</span>, <span class="prelude-val">None</span>);
						<span class="ident">dh_elem</span>.<span class="ident">clear_bits</span>(<span class="ident">mask</span>);
						<span class="ident">dh_elem</span>.<span class="ident">set_bits</span>(<span class="ident">mask</span> <span class="op">&amp;</span> <span class="ident">sh_elem</span>.<span class="ident">load_value</span>());
					}
					<span class="kw">for</span> (<span class="ident">dst</span>, <span class="ident">src</span>) <span class="kw">in</span> <span class="ident">d_body</span>.<span class="ident">iter_mut</span>().<span class="ident">zip</span>(<span class="ident">s_body</span>.<span class="ident">iter</span>()) {
						<span class="ident">dst</span>.<span class="ident">store_value</span>(<span class="ident">src</span>.<span class="ident">load_value</span>())
					}
					<span class="kw">if</span> <span class="kw">let</span> (<span class="prelude-val">Some</span>((<span class="ident">dt_elem</span>, <span class="ident">t_idx</span>)), <span class="prelude-val">Some</span>((<span class="ident">st_elem</span>, <span class="kw">_</span>))) <span class="op">=</span>
						(<span class="ident">d_tail</span>, <span class="ident">s_tail</span>)
					{
						<span class="kw">let</span> <span class="ident">mask</span> <span class="op">=</span> <span class="ident">O::mask</span>(<span class="prelude-val">None</span>, <span class="ident">t_idx</span>);
						<span class="ident">dt_elem</span>.<span class="ident">clear_bits</span>(<span class="ident">mask</span>);
						<span class="ident">dt_elem</span>.<span class="ident">set_bits</span>(<span class="ident">mask</span> <span class="op">&amp;</span> <span class="ident">st_elem</span>.<span class="ident">load_value</span>());
					}
				},
				<span class="kw">_</span> =&gt; <span class="macro">unreachable!</span>(
					<span class="string">&quot;Slices with equal type parameters, lengths, and heads \
					 will always have equal domains&quot;</span>
				),
			}
		}
		<span class="comment">/* TODO(myrrlyn): Remove this when specialization stabilizes.

		This section simulates access to specialization through partial
		type-argument application. It detects accelerable type arguments (`O`
		values provided by `bitvec`, where `BitSlice&lt;O, _&gt;` implements
		`BitField`) and uses their batch load/store behavior to move more than
		one bit per cycle.

		Without language-level specialization, we cannot dispatch to
		individually well-typed functions, so instead this block uses the
		compiler’s `TypeId` API to inspect the type arguments passed to a
		monomorphization and select the appropriate codegen for it. We know that
		control will only enter any of these subsequent blocks when the type
		argument to monomorphization matches the guard, so the pointer casts
		become the identity function, which is safe and correct.

		This is only safe to do in `.copy_from_bitslice()`, not in
		`.clone_from_bitslice()`, because `BitField`’s behavior will only be
		correct when the two slices are matching in both their ordering and
		storage type arguments. Mismatches will cause an observed shuffling of
		sections as `BitField` reïnterprets raw bytes according to the machine
		register selected.
		*/</span>
		<span class="kw">else</span> <span class="kw">if</span> <span class="ident">dvl::match_order</span>::<span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">Lsb0</span><span class="op">&gt;</span>() {
			<span class="kw">let</span> <span class="ident">this</span>: <span class="kw-2">&amp;mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Lsb0</span>, <span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span>
				<span class="kw">unsafe</span> { <span class="kw-2">&amp;mut</span> <span class="kw-2">*</span>(<span class="self">self</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="kw">_</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="kw">_</span>) };
			<span class="kw">let</span> <span class="ident">that</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Lsb0</span>, <span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span>
				<span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">*</span>(<span class="ident">src</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="kw">_</span>) };
			<span class="ident">this</span>.<span class="ident">sp_copy_from_bitslice</span>(<span class="ident">that</span>);
		}
		<span class="kw">else</span> <span class="kw">if</span> <span class="ident">dvl::match_order</span>::<span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">Msb0</span><span class="op">&gt;</span>() {
			<span class="kw">let</span> <span class="ident">this</span>: <span class="kw-2">&amp;mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span>
				<span class="kw">unsafe</span> { <span class="kw-2">&amp;mut</span> <span class="kw-2">*</span>(<span class="self">self</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="kw">_</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="kw">_</span>) };
			<span class="kw">let</span> <span class="ident">that</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span>
				<span class="kw">unsafe</span> { <span class="kw-2">&amp;</span><span class="kw-2">*</span>(<span class="ident">src</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="kw">_</span>) };
			<span class="ident">this</span>.<span class="ident">sp_copy_from_bitslice</span>(<span class="ident">that</span>);
		}
		<span class="kw">else</span> {
			<span class="kw">for</span> (<span class="ident">from</span>, <span class="ident">to</span>) <span class="kw">in</span>
				<span class="ident">src</span>.<span class="ident">as_bitptr_range</span>().<span class="ident">zip</span>(<span class="self">self</span>.<span class="ident">as_mut_bitptr_range</span>())
			{
				<span class="kw">unsafe</span> {
					<span class="ident">to</span>.<span class="ident">write</span>(<span class="ident">from</span>.<span class="ident">read</span>());
				}
			}
		}
	}

	<span class="doccomment">/// Swaps all bits in `self` with those in `other`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The length of `other` must be the same as `self`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Original</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`slice::swap_with_slice`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.swap_with_slice)</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # API Differences</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This method is renamed, as it takes a bit slice rather than an element</span>
	<span class="doccomment">/// slice.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Panics</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function will panic if the two slices have different lengths.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let mut one = [0xA5u8, 0x69];</span>
	<span class="doccomment">/// let mut two = 0x1234u16;</span>
	<span class="doccomment">/// let one_bits = one.view_bits_mut::&lt;Msb0&gt;();</span>
	<span class="doccomment">/// let two_bits = two.view_bits_mut::&lt;Lsb0&gt;();</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// one_bits.swap_with_bitslice(two_bits);</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// assert_eq!(one, [0x2C, 0x48]);</span>
	<span class="doccomment">/// # #[cfg(target_endian = &quot;little&quot;)] {</span>
	<span class="doccomment">/// assert_eq!(two, 0x96A5);</span>
	<span class="doccomment">/// # }</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">swap_with_bitslice</span><span class="op">&lt;</span><span class="ident">O2</span>, <span class="ident">T2</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">other</span>: <span class="kw-2">&amp;mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O2</span>, <span class="ident">T2</span><span class="op">&gt;</span>)
	<span class="kw">where</span>
		<span class="ident">O2</span>: <span class="ident">BitOrder</span>,
		<span class="ident">T2</span>: <span class="ident">BitStore</span>,
	{
		<span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">len</span>();
		<span class="macro">assert_eq!</span>(<span class="ident">len</span>, <span class="ident">other</span>.<span class="ident">len</span>());
		<span class="kw">for</span> (<span class="ident">a</span>, <span class="ident">b</span>) <span class="kw">in</span> <span class="self">self</span>.<span class="ident">as_mut_bitptr_range</span>().<span class="ident">zip</span>(<span class="ident">other</span>.<span class="ident">as_mut_bitptr_range</span>())
		{
			<span class="kw">unsafe</span> {
				<span class="ident">a</span>.<span class="ident">swap</span>(<span class="ident">b</span>);
			}
		}
	}

	<span class="doccomment">/// Shifts the contents of a bit-slice left (towards index `0`).</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This moves the contents of the slice from `by ..` down to</span>
	<span class="doccomment">/// `0 .. len - by`, and erases `len - by ..` to `0`. As this is a</span>
	<span class="doccomment">/// destructive (and linearly expensive) operation, you may prefer instead</span>
	<span class="doccomment">/// to use range subslicing.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;mut self`</span>
	<span class="doccomment">/// - `by`: The distance by which to shift the slice contents.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Panics</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This panics if `by` is not less than `self.len()`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits = bits![mut 1; 6];</span>
	<span class="doccomment">/// bits.shift_left(2);</span>
	<span class="doccomment">/// assert_eq!(bits, bits![1, 1, 1, 1, 0, 0]);</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">shift_left</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">by</span>: <span class="ident">usize</span>) {
		<span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">len</span>();
		<span class="kw">if</span> <span class="ident">by</span> <span class="op">==</span> <span class="number">0</span> {
			<span class="kw">return</span>;
		}
		<span class="macro">assert!</span>(
			<span class="ident">by</span> <span class="op">&lt;</span> <span class="ident">len</span>,
			<span class="string">&quot;Cannot shift a slice by more than its length: {} exceeds {}&quot;</span>,
			<span class="ident">by</span>,
			<span class="ident">len</span>
		);

		<span class="kw">unsafe</span> {
			<span class="self">self</span>.<span class="ident">copy_within_unchecked</span>(<span class="ident">by</span> .., <span class="number">0</span>);
			<span class="kw">let</span> <span class="ident">trunc</span> <span class="op">=</span> <span class="ident">len</span> <span class="op">-</span> <span class="ident">by</span>;
			<span class="self">self</span>.<span class="ident">get_unchecked_mut</span>(<span class="ident">trunc</span> ..).<span class="ident">set_all</span>(<span class="bool-val">false</span>);
		}
	}

	<span class="doccomment">/// Shifts the contents of a bit-slice right (towards index `self.len()`).</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This moves the contents of the slice from `.. len - by` up to `by ..`,</span>
	<span class="doccomment">/// and erases `.. by` to `0`. As this is a destructive (and linearly</span>
	<span class="doccomment">/// expensive) operation, you may prefer instead to use range subslicing.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;mut self`</span>
	<span class="doccomment">/// - `by`: The distance by which to shift the slice contents.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Panics</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This panics if `by` is not less than `self.len()`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits = bits![mut 1; 6];</span>
	<span class="doccomment">/// bits.shift_right(2);</span>
	<span class="doccomment">/// assert_eq!(bits, bits![0, 0, 1, 1, 1, 1]);</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">shift_right</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">by</span>: <span class="ident">usize</span>) {
		<span class="kw">let</span> <span class="ident">len</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">len</span>();
		<span class="kw">if</span> <span class="ident">by</span> <span class="op">==</span> <span class="number">0</span> {
			<span class="kw">return</span>;
		}
		<span class="macro">assert!</span>(
			<span class="ident">by</span> <span class="op">&lt;</span> <span class="ident">len</span>,
			<span class="string">&quot;Cannot shift a slice by more than its length: {} exceeds {}&quot;</span>,
			<span class="ident">by</span>,
			<span class="ident">len</span>
		);

		<span class="kw">let</span> <span class="ident">trunc</span> <span class="op">=</span> <span class="ident">len</span> <span class="op">-</span> <span class="ident">by</span>;
		<span class="kw">unsafe</span> {
			<span class="self">self</span>.<span class="ident">copy_within_unchecked</span>(.. <span class="ident">trunc</span>, <span class="ident">by</span>);
			<span class="self">self</span>.<span class="ident">get_unchecked_mut</span>(.. <span class="ident">by</span>).<span class="ident">set_all</span>(<span class="bool-val">false</span>);
		}
	}

	<span class="doccomment">/// Sets all bits in the slice to a value.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;mut self`</span>
	<span class="doccomment">/// - `value`: The bit value to which all bits in the slice will be set.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let mut src = 0u8;</span>
	<span class="doccomment">/// let bits = src.view_bits_mut::&lt;Msb0&gt;();</span>
	<span class="doccomment">/// bits[2 .. 6].set_all(true);</span>
	<span class="doccomment">/// assert_eq!(bits.as_raw_slice(), &amp;[0b0011_1100]);</span>
	<span class="doccomment">/// bits[3 .. 5].set_all(false);</span>
	<span class="doccomment">/// assert_eq!(bits.as_raw_slice(), &amp;[0b0010_0100]);</span>
	<span class="doccomment">/// bits[.. 1].set_all(true);</span>
	<span class="doccomment">/// assert_eq!(bits.as_raw_slice(), &amp;[0b1010_0100]);</span>
	<span class="doccomment">/// ```</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_all</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">value</span>: <span class="ident">bool</span>) {
		<span class="comment">//  Grab the function pointers used to commit bit-masks into memory.</span>
		<span class="kw">let</span> <span class="ident">setter</span> <span class="op">=</span> <span class="op">&lt;</span><span class="ident">T::Access</span><span class="op">&gt;</span><span class="ident">::get_writers</span>(<span class="ident">value</span>);
		<span class="kw">match</span> <span class="self">self</span>.<span class="ident">domain_mut</span>() {
			<span class="ident">DomainMut::Enclave</span> { <span class="ident">head</span>, <span class="ident">elem</span>, <span class="ident">tail</span> } =&gt; {
				<span class="ident">setter</span>(<span class="ident">elem</span>, <span class="ident">O::mask</span>(<span class="ident">head</span>, <span class="ident">tail</span>));
			},
			<span class="ident">DomainMut::Region</span> { <span class="ident">head</span>, <span class="ident">body</span>, <span class="ident">tail</span> } =&gt; {
				<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">head</span>, <span class="ident">elem</span>)) <span class="op">=</span> <span class="ident">head</span> {
					<span class="ident">setter</span>(<span class="ident">elem</span>, <span class="ident">O::mask</span>(<span class="ident">head</span>, <span class="prelude-val">None</span>));
				}
				<span class="comment">//  loop assignment is `memset`’s problem, not ours</span>
				<span class="kw">unsafe</span> {
					<span class="ident">ptr::write_bytes</span>(
						<span class="ident">body</span>.<span class="ident">as_mut_ptr</span>(),
						[<span class="number">0</span>, <span class="op">!</span><span class="number">0</span>][<span class="ident">value</span> <span class="kw">as</span> <span class="ident">usize</span>],
						<span class="ident">body</span>.<span class="ident">len</span>(),
					);
				}
				<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="ident">elem</span>, <span class="ident">tail</span>)) <span class="op">=</span> <span class="ident">tail</span> {
					<span class="ident">setter</span>(<span class="ident">elem</span>, <span class="ident">O::mask</span>(<span class="prelude-val">None</span>, <span class="ident">tail</span>));
				}
			},
		}
	}

	<span class="doccomment">/// Applies a function to each bit in the slice.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// `BitSlice` cannot implement [`IndexMut`], as it cannot manifest `&amp;mut</span>
	<span class="doccomment">/// bool` references, and the [`BitRef`] proxy reference has an unavoidable</span>
	<span class="doccomment">/// overhead. This method bypasses both problems, by applying a function to</span>
	<span class="doccomment">/// each pair of index and value in the slice, without constructing a proxy</span>
	<span class="doccomment">/// reference. Benchmarks indicate that this method is about 2–4 times</span>
	<span class="doccomment">/// faster than the `.iter_mut().enumerate()` equivalent.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;mut self`</span>
	<span class="doccomment">/// - `func`: A function which receives two arguments, `index: usize` and</span>
	<span class="doccomment">///   `value: bool`, and returns a `bool`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// For each index in the slice, the result of invoking `func` with the</span>
	<span class="doccomment">/// index number and current bit value is written into the slice.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let mut data = 0u8;</span>
	<span class="doccomment">/// let bits = data.view_bits_mut::&lt;Msb0&gt;();</span>
	<span class="doccomment">/// bits.for_each(|idx, _bit| idx % 3 == 0);</span>
	<span class="doccomment">/// assert_eq!(data, 0b100_100_10);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitRef`]: crate::ptr::BitRef</span>
	<span class="doccomment">/// [`IndexMut`]: core::ops::IndexMut</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">for_each</span><span class="op">&lt;</span><span class="ident">F</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="kw-2">mut</span> <span class="ident">func</span>: <span class="ident">F</span>)
	<span class="kw">where</span> <span class="ident">F</span>: <span class="ident">FnMut</span>(<span class="ident">usize</span>, <span class="ident">bool</span>) -&gt; <span class="ident">bool</span> {
		<span class="kw">for</span> (<span class="ident">idx</span>, <span class="ident">ptr</span>) <span class="kw">in</span> <span class="self">self</span>.<span class="ident">as_mut_bitptr_range</span>().<span class="ident">enumerate</span>() {
			<span class="kw">unsafe</span> {
				<span class="ident">ptr</span>.<span class="ident">write</span>(<span class="ident">func</span>(<span class="ident">idx</span>, <span class="ident">ptr</span>.<span class="ident">read</span>()));
			}
		}
	}

	<span class="doccomment">/// Produces the absolute offset in bits between two slice heads.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// While this method is sound for any two arbitrary bit slices, the answer</span>
	<span class="doccomment">/// it produces is meaningful *only* when one argument is a strict subslice</span>
	<span class="doccomment">/// of the other. If the two slices are created from different buffers</span>
	<span class="doccomment">/// entirely, a comparison is undefined; if the two slices are disjoint</span>
	<span class="doccomment">/// regions of the same buffer, then the semantically correct distance is</span>
	<span class="doccomment">/// between the tail of the lower and the head of the upper, which this</span>
	<span class="doccomment">/// does not measure.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Visual Description</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Consider the following sequence of bits:</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```text</span>
	<span class="doccomment">/// [ 0 1 2 3 4 5 6 7 8 9 a b ]</span>
	<span class="doccomment">///   |       ^^^^^^^       |</span>
	<span class="doccomment">///   ^^^^^^^^^^^^^^^^^^^^^^^</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// It does not matter whether there are bits between the tail of the</span>
	<span class="doccomment">/// smaller and the larger slices. The offset is computed from the bit</span>
	<span class="doccomment">/// distance between the two heads.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Behavior</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function computes the *semantic* distance between the heads, rather</span>
	<span class="doccomment">/// than the *electrical. It does not take into account the `BitOrder`</span>
	<span class="doccomment">/// implementation of the slice.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety and Soundness</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// One of `self` or `other` must contain the other for this comparison to</span>
	<span class="doccomment">/// be meaningful.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">/// - `other`: Another bit slice. This must be either a strict subregion or</span>
	<span class="doccomment">///   a strict superregion of `self`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The distance in (semantic) bits between the heads of each region. The</span>
	<span class="doccomment">/// value is positive when `other` is higher in the address space than</span>
	<span class="doccomment">/// `self`, and negative when `other` is lower in the address space than</span>
	<span class="doccomment">/// `self`.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">offset_from</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">other</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>) -&gt; <span class="ident">isize</span> {
		<span class="kw">unsafe</span> { <span class="ident">other</span>.<span class="ident">as_bitptr</span>().<span class="ident">offset_from</span>(<span class="self">self</span>.<span class="ident">as_bitptr</span>()) }
	}

	<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">never</span>)]</span>
	<span class="attribute">#[<span class="ident">deprecated</span> <span class="op">=</span> <span class="string">&quot;Use `BitPtr::offset_from`&quot;</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">electrical_distance</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">_other</span>: <span class="kw-2">&amp;</span><span class="self">Self</span>) -&gt; <span class="ident">isize</span> {
		<span class="macro">unimplemented!</span>(
			<span class="string">&quot;This no longer exists! Offsets are only defined between two \
			 bit-pointers in the same bit-region, and `bitvec` considers two \
			 regions with different orderings, *even if they cover the same \
			 locations*, to be different. Use `BitPtr::offset_from`.&quot;</span>
		);
	}
}

<span class="doccomment">/// Unchecked variants of checked accessors.</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
	<span class="ident">O</span>: <span class="ident">BitOrder</span>,
	<span class="ident">T</span>: <span class="ident">BitStore</span>,
{
	<span class="doccomment">/// Writes a new bit at a given index, without doing bounds checking.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This is generally not recommended; use with caution! Calling this method</span>
	<span class="doccomment">/// with an out-of-bounds index is *[undefined behavior]*. For a safe</span>
	<span class="doccomment">/// alternative, see [`.set()`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;mut self`</span>
	<span class="doccomment">/// - `index`: The bit index at which to write. It must be in the range `0</span>
	<span class="doccomment">///   .. self.len()`.</span>
	<span class="doccomment">/// - `value`: The value to be written; `true` for `1` or `false` for `0`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The bit at `index` is set to `value`. If `index` is out of bounds, then</span>
	<span class="doccomment">/// the memory access is incorrect, and its behavior is unspecified.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This method is **not** safe. It performs raw pointer arithmetic to seek</span>
	<span class="doccomment">/// from the start of the slice to the requested index, and set the bit</span>
	<span class="doccomment">/// there. It does not inspect the length of `self`, and it is free to</span>
	<span class="doccomment">/// perform out-of-bounds memory *write* access.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Use this method **only** when you have already performed the bounds</span>
	<span class="doccomment">/// check, and can guarantee that the call occurs with a safely in-bounds</span>
	<span class="doccomment">/// index.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This example uses a bit slice of length 2, and demonstrates</span>
	<span class="doccomment">/// out-of-bounds access to the last bit in the element.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits = bits![mut 0; 2];</span>
	<span class="doccomment">/// let (first, _) = bits.split_at_mut(1);</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// unsafe {</span>
	<span class="doccomment">///   first.set_unchecked(1, true);</span>
	<span class="doccomment">/// }</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// assert_eq!(bits, bits![0, 1]);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`self.len()`]: Self::len</span>
	<span class="doccomment">/// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html</span>
	<span class="doccomment">/// [`.set()`]: Self::set</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">set_unchecked</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">index</span>: <span class="ident">usize</span>, <span class="ident">value</span>: <span class="ident">bool</span>) {
		<span class="self">self</span>.<span class="ident">as_mut_bitptr</span>().<span class="ident">add</span>(<span class="ident">index</span>).<span class="ident">write</span>(<span class="ident">value</span>);
	}

	<span class="doccomment">/// Swaps two bits in the slice.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// See [`.swap()`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// `a` and `b` must both be less than [`self.len()`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`self.len()`]: Self::len</span>
	<span class="doccomment">/// [`.swap()`]: Self::swap</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">swap_unchecked</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">a</span>: <span class="ident">usize</span>, <span class="ident">b</span>: <span class="ident">usize</span>) {
		<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">as_mut_bitptr</span>().<span class="ident">add</span>(<span class="ident">a</span>);
		<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">as_mut_bitptr</span>().<span class="ident">add</span>(<span class="ident">b</span>);
		<span class="ident">a</span>.<span class="ident">swap</span>(<span class="ident">b</span>);
	}

	<span class="doccomment">/// Divides one slice into two at an index, without performing any bounds</span>
	<span class="doccomment">/// checking.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// See [`.split_at()`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// `mid` must not be greater than [`self.len()`]. If this condition is</span>
	<span class="doccomment">/// violated, the function behavior is *unspecified*.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits = bits![0, 0, 0, 1, 1, 1];</span>
	<span class="doccomment">/// let (l, r) = unsafe { bits.split_at_unchecked(3) };</span>
	<span class="doccomment">/// assert!(l.not_any());</span>
	<span class="doccomment">/// assert!(r.all());</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let (l, r) = unsafe { bits.split_at_unchecked(6) };</span>
	<span class="doccomment">/// assert_eq!(l, bits);</span>
	<span class="doccomment">/// assert!(r.is_empty());</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`self.len()`]: Self::len</span>
	<span class="doccomment">/// [`.split_at()`]: Self::split_at</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">split_at_unchecked</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">mid</span>: <span class="ident">usize</span>) -&gt; (<span class="kw-2">&amp;</span><span class="self">Self</span>, <span class="kw-2">&amp;</span><span class="self">Self</span>) {
		(<span class="self">self</span>.<span class="ident">get_unchecked</span>(.. <span class="ident">mid</span>), <span class="self">self</span>.<span class="ident">get_unchecked</span>(<span class="ident">mid</span> ..))
	}

	<span class="doccomment">/// Divides one mutable slice into two at an index.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// See [`.split_at_mut()`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// `mid` must not be greater than [`self.len()`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`self.len()`]: Self::len</span>
	<span class="doccomment">/// [`.split_at_mut()`]: Self::split_at_mut</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="attribute">#[<span class="ident">allow</span>(<span class="ident">clippy::type_complexity</span>)]</span>
	<span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">split_at_unchecked_mut</span>(
		<span class="kw-2">&amp;mut</span> <span class="self">self</span>,
		<span class="ident">mid</span>: <span class="ident">usize</span>,
	) -&gt; (<span class="kw-2">&amp;mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T::Alias</span><span class="op">&gt;</span>, <span class="kw-2">&amp;mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T::Alias</span><span class="op">&gt;</span>) {
		<span class="kw">let</span> <span class="ident">bp</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">alias_mut</span>().<span class="ident">as_mut_bitspan</span>();
		(
			<span class="ident">bp</span>.<span class="ident">to_bitslice_mut</span>().<span class="ident">get_unchecked_mut</span>(.. <span class="ident">mid</span>),
			<span class="ident">bp</span>.<span class="ident">to_bitslice_mut</span>().<span class="ident">get_unchecked_mut</span>(<span class="ident">mid</span> ..),
		)
	}

	<span class="doccomment">/// Copies bits from one part of the slice to another part of itself,</span>
	<span class="doccomment">/// without doing bounds checks.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The ranges are allowed to overlap.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;mut self`</span>
	<span class="doccomment">/// - `src`: The range within `self` from which to copy.</span>
	<span class="doccomment">/// - `dst`: The starting index within `self` at which to paste.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// `self[src]` is copied to `self[dest .. dest + src.end() - src.start()]`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// `src` and `dest .. dest + src.len()` must be entirely within</span>
	<span class="doccomment">/// [`self.len()`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`self.len()`]: Self::len</span>
	<span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">copy_within_unchecked</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">src</span>: <span class="ident">R</span>, <span class="ident">dest</span>: <span class="ident">usize</span>)
	<span class="kw">where</span> <span class="ident">R</span>: <span class="ident">RangeBounds</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> {
		<span class="kw">if</span> <span class="ident">dvl::match_order</span>::<span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">Lsb0</span><span class="op">&gt;</span>() {
			<span class="kw">let</span> <span class="ident">this</span>: <span class="kw-2">&amp;mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Lsb0</span>, <span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="kw-2">*</span>(<span class="self">self</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="kw">_</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="kw">_</span>);
			<span class="ident">this</span>.<span class="ident">sp_copy_within_unchecked</span>(<span class="ident">src</span>, <span class="ident">dest</span>);
		}
		<span class="kw">else</span> <span class="kw">if</span> <span class="ident">dvl::match_order</span>::<span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">Msb0</span><span class="op">&gt;</span>() {
			<span class="kw">let</span> <span class="ident">this</span>: <span class="kw-2">&amp;mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="ident">T</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="kw-2">*</span>(<span class="self">self</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="kw">_</span> <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="kw">_</span>);
			<span class="ident">this</span>.<span class="ident">sp_copy_within_unchecked</span>(<span class="ident">src</span>, <span class="ident">dest</span>);
		}
		<span class="kw">else</span> {
			<span class="kw">let</span> <span class="ident">source</span> <span class="op">=</span> <span class="ident">dvl::normalize_range</span>(<span class="ident">src</span>, <span class="self">self</span>.<span class="ident">len</span>());
			<span class="kw">let</span> <span class="ident">source_len</span> <span class="op">=</span> <span class="ident">source</span>.<span class="ident">len</span>();
			<span class="kw">let</span> <span class="ident">rev</span> <span class="op">=</span> <span class="ident">source</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="ident">dest</span>);
			<span class="kw">let</span> <span class="ident">iter</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">get_unchecked</span>(<span class="ident">source</span>).<span class="ident">as_bitptr_range</span>().<span class="ident">zip</span>(
				<span class="self">self</span>.<span class="ident">get_unchecked_mut</span>(<span class="ident">dest</span> .. <span class="ident">dest</span> <span class="op">+</span> <span class="ident">source_len</span>)
					.<span class="ident">as_mut_bitptr_range</span>(),
			);
			<span class="kw">if</span> <span class="ident">rev</span> {
				<span class="kw">for</span> (<span class="ident">from</span>, <span class="ident">to</span>) <span class="kw">in</span> <span class="ident">iter</span>.<span class="ident">rev</span>() {
					<span class="ident">to</span>.<span class="ident">write</span>(<span class="ident">from</span>.<span class="ident">read</span>());
				}
			}
			<span class="kw">else</span> {
				<span class="kw">for</span> (<span class="ident">from</span>, <span class="ident">to</span>) <span class="kw">in</span> <span class="ident">iter</span> {
					<span class="ident">to</span>.<span class="ident">write</span>(<span class="ident">from</span>.<span class="ident">read</span>());
				}
			}
		}
	}
}

<span class="doccomment">/// View conversions.</span>
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
	<span class="ident">O</span>: <span class="ident">BitOrder</span>,
	<span class="ident">T</span>: <span class="ident">BitStore</span>,
{
	<span class="doccomment">/// Returns a raw bit-pointer to the base of the bit-slice’s region.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The caller must ensure that the bit-slice outlives the bit-pointer this</span>
	<span class="doccomment">/// function returns, or else it will end up pointing to garbage.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The caller must also ensure that the memory the bit-pointer</span>
	<span class="doccomment">/// (non-transitively) points to is never written to using this bit-pointer</span>
	<span class="doccomment">/// or any bit-pointer derived from it. If you need to mutate the contents</span>
	<span class="doccomment">/// of the slice, use [`.as_mut_bitptr()`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Modifying the container referenced by this bit-slice may cause its</span>
	<span class="doccomment">/// buffer to be reällocated, which would also make any bit-pointers to it</span>
	<span class="doccomment">/// invalid.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Original</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`slice::as_ptr`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_ptr)</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # API Differences</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This returns a structure, [`BitPtr`], rather than an actual raw pointer</span>
	<span class="doccomment">/// `*Bit`. The information required to address a bit within a memory</span>
	<span class="doccomment">/// element cannot be encoded into a single pointer.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This structure can be converted back into a `&amp;BitSlice` with the</span>
	<span class="doccomment">/// function [`from_raw_parts`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let x = bits![0, 0, 1];</span>
	<span class="doccomment">/// let x_ptr = x.as_ptr();</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// unsafe {</span>
	<span class="doccomment">///   for i in 0 .. x.len() {</span>
	<span class="doccomment">///     assert_eq!(*x.get_unchecked(i), (&amp;*x)[i]);</span>
	<span class="doccomment">///   }</span>
	<span class="doccomment">/// }</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`.as_mut_bitptr()`]: Self::as_mut_bitptr</span>
	<span class="doccomment">/// [`from_raw_parts`]: crate::slice::from_raw_parts</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">as_bitptr</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">BitPtr</span><span class="op">&lt;</span><span class="ident">Const</span>, <span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> {
		<span class="self">self</span>.<span class="ident">as_bitspan</span>().<span class="ident">as_bitptr</span>()
	}

	<span class="doccomment">/// Returns an unsafe mutable bit-pointer to the bit-slice’s region.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The caller must ensure that the bit-slice outlives the bit-pointer this</span>
	<span class="doccomment">/// function returns, or else it will end up pointing to garbage.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Modifying the container referenced by this bit-slice may cause its</span>
	<span class="doccomment">/// buffer to be reällocated, which would also make any bit-pointers to it</span>
	<span class="doccomment">/// invalid.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Original</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`slice::as_mut_ptr`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_mut_ptr)</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # API Differences</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This returns `*mut BitSlice`, which is the equivalent of `*mut [T]`</span>
	<span class="doccomment">/// instead of `*mut T`. The pointer encoding used requires more than one</span>
	<span class="doccomment">/// CPU word of space to address a single bit, so there is no advantage to</span>
	<span class="doccomment">/// removing the length information from the encoded pointer value.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits = bits![mut Lsb0, u8; 0; 8];</span>
	<span class="doccomment">/// let bits_ptr = bits.as_mut_ptr();</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// for i in 0 .. bits.len() {</span>
	<span class="doccomment">///   unsafe {</span>
	<span class="doccomment">///     bits_ptr.add(i).write(i % 3 == 0);</span>
	<span class="doccomment">///   }</span>
	<span class="doccomment">/// }</span>
	<span class="doccomment">/// assert_eq!(bits.as_raw_slice()[0], 0b0100_1001);</span>
	<span class="doccomment">/// ```</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">as_mut_bitptr</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) -&gt; <span class="ident">BitPtr</span><span class="op">&lt;</span><span class="ident">Mut</span>, <span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> {
		<span class="self">self</span>.<span class="ident">as_mut_bitspan</span>().<span class="ident">as_bitptr</span>()
	}

	<span class="doccomment">/// Returns the two raw bit-pointers spanning the bit-slice.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The returned range is half-open, which means that the end bit-pointer</span>
	<span class="doccomment">/// points *one past* the last bit of the bit-slice. This way, an empty</span>
	<span class="doccomment">/// bit-slice is represented by two equal bit-pointers, and the difference</span>
	<span class="doccomment">/// between the two bit-pointers represents the size of the bit-slice.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// See [`as_bitptr`] for warnings on using these bit-pointers. The end</span>
	<span class="doccomment">/// bit-pointer requires extra caution, as it does not point to a valid bit</span>
	<span class="doccomment">/// in the bit-slice.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function allows a more direct access to bit-pointers, without</span>
	<span class="doccomment">/// paying the cost of encoding into a `*BitSlice`, at the cost of no longer</span>
	<span class="doccomment">/// fitting into ordinary Rust interfaces.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Original</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`slice::as_ptr_range`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_ptr_range)</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # API Differences</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This returns a dedicated structure, rather than a range of [`BitPtr`]s,</span>
	<span class="doccomment">/// because the traits needed for non-`core` types to correctly operate in</span>
	<span class="doccomment">/// ranges are still unstable. The structure can be converted into a range,</span>
	<span class="doccomment">/// but that range will not be an iterator.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits = bits![0, 1, 0, 0, 1];</span>
	<span class="doccomment">/// let mid_ptr = bits.get(2).unwrap().into_bitptr();</span>
	<span class="doccomment">/// let mut range = bits.as_bitptr_range();</span>
	<span class="doccomment">/// assert!(range.contains(&amp;mid_ptr));</span>
	<span class="doccomment">/// unsafe {</span>
	<span class="doccomment">///   assert!(!range.next().unwrap().read());</span>
	<span class="doccomment">///   assert!(range.next_back().unwrap().read())</span>
	<span class="doccomment">/// }</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitPtr`]: crate::ptr::BitPtr</span>
	<span class="doccomment">/// [`as_bitptr`]: Self::as_bitptr</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">as_bitptr_range</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">BitPtrRange</span><span class="op">&lt;</span><span class="ident">Const</span>, <span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> {
		<span class="self">self</span>.<span class="ident">as_bitspan</span>().<span class="ident">as_bitptr_range</span>()
	}

	<span class="doccomment">/// Returns the two unsafe mutable bit-pointers spanning the bit-slice.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The returned range is half-open, which means that the end bit-pointer</span>
	<span class="doccomment">/// points *one past* the last bitt of the bit-slice. This way, an empty</span>
	<span class="doccomment">/// bit-slice is represented by two equal bit-pointers, and the difference</span>
	<span class="doccomment">/// between the two bit-pointers represents the size of the bit-slice.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// See [`as_mut_bitptr`] for warnings on using these bit-pointers. The end</span>
	<span class="doccomment">/// bit-pointer requires extra caution, as it does not point to a valid bit</span>
	<span class="doccomment">/// in the bit-slice.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Original</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`slice::as_mut_ptr_range`](https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_mut_ptr_range)</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # API Differences</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This returns a dedicated structure, rather than a range of [`BitPtr`]s,</span>
	<span class="doccomment">/// because the traits needed for non-`core` types to correctly operate in</span>
	<span class="doccomment">/// ranges are still unstable. The structure can be converted into a range,</span>
	<span class="doccomment">/// but that range will not be an iterator.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">/// use bitvec::ptr as bv_ptr;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let mut data = 0u8;</span>
	<span class="doccomment">/// let bits = data.view_bits_mut::&lt;Msb0&gt;();</span>
	<span class="doccomment">/// for mut bitptr in bits.as_mut_bitptr_range() {</span>
	<span class="doccomment">///   unsafe { bv_ptr::write(bitptr, true); }</span>
	<span class="doccomment">/// }</span>
	<span class="doccomment">/// assert_eq!(data, !0);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitPtr`]: crate::ptr::BitPtr</span>
	<span class="doccomment">/// [`as_mut_bitptr`]: Self::as_mut_bitptr</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">as_mut_bitptr_range</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) -&gt; <span class="ident">BitPtrRange</span><span class="op">&lt;</span><span class="ident">Mut</span>, <span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> {
		<span class="self">self</span>.<span class="ident">as_mut_bitspan</span>().<span class="ident">as_bitptr_range</span>()
	}

	<span class="doccomment">/// Splits the slice into subslices at alias boundaries.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This splits `self` into the memory locations that it partially fills and</span>
	<span class="doccomment">/// the memory locations that it completely fills. The locations that are</span>
	<span class="doccomment">/// completely filled may be accessed without any `bitvec`-imposed alias</span>
	<span class="doccomment">/// conditions, while the locations that are only partially filled are left</span>
	<span class="doccomment">/// unchanged.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// You can read more about the [`BitDomain`] splitting in its</span>
	<span class="doccomment">/// documentation.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let mut data = [0u16; 3];</span>
	<span class="doccomment">/// let all = data.view_bits_mut::&lt;Msb0&gt;();</span>
	<span class="doccomment">/// let (_, rest) = all.split_at_mut(8);</span>
	<span class="doccomment">/// let bits: &amp;BitSlice&lt;Msb0, &lt;u16 as BitStore&gt;::Alias&gt; = &amp;rest[.. 32];</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let (head, body, tail) = bits</span>
	<span class="doccomment">///   .bit_domain()</span>
	<span class="doccomment">///   .region()</span>
	<span class="doccomment">///   .unwrap();</span>
	<span class="doccomment">/// assert_eq!(head.len(), 8);</span>
	<span class="doccomment">/// assert_eq!(tail.len(), 8);</span>
	<span class="doccomment">/// let _: &amp;BitSlice&lt;Msb0, &lt;u16 as BitStore&gt;::Alias&gt; = head;</span>
	<span class="doccomment">/// let _: &amp;BitSlice&lt;Msb0, &lt;u16 as BitStore&gt;::Alias&gt; = tail;</span>
	<span class="doccomment">/// let _: &amp;BitSlice&lt;Msb0, u16&gt; = body;</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitDomain`]: crate::domain::BitDomain</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bit_domain</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">BitDomain</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> {
		<span class="ident">BitDomain::new</span>(<span class="self">self</span>)
	}

	<span class="doccomment">/// Splits the slice into subslices at alias boundaries.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This splits `self` into the memory locations that it partially fills and</span>
	<span class="doccomment">/// the memory locations that it completely fills. The locations that are</span>
	<span class="doccomment">/// completely filled may be accessed without any `bitvec`-imposed alias</span>
	<span class="doccomment">/// conditions, while the locations that are only partially filled are left</span>
	<span class="doccomment">/// unchanged.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// You can read more about the [`BitDomainMut`] splitting in its</span>
	<span class="doccomment">/// documentation.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let mut data = [0u16; 3];</span>
	<span class="doccomment">/// let all = data.view_bits_mut::&lt;Msb0&gt;();</span>
	<span class="doccomment">/// let (_, rest) = all.split_at_mut(8);</span>
	<span class="doccomment">/// let bits: &amp;mut BitSlice&lt;Msb0, &lt;u16 as BitStore&gt;::Alias&gt;</span>
	<span class="doccomment">///   = &amp;mut rest[.. 32];</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let (head, body, tail) = bits</span>
	<span class="doccomment">///   .bit_domain_mut()</span>
	<span class="doccomment">///   .region()</span>
	<span class="doccomment">///   .unwrap();</span>
	<span class="doccomment">/// assert_eq!(head.len(), 8);</span>
	<span class="doccomment">/// assert_eq!(tail.len(), 8);</span>
	<span class="doccomment">/// let _: &amp;mut BitSlice&lt;Msb0, &lt;u16 as BitStore&gt;::Alias&gt; = head;</span>
	<span class="doccomment">/// let _: &amp;mut BitSlice&lt;Msb0, &lt;u16 as BitStore&gt;::Alias&gt; = tail;</span>
	<span class="doccomment">/// let _: &amp;mut BitSlice&lt;Msb0, u16&gt; = body;</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitDomainMut`]: crate::domain::BitDomainMut</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">bit_domain_mut</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) -&gt; <span class="ident">BitDomainMut</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> {
		<span class="ident">BitDomainMut::new</span>(<span class="self">self</span>)
	}

	<span class="doccomment">/// Views the underlying memory containing the slice, split at alias</span>
	<span class="doccomment">/// boundaries.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This splits `self` into the memory locations that it partially fills and</span>
	<span class="doccomment">/// the memory locations that it completely fills. The locations that are</span>
	<span class="doccomment">/// completely filled may be accessed without any `bitvec`-imposed alias</span>
	<span class="doccomment">/// conditions, while the locations that are only partially filled are left</span>
	<span class="doccomment">/// unchanged.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// You can read more about the [`Domain`] splitting in its documentation.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let mut data = [0u16; 3];</span>
	<span class="doccomment">/// let all = data.view_bits_mut::&lt;Msb0&gt;();</span>
	<span class="doccomment">/// let (_, rest) = all.split_at_mut(8);</span>
	<span class="doccomment">/// let bits: &amp;BitSlice&lt;Msb0, &lt;u16 as BitStore&gt;::Alias&gt; = &amp;rest[.. 32];</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let (head, body, tail) = bits</span>
	<span class="doccomment">///   .domain()</span>
	<span class="doccomment">///   .region()</span>
	<span class="doccomment">///   .unwrap();</span>
	<span class="doccomment">/// assert_eq!(body.len(), 1);</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let _: &amp;&lt;u16 as BitStore&gt;::Alias = head.unwrap().1;</span>
	<span class="doccomment">/// let _: &amp;&lt;u16 as BitStore&gt;::Alias = tail.unwrap().0;</span>
	<span class="doccomment">/// let _: &amp;[u16] = body;</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`Domain`]: crate::domain::Domain</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">domain</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">Domain</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
		<span class="ident">Domain::new</span>(<span class="self">self</span>)
	}

	<span class="doccomment">/// Views the underlying memory containing the slice, split at alias</span>
	<span class="doccomment">/// boundaries.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This splits `self` into the memory locations that it partially fills and</span>
	<span class="doccomment">/// the memory locations that it completely fills. The locations that are</span>
	<span class="doccomment">/// completely filled may be accessed without any `bitvec`-imposed alias</span>
	<span class="doccomment">/// conditions, while the locations that are only partially filled are left</span>
	<span class="doccomment">/// unchanged.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// You can read more about the [`DomainMut`] splitting in its</span>
	<span class="doccomment">/// documentation.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let mut data = [0u16; 3];</span>
	<span class="doccomment">/// let all = data.view_bits_mut::&lt;Msb0&gt;();</span>
	<span class="doccomment">/// let (_, rest) = all.split_at_mut(8);</span>
	<span class="doccomment">/// let bits: &amp;mut BitSlice&lt;Msb0, &lt;u16 as BitStore&gt;::Alias&gt; = &amp;mut rest[.. 32];</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let (head, body, tail) = bits</span>
	<span class="doccomment">///   .domain_mut()</span>
	<span class="doccomment">///   .region()</span>
	<span class="doccomment">///   .unwrap();</span>
	<span class="doccomment">/// assert_eq!(body.len(), 1);</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let _: &amp;&lt;&lt;u16 as BitStore&gt;::Alias as BitStore&gt;::Access = head.unwrap().1;</span>
	<span class="doccomment">/// let _: &amp;&lt;&lt;u16 as BitStore&gt;::Alias as BitStore&gt;::Access = tail.unwrap().0;</span>
	<span class="doccomment">/// let _: &amp;mut [u16] = body;</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`DomainMut`]: crate::domain::DomainMut</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">domain_mut</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) -&gt; <span class="ident">DomainMut</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> {
		<span class="ident">DomainMut::new</span>(<span class="self">self</span>)
	}

	<span class="doccomment">/// Views the underlying memory containing the slice.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The returned slice handle views all elements touched by `self`, and</span>
	<span class="doccomment">/// marks them all with `self`’s current aliasing state. For a more precise</span>
	<span class="doccomment">/// view, or one that permits mutation, use [`.domain()`] or</span>
	<span class="doccomment">/// [`.domain_mut()`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`.domain()`]: Self::domain</span>
	<span class="doccomment">/// [`.domain_mut()`]: Self::domain_mut</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">as_raw_slice</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span>[<span class="ident">T</span>] {
		<span class="kw">let</span> <span class="ident">bitspan</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">as_bitspan</span>();
		<span class="kw">let</span> (<span class="ident">base</span>, <span class="ident">elts</span>) <span class="op">=</span> (<span class="ident">bitspan</span>.<span class="ident">address</span>().<span class="ident">to_const</span>(), <span class="ident">bitspan</span>.<span class="ident">elements</span>());
		<span class="kw">unsafe</span> { <span class="ident">slice::from_raw_parts</span>(<span class="ident">base</span>, <span class="ident">elts</span>) }
	}
}

<span class="doccomment">/// Crate-internal functions.</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
	<span class="ident">O</span>: <span class="ident">BitOrder</span>,
	<span class="ident">T</span>: <span class="ident">BitStore</span>,
{
	<span class="doccomment">/// Type-cast the slice reference to its pointer structure.</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">as_bitspan</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">BitSpan</span><span class="op">&lt;</span><span class="ident">Const</span>, <span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> {
		<span class="ident">BitSpan::from_bitslice_ptr</span>(<span class="self">self</span>)
	}

	<span class="doccomment">/// Type-cast the slice reference to its pointer structure.</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">as_mut_bitspan</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) -&gt; <span class="ident">BitSpan</span><span class="op">&lt;</span><span class="ident">Mut</span>, <span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> {
		<span class="ident">BitSpan::from_bitslice_ptr_mut</span>(<span class="self">self</span>)
	}

	<span class="doccomment">/// Asserts that `index` is not out of `bounds`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">/// - `index`: The index to test against [`self.len()`].</span>
	<span class="doccomment">/// - `bounds`: Bounds to check.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Panics</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This method panics if `bounds` doesn&#39;t contain the `index`.</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">assert_in_bounds</span><span class="op">&lt;</span><span class="ident">R</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">index</span>: <span class="ident">usize</span>, <span class="ident">bounds</span>: <span class="ident">R</span>)
	<span class="kw">where</span> <span class="ident">R</span>: <span class="ident">RangeBounds</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> {
		<span class="macro">assert!</span>(
			<span class="ident">bounds</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="ident">index</span>),
			<span class="string">&quot;Index {} out of range: {:?}&quot;</span>,
			<span class="ident">index</span>,
			<span class="ident">bounds</span>.<span class="ident">end_bound</span>()
		);
	}

	<span class="doccomment">/// Marks an immutable slice as referring to aliased memory region.</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">alias</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="kw-2">&amp;</span><span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T::Alias</span><span class="op">&gt;</span> {
		<span class="self">self</span>.<span class="ident">as_bitspan</span>().<span class="ident">cast</span>::<span class="op">&lt;</span><span class="ident">T::Alias</span><span class="op">&gt;</span>().<span class="ident">to_bitslice_ref</span>()
	}

	<span class="doccomment">/// Marks a mutable slice as describing an aliased memory region.</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">alias_mut</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>) -&gt; <span class="kw-2">&amp;mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T::Alias</span><span class="op">&gt;</span> {
		<span class="self">self</span>.<span class="ident">as_mut_bitspan</span>().<span class="ident">cast</span>::<span class="op">&lt;</span><span class="ident">T::Alias</span><span class="op">&gt;</span>().<span class="ident">to_bitslice_mut</span>()
	}

	<span class="doccomment">/// Removes the aliasing marker from a mutable slice handle.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This must only be used when the slice is either known to be unaliased,</span>
	<span class="doccomment">/// or this call is combined with an operation that adds an aliasing marker</span>
	<span class="doccomment">/// and the total number of aliasing markers must remain unchanged.</span>
	<span class="attribute">#[<span class="ident">inline</span>(<span class="ident">always</span>)]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">tarpaulin_include</span>))]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">unalias_mut</span>(
		<span class="ident">this</span>: <span class="kw-2">&amp;mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T::Alias</span><span class="op">&gt;</span>,
	) -&gt; <span class="kw-2">&amp;mut</span> <span class="self">Self</span> {
		<span class="ident">this</span>.<span class="ident">as_mut_bitspan</span>().<span class="ident">cast</span>::<span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>().<span class="ident">to_bitslice_mut</span>()
	}

	<span class="doccomment">/// Splits a mutable slice at some mid-point, without checking boundary</span>
	<span class="doccomment">/// conditions or adding an alias marker.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This method has the same behavior as [`.split_at_unchecked_mut()`],</span>
	<span class="doccomment">/// except that it does not apply an aliasing marker to the partitioned</span>
	<span class="doccomment">/// subslices.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// See [`.split_at_unchecked_mut()`] for safety requirements.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Additionally, this is only safe when `T` is alias-safe.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`.split_at_unchecked_mut()`]: Self::split_at_unchecked_mut</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">split_at_unchecked_mut_noalias</span>(
		<span class="kw-2">&amp;mut</span> <span class="self">self</span>,
		<span class="ident">mid</span>: <span class="ident">usize</span>,
	) -&gt; (<span class="kw-2">&amp;mut</span> <span class="self">Self</span>, <span class="kw-2">&amp;mut</span> <span class="self">Self</span>) {
		<span class="comment">//  Split the slice at the requested midpoint, adding an alias layer</span>
		<span class="kw">let</span> (<span class="ident">head</span>, <span class="ident">tail</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">split_at_unchecked_mut</span>(<span class="ident">mid</span>);
		<span class="comment">//  Remove the new alias layer.</span>
		(<span class="ident"><span class="self">Self</span>::unalias_mut</span>(<span class="ident">head</span>), <span class="ident"><span class="self">Self</span>::unalias_mut</span>(<span class="ident">tail</span>))
	}
}

<span class="doccomment">/// Methods available only when `T` allows shared mutability.</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
	<span class="ident">O</span>: <span class="ident">BitOrder</span>,
	<span class="ident">T</span>: <span class="ident">BitStore</span> <span class="op">+</span> <span class="ident">Radium</span>,
{
	<span class="doccomment">/// Writes a new bit at a given index.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This method supports writing through a shared reference to a bit that</span>
	<span class="doccomment">/// may be observed by other `BitSlice` handles. It is only present when the</span>
	<span class="doccomment">/// `T` type parameter supports such shared mutation (measured by the</span>
	<span class="doccomment">/// [`Radium`] trait).</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">/// - `index`: The bit index at which to write. It must be in the range `0</span>
	<span class="doccomment">///   .. self.len()`.</span>
	<span class="doccomment">/// - `value`: The value to be written; `true` for `1` or `false` for `0`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// If `index` is valid, then the bit to which it refers is set to `value`.</span>
	<span class="doccomment">/// If `T` is an [atomic], this will lock the memory bus for the referent</span>
	<span class="doccomment">/// address, and may cause stalls.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Panics</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This method panics if `index` is not less than [`self.len()`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">/// use core::cell::Cell;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let byte = Cell::new(0u8);</span>
	<span class="doccomment">/// let bits = byte.view_bits::&lt;Msb0&gt;();</span>
	<span class="doccomment">/// let bits_2 = bits;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// bits.set_aliased(1, true);</span>
	<span class="doccomment">/// assert!(bits_2[1]);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This example panics when it attempts to set a bit that is out of bounds.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust,should_panic</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">/// use core::cell::Cell;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let byte = Cell::new(0u8);</span>
	<span class="doccomment">/// let bits = byte.view_bits::&lt;Lsb0&gt;();</span>
	<span class="doccomment">/// bits.set_aliased(8, false);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [atomic]: core::sync::atomic</span>
	<span class="doccomment">/// [`Radium`]: radium::Radium</span>
	<span class="doccomment">/// [`self.len()`]: Self::len</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">set_aliased</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">index</span>: <span class="ident">usize</span>, <span class="ident">value</span>: <span class="ident">bool</span>) {
		<span class="self">self</span>.<span class="ident">assert_in_bounds</span>(<span class="ident">index</span>, <span class="number">0</span> .. <span class="self">self</span>.<span class="ident">len</span>());
		<span class="kw">unsafe</span> {
			<span class="self">self</span>.<span class="ident">set_aliased_unchecked</span>(<span class="ident">index</span>, <span class="ident">value</span>);
		}
	}

	<span class="doccomment">/// Writes a new bit at a given index, without doing bounds checking.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This method supports writing through a shared reference to a bit that</span>
	<span class="doccomment">/// may be observed by other `BitSlice` handles. It is only present when the</span>
	<span class="doccomment">/// `T` type parameter supports such shared mutation (measured by the</span>
	<span class="doccomment">/// [`Radium`] trait).</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The bit at `index` is set to `value`. If `index` is out of bounds, then</span>
	<span class="doccomment">/// the memory access is incorrect, and its behavior is unspecified. If `T`</span>
	<span class="doccomment">/// is an [atomic], this will lock the memory bus for the referent</span>
	<span class="doccomment">/// address, and may cause stalls.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This method is **not** safe. It performs raw pointer arithmetic to seek</span>
	<span class="doccomment">/// from the start of the slice to the requested index, and set the bit</span>
	<span class="doccomment">/// there. It does not inspect the length of `self`, and it is free to</span>
	<span class="doccomment">/// perform out-of-bounds memory *write* access.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Use this method **only** when you have already performed the bounds</span>
	<span class="doccomment">/// check, and can guarantee that the call occurs with a safely in-bounds</span>
	<span class="doccomment">/// index.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">/// use core::cell::Cell;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let byte = Cell::new(0u8);</span>
	<span class="doccomment">/// let bits = byte.view_bits::&lt;Msb0&gt;();</span>
	<span class="doccomment">/// let bits_2 = bits;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let (first, _) = bits.split_at(1);</span>
	<span class="doccomment">/// assert_eq!(first.len(), 1);</span>
	<span class="doccomment">/// unsafe { first.set_aliased_unchecked(2, true); }</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// assert!(bits_2[2]);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [atomic]: core::sync::atomic</span>
	<span class="doccomment">/// [`Radium`]: radium::Radium</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">set_aliased_unchecked</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">index</span>: <span class="ident">usize</span>, <span class="ident">value</span>: <span class="ident">bool</span>) {
		<span class="self">self</span>.<span class="ident">as_bitptr</span>().<span class="ident">add</span>(<span class="ident">index</span>).<span class="ident">freeze</span>().<span class="ident">frozen_write_bit</span>(<span class="ident">value</span>);
	}

	<span class="doccomment">/// Splits a mutable slice at some mid-point.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This method has the same behavior as [`.split_at_mut()`], except that it</span>
	<span class="doccomment">/// does not apply an aliasing marker to the partitioned subslices.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Because this method is defined only on `BitSlice`s whose `T` type is</span>
	<span class="doccomment">/// alias-safe, the subslices do not need to be additionally marked.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`.split_at_mut()`]: Self::split_at_mut</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">split_at_aliased_mut</span>(
		<span class="kw-2">&amp;mut</span> <span class="self">self</span>,
		<span class="ident">mid</span>: <span class="ident">usize</span>,
	) -&gt; (<span class="kw-2">&amp;mut</span> <span class="self">Self</span>, <span class="kw-2">&amp;mut</span> <span class="self">Self</span>) {
		<span class="kw">let</span> (<span class="ident">head</span>, <span class="ident">tail</span>) <span class="op">=</span> <span class="self">self</span>.<span class="ident">split_at_mut</span>(<span class="ident">mid</span>);
		<span class="kw">unsafe</span> { (<span class="ident"><span class="self">Self</span>::unalias_mut</span>(<span class="ident">head</span>), <span class="ident"><span class="self">Self</span>::unalias_mut</span>(<span class="ident">tail</span>)) }
	}
}

<span class="doccomment">/// Miscellaneous information.</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
	<span class="ident">O</span>: <span class="ident">BitOrder</span>,
	<span class="ident">T</span>: <span class="ident">BitStore</span>,
{
	<span class="doccomment">/// The inclusive maximum length of a `BitSlice&lt;_, T&gt;`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// As `BitSlice` is zero-indexed, the largest possible index is one less</span>
	<span class="doccomment">/// than this value.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// |CPU word width|         Value         |</span>
	<span class="doccomment">/// |-------------:|----------------------:|</span>
	<span class="doccomment">/// |32 bits       |     `0x1fff_ffff`     |</span>
	<span class="doccomment">/// |64 bits       |`0x1fff_ffff_ffff_ffff`|</span>
	<span class="kw">pub</span> <span class="kw">const</span> <span class="ident">MAX_BITS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">BitSpan</span>::<span class="op">&lt;</span><span class="ident">Const</span>, <span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span><span class="ident">::REGION_MAX_BITS</span>;
	<span class="doccomment">/// The inclusive maximum length that a slice `[T]` can be for</span>
	<span class="doccomment">/// `BitSlice&lt;_, T&gt;` to cover it.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// A `BitSlice&lt;_, T&gt;` that begins in the interior of an element and</span>
	<span class="doccomment">/// contains the maximum number of bits will extend one element past the</span>
	<span class="doccomment">/// cutoff that would occur if the slice began at the zeroth bit. Such a</span>
	<span class="doccomment">/// slice must be manually constructed, but will not otherwise fail.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// |Type Bits|Max Elements (32-bit)| Max Elements (64-bit) |</span>
	<span class="doccomment">/// |--------:|--------------------:|----------------------:|</span>
	<span class="doccomment">/// |        8|    `0x0400_0001`    |`0x0400_0000_0000_0001`|</span>
	<span class="doccomment">/// |       16|    `0x0200_0001`    |`0x0200_0000_0000_0001`|</span>
	<span class="doccomment">/// |       32|    `0x0100_0001`    |`0x0100_0000_0000_0001`|</span>
	<span class="doccomment">/// |       64|    `0x0080_0001`    |`0x0080_0000_0000_0001`|</span>
	<span class="kw">pub</span> <span class="kw">const</span> <span class="ident">MAX_ELTS</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="ident">BitSpan</span>::<span class="op">&lt;</span><span class="ident">Const</span>, <span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span><span class="ident">::REGION_MAX_ELTS</span>;
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;alloc&quot;</span>)]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
	<span class="ident">O</span>: <span class="ident">BitOrder</span>,
	<span class="ident">T</span>: <span class="ident">BitStore</span>,
{
	<span class="doccomment">/// Copies `self` into a new [`BitVec`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This resets any alias markings from `self`, since the returned buffer is</span>
	<span class="doccomment">/// known to be newly allocated and thus unaliased.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Examples</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// ```rust</span>
	<span class="doccomment">/// use bitvec::prelude::*;</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// let bits = bits![0, 1, 0, 1];</span>
	<span class="doccomment">/// let bv = bits.to_bitvec();</span>
	<span class="doccomment">/// assert_eq!(bits, bv);</span>
	<span class="doccomment">/// ```</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitVec`]: crate::vec::BitVec</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">to_bitvec</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident">BitVec</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T::Unalias</span><span class="op">&gt;</span> {
		<span class="kw">let</span> <span class="ident">bitspan</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">as_bitspan</span>();
		<span class="comment">//  Create an allocation and copy `*self` into it.</span>
		<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="self">self</span>.<span class="ident">domain</span>().<span class="ident">collect</span>::<span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="kw">_</span><span class="op">&gt;</span><span class="op">&gt;</span>().<span class="ident">pipe</span>(<span class="ident">ManuallyDrop::new</span>);
		<span class="kw">let</span> <span class="ident">capacity</span> <span class="op">=</span> <span class="ident">vec</span>.<span class="ident">capacity</span>();
		<span class="kw">unsafe</span> {
			<span class="ident">BitVec::from_fields</span>(
				<span class="ident">BitSpan::new_unchecked</span>(
					<span class="ident">vec</span>.<span class="ident">as_mut_ptr</span>().<span class="ident">cast</span>::<span class="op">&lt;</span><span class="ident">T::Unalias</span><span class="op">&gt;</span>().<span class="ident">force_wrap</span>(),
					<span class="ident">bitspan</span>.<span class="ident">head</span>(),
					<span class="ident">bitspan</span>.<span class="ident">len</span>(),
				),
				<span class="ident">capacity</span>,
			)
		}
	}
}

<span class="doccomment">/** Performs the same functionality as [`from_raw_parts`], without checking the
`len` argument.

# Parameters

- `data`: A `BitPtr` to a dereferencable region of memory.
- `len`: The length, in bits, of the region beginning at `*data`. This is not
  checked against the maximum value, and is encoded directly into the bit-slice
  reference. If it exceeds [`BitSlice::MAX_BITS`], it will be modulated to fit
  (the high bits will be discarded).

# Returns

A `&amp;BitSlice` reference starting at `data` and running for `len &amp; MAX_BITS`
bits.

# Safety

See [`from_raw_parts`].

[`BitSlice::MAX_BITS`]: crate::slice::BitSlice::MAX_BITS
[`from_raw_parts`]: crate::slice::from_raw_parts
**/</span>
<span class="attribute">#[<span class="ident">inline</span>]</span>
<span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">from_raw_parts_unchecked</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>(
	<span class="ident">data</span>: <span class="ident">BitPtr</span><span class="op">&lt;</span><span class="ident">Const</span>, <span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>,
	<span class="ident">len</span>: <span class="ident">usize</span>,
) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
	<span class="ident">O</span>: <span class="ident">BitOrder</span>,
	<span class="ident">T</span>: <span class="ident">BitStore</span>,
{
	<span class="ident">data</span>.<span class="ident">span_unchecked</span>(<span class="ident">len</span>).<span class="ident">to_bitslice_ref</span>()
}

<span class="doccomment">/** Performs the same functionality as [`from_raw_parts_mut`], without checking
the `len` argument.

# Parameters

- `data`: A `BitPtr` to a dereferencable region of memory.
- `len`: The length, in bits, of the region beginning at `*data`. This is not
  checked against the maximum value, and is encoded directly into the bit-slice
  reference. If it exceeds [`BitSlice::MAX_BITS`], it will be modulated to fit
  (the high bits will be discarded).

# Returns

A `&amp;mut BitSlice` reference starting at `data` and running for `len &amp; MAX_BITS`
bits.

# Safety

See [`from_raw_parts_mut`].

[`BitSlice::MAX_BITS`]: crate::slice::BitSlice::MAX_BITS
[`from_raw_parts_mut`]: crate::slice::from_raw_parts_mut
**/</span>
<span class="attribute">#[<span class="ident">inline</span>]</span>
<span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">from_raw_parts_unchecked_mut</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>(
	<span class="ident">data</span>: <span class="ident">BitPtr</span><span class="op">&lt;</span><span class="ident">Mut</span>, <span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>,
	<span class="ident">len</span>: <span class="ident">usize</span>,
) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="kw-2">mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span>
	<span class="ident">O</span>: <span class="ident">BitOrder</span>,
	<span class="ident">T</span>: <span class="ident">BitStore</span>,
{
	<span class="ident">data</span>.<span class="ident">span_unchecked</span>(<span class="ident">len</span>).<span class="ident">to_bitslice_mut</span>()
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
<span class="kw">mod</span> <span class="ident">tests</span>;
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="bitvec" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>