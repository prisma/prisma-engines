<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.22.3/src/access.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>access.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../bitvec/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
</pre><pre class="rust"><code><span class="doccomment">/*! Memory access guards.

[`bitvec`] allows a program to produce handles over memory that do not logically
alias their bits, but may alias in hardware. This module provides a unified
interface for memory accesses that can be specialized to handle aliased and
unaliased access events.

The [`BitAccess`] trait provides capabilities to access bits in memory elements
through shared references, and its implementations are responsible for
coördinating synchronization and contention as needed.

The [`BitSafe`] trait abstracts over wrappers to the [`Cell`] and [atomic] types
that forbid writing through their references, even when other references to the
same location may write.

[`BitAccess`]: crate::access::BitAccess
[`BitSafe`]: crate::access::BitSafe
[`Cell`]: core::cell::Cell
[`bitvec`]: crate
!*/</span>

<span class="kw">use</span> <span class="ident">core::sync::atomic</span>;

<span class="kw">use</span> <span class="ident">funty::IsInteger</span>;
<span class="kw">use</span> <span class="ident">radium::Radium</span>;

<span class="kw">use</span> <span class="kw">crate</span>::{
	<span class="ident">index</span>::{
		<span class="ident">BitIdx</span>,
		<span class="ident">BitMask</span>,
	},
	<span class="ident">mem::BitRegister</span>,
	<span class="ident">order::BitOrder</span>,
};

<span class="doccomment">/** Abstracts over the instructions used when accessing a memory location.

This trait provides functions to manipulate bits in a referent memory register
through the appropriate access instructions, so that use sites elsewhere in the
crate can select their required behavior without changing their interface.

This is automatically implemented for all types that permit shared/mutable
memory access to memory registers through the [`radium`] crate. Its use is
constrained in the [`store`] module.

This trait is only ever used by [`bitvec`] internals, and is never exposed
outside the crate. It must be marked as public so that it can be used as an
associated item in [`BitStore`], even though it is never made accessible.

[`BitStore`]: crate::store::BitStore
[`bitvec`]: crate
[`radium`]: radium
[`store`]: crate::store
**/</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">BitAccess</span>: <span class="ident">Radium</span>
<span class="kw">where</span> <span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">Radium</span><span class="op">&gt;</span><span class="ident">::Item</span>: <span class="ident">BitRegister</span>
{
	<span class="doccomment">/// Clears any number of bits in a memory register to `0`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The mask provided to this method must be constructed from indices that</span>
	<span class="doccomment">/// are valid in the caller’s context. As the mask is already computed by</span>
	<span class="doccomment">/// the caller, this does not take an ordering type parameter.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">/// - `mask`: A mask of any number of bits. This is a selection mask: all</span>
	<span class="doccomment">///   bits in the mask that are set to `1` will be modified in the element</span>
	<span class="doccomment">///   at `*self`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// All bits in `*self` that are selected (set to `1` in the `mask`) will be</span>
	<span class="doccomment">/// cleared. All bits in `*self` that are not selected (cleared to `0` in</span>
	<span class="doccomment">/// the `mask`) are unchanged.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Do not invert the `mask` prior to calling this function in order to save</span>
	<span class="doccomment">/// the unselected bits and clear the selected bits. [`BitMask`] is a</span>
	<span class="doccomment">/// selection type, not a bitwise-operation argument.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitMask`]: crate::index::BitMask</span>
	<span class="kw">fn</span> <span class="ident">clear_bits</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">mask</span>: <span class="ident">BitMask</span><span class="op">&lt;</span><span class="ident"><span class="self">Self</span>::Item</span><span class="op">&gt;</span>) {
		<span class="self">self</span>.<span class="ident">fetch_and</span>(<span class="op">!</span><span class="ident">mask</span>.<span class="ident">into_inner</span>(), <span class="ident">atomic::Ordering::Relaxed</span>);
	}

	<span class="doccomment">/// Sets any number of bits in a memory register to `1`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The mask provided to this method must be constructed from indices that</span>
	<span class="doccomment">/// are valid in the caller’s context. As the mask is already computed by</span>
	<span class="doccomment">/// the caller, this does not take an ordering type parameter.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">/// - `mask`: A mask of any number of bits. This is a selection mask: all</span>
	<span class="doccomment">///   bits in the mask that are set to `1` will be modified in the element</span>
	<span class="doccomment">///   at `*self`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// All bits in `*self` that are selected (set to `1` in the `mask`) will be</span>
	<span class="doccomment">/// cleared. All bits in `*self` that are not selected (cleared to `0` in</span>
	<span class="doccomment">/// the `mask`) are unchanged.</span>
	<span class="kw">fn</span> <span class="ident">set_bits</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">mask</span>: <span class="ident">BitMask</span><span class="op">&lt;</span><span class="ident"><span class="self">Self</span>::Item</span><span class="op">&gt;</span>) {
		<span class="self">self</span>.<span class="ident">fetch_or</span>(<span class="ident">mask</span>.<span class="ident">into_inner</span>(), <span class="ident">atomic::Ordering::Relaxed</span>);
	}

	<span class="doccomment">/// Inverts any number of bits in a memory register.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The mask provided to this method must be constructed from indices that</span>
	<span class="doccomment">/// are valid in the caller’s context. As the mask is already computed by</span>
	<span class="doccomment">/// the caller, this does not take an ordering type parameter.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">/// - `mask`: A mask of any number of bits. This is a selection mask: all</span>
	<span class="doccomment">///   bits in the mask that are set to `1` will be modified in the element</span>
	<span class="doccomment">///   at `*self`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// All bits in `*self` that are selected (set to `1` in the `mask`) will be</span>
	<span class="doccomment">/// inverted. All bits in `*self` that are not selected (cleared to `0` in</span>
	<span class="doccomment">/// the `mask`) are unchanged.</span>
	<span class="kw">fn</span> <span class="ident">invert_bits</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">mask</span>: <span class="ident">BitMask</span><span class="op">&lt;</span><span class="ident"><span class="self">Self</span>::Item</span><span class="op">&gt;</span>) {
		<span class="self">self</span>.<span class="ident">fetch_xor</span>(<span class="ident">mask</span>.<span class="ident">into_inner</span>(), <span class="ident">atomic::Ordering::Relaxed</span>);
	}

	<span class="doccomment">/// Writes a value to one bit in a memory register.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Type Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `O`: A bit ordering.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `&amp;self`</span>
	<span class="doccomment">/// - `index`: The semantic index of the bit in `*self` to write.</span>
	<span class="doccomment">/// - `value`: The bit value to write into `*self` at `index`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The bit previously stored in `*self` at `index`. As these operations are</span>
	<span class="doccomment">/// required to load the `*self` value from memory in order to work, the</span>
	<span class="doccomment">/// previous value can be retained to reduce spurious loads elsewhere in the</span>
	<span class="doccomment">/// crate.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Effects</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The memory register at address `self` has the bit corresponding to the</span>
	<span class="doccomment">/// `index` cursor under the `O` order written with the new `value`, and all</span>
	<span class="doccomment">/// other bits are unchanged.</span>
	<span class="kw">fn</span> <span class="ident">write_bit</span><span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">index</span>: <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident"><span class="self">Self</span>::Item</span><span class="op">&gt;</span>, <span class="ident">value</span>: <span class="ident">bool</span>) -&gt; <span class="ident">bool</span>
	<span class="kw">where</span> <span class="ident">O</span>: <span class="ident">BitOrder</span> {
		<span class="kw">let</span> <span class="ident">select</span> <span class="op">=</span> <span class="ident">index</span>.<span class="ident">select</span>::<span class="op">&lt;</span><span class="ident">O</span><span class="op">&gt;</span>().<span class="ident">into_inner</span>();
		<span class="ident">select</span>
			<span class="op">&amp;</span> <span class="kw">if</span> <span class="ident">value</span> {
				<span class="self">self</span>.<span class="ident">fetch_or</span>(<span class="ident">select</span>, <span class="ident">atomic::Ordering::Relaxed</span>)
			}
			<span class="kw">else</span> {
				<span class="self">self</span>.<span class="ident">fetch_and</span>(<span class="op">!</span><span class="ident">select</span>, <span class="ident">atomic::Ordering::Relaxed</span>)
			} <span class="op">!</span><span class="op">=</span> <span class="op">&lt;</span><span class="ident"><span class="self">Self</span>::Item</span><span class="op">&gt;</span><span class="ident">::ZERO</span>
	}

	<span class="doccomment">/// Gets the function that writes `value` into all bits under a mask.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `value`: The bit that will be directly written by the returned</span>
	<span class="doccomment">///   function.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// A function which, when applied to a reference and a mask, will write</span>
	<span class="doccomment">/// `value` into memory. If `value` is `false`, then this produces</span>
	<span class="doccomment">/// [`clear_bits`]; if it is `true`, then this produces [`set_bits`].</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`clear_bits`]: Self::clear_bits</span>
	<span class="doccomment">/// [`set_bits`]: Self::set_bits</span>
	<span class="kw">fn</span> <span class="ident">get_writers</span>(<span class="ident">value</span>: <span class="ident">bool</span>) -&gt; <span class="kw">for</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">fn</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="self">Self</span>, <span class="ident">BitMask</span><span class="op">&lt;</span><span class="ident"><span class="self">Self</span>::Item</span><span class="op">&gt;</span>) {
		<span class="kw">if</span> <span class="ident">value</span> {
			<span class="ident"><span class="self">Self</span>::set_bits</span>
		}
		<span class="kw">else</span> {
			<span class="ident"><span class="self">Self</span>::clear_bits</span>
		}
	}
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">A</span><span class="op">&gt;</span> <span class="ident">BitAccess</span> <span class="kw">for</span> <span class="ident">A</span>
<span class="kw">where</span>
	<span class="ident">A</span>: <span class="ident">Radium</span>,
	<span class="ident">A::Item</span>: <span class="ident">BitRegister</span>,
{
}

<span class="doccomment">/** Restricts memory modification to only exclusive references.

The shared-mutability types do not permit locking their references to prevent
writing through them when inappropriate. Implementors of this trait are able to
view aliased memory and handle other references writing to it, even though they
themselves may be forbidden from doing so.
**/</span>
<span class="kw">pub</span> <span class="kw">trait</span> <span class="ident">BitSafe</span> {
	<span class="doccomment">/// The register type being guarded against shared mutation.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This is only present as an extra proof that the type graph all uses the</span>
	<span class="doccomment">/// same underlying integers.</span>
	<span class="kw">type</span> <span class="ident">Mem</span>: <span class="ident">BitRegister</span>;

	<span class="doccomment">/// The accessor type being prevented from mutating while shared.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This is exposed as an associated type so that `BitStore` can name it</span>
	<span class="doccomment">/// without having to re-select it based on crate configuration.</span>
	<span class="kw">type</span> <span class="ident">Rad</span>: <span class="ident">Radium</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident"><span class="self">Self</span>::Mem</span><span class="op">&gt;</span>;

	<span class="doccomment">/// Reads the value out of memory only if a shared reference to the location</span>
	<span class="doccomment">/// can be produced.</span>
	<span class="kw">fn</span> <span class="ident">load</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="ident"><span class="self">Self</span>::Mem</span>;

	<span class="doccomment">/// Writes a value into memory only if an exclusive reference to the</span>
	<span class="doccomment">/// location can be produced.</span>
	<span class="kw">fn</span> <span class="ident">store</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">value</span>: <span class="ident"><span class="self">Self</span>::Mem</span>);
}

<span class="macro">macro_rules!</span> <span class="ident">safe</span> {
	($(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">t</span>:<span class="ident">ident</span> =&gt; <span class="macro-nonterminal">$</span><span class="macro-nonterminal">w</span>:<span class="ident">ident</span> =&gt; <span class="macro-nonterminal">$</span><span class="macro-nonterminal">r</span>:<span class="ident">path</span>),<span class="op">+</span> $(,)<span class="question-mark">?</span>) =&gt; { $(
		<span class="doccomment">/// A wrapper over a shared-mutable type that forbids writing to the</span>
		<span class="doccomment">/// location through its own reference. Other references to the location</span>
		<span class="doccomment">/// may still write to it, and reads from this reference will be aware</span>
		<span class="doccomment">/// of this possibility.</span>
		<span class="doccomment">///</span>
		<span class="doccomment">/// This is necessary in order to enforce [`bitvec`]’s memory model,</span>
		<span class="doccomment">/// which disallows shared mutation to individual bits. [`BitSlice`]s</span>
		<span class="doccomment">/// may produce memory views that use this type in order to ensure that</span>
		<span class="doccomment">/// handles that lack write permission to an area may not write to it,</span>
		<span class="doccomment">/// even if other handles may.</span>
		<span class="doccomment">///</span>
		<span class="doccomment">/// Under the `&quot;atomic&quot;` feature, this uses [`radium`]’s best-effort</span>
		<span class="doccomment">/// atomic alias; when this feature is disabled, then it uses a [`Cell`]</span>
		<span class="doccomment">/// directly.</span>
		<span class="doccomment">///</span>
		<span class="doccomment">/// [`BitSlice`]: crate::slice::BitSlice</span>
		<span class="doccomment">/// [`Cell`]: core::cell::Cell</span>
		<span class="doccomment">/// [`radium`]: radium::types</span>
		<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
		<span class="attribute">#[<span class="ident">repr</span>(<span class="ident">transparent</span>)]</span>
		<span class="kw">pub</span> <span class="kw">struct</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">w</span> {
			<span class="ident">inner</span>: <span class="op">&lt;</span><span class="self">Self</span> <span class="kw">as</span> <span class="ident">BitSafe</span><span class="op">&gt;</span><span class="ident">::Rad</span>,
		}

		<span class="kw">impl</span> <span class="ident">BitSafe</span> <span class="kw">for</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">w</span> {
			<span class="kw">type</span> <span class="ident">Mem</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">t</span>;

			<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;atomic&quot;</span>)]</span>
			<span class="kw">type</span> <span class="ident">Rad</span> <span class="op">=</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">r</span>;

			<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;atomic&quot;</span>))]</span>
			<span class="kw">type</span> <span class="ident">Rad</span> <span class="op">=</span> <span class="ident">core::cell::Cell</span><span class="op">&lt;</span><span class="macro-nonterminal">$</span><span class="macro-nonterminal">t</span><span class="op">&gt;</span>;

			<span class="kw">fn</span> <span class="ident">load</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; <span class="macro-nonterminal">$</span><span class="macro-nonterminal">t</span> {
				<span class="ident">radium::Radium::load</span>(
					<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">inner</span>,
					<span class="ident">core::sync::atomic::Ordering::Relaxed</span>,
				)
			}

			<span class="kw">fn</span> <span class="ident">store</span>(<span class="kw-2">&amp;mut</span> <span class="self">self</span>, <span class="ident">value</span>: <span class="macro-nonterminal">$</span><span class="macro-nonterminal">t</span>) {
				<span class="ident">radium::Radium::store</span>(
					<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">inner</span>,
					<span class="ident">value</span>,
					<span class="ident">core::sync::atomic::Ordering::Relaxed</span>,
				)
			}
		}
	)<span class="op">+</span> };
}

<span class="macro">safe!</span> {
	<span class="ident">u8</span> =&gt; <span class="ident">BitSafeU8</span> =&gt; <span class="ident">radium::types::RadiumU8</span>,
	<span class="ident">u16</span> =&gt; <span class="ident">BitSafeU16</span> =&gt; <span class="ident">radium::types::RadiumU16</span>,
	<span class="ident">u32</span> =&gt; <span class="ident">BitSafeU32</span> =&gt; <span class="ident">radium::types::RadiumU32</span>,
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_pointer_width</span> <span class="op">=</span> <span class="string">&quot;64&quot;</span>)]</span>
<span class="macro">safe!</span>(<span class="ident">u64</span> =&gt; <span class="ident">BitSafeU64</span> =&gt; <span class="ident">radium::types::RadiumU64</span>);

<span class="macro">safe!</span>(<span class="ident">usize</span> =&gt; <span class="ident">BitSafeUsize</span> =&gt; <span class="ident">radium::types::RadiumUsize</span>);

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
<span class="kw">mod</span> <span class="ident">tests</span> {
	<span class="kw">use</span> <span class="kw">super</span>::<span class="kw-2">*</span>;
	<span class="kw">use</span> <span class="ident"><span class="kw">crate</span>::prelude</span>::<span class="kw-2">*</span>;

	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="kw">fn</span> <span class="ident">touch_memory</span>() {
		<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
		<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span><span class="op">&gt;</span>();
		<span class="kw">let</span> <span class="ident">accessor</span> <span class="op">=</span> <span class="kw">unsafe</span> {
			<span class="kw-2">&amp;</span><span class="kw-2">*</span>(<span class="ident">bits</span>
				.<span class="ident">as_bitspan</span>()
				.<span class="ident">address</span>()
				.<span class="ident">cast</span>::<span class="op">&lt;</span><span class="op">&lt;</span><span class="ident">u8</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span><span class="ident">::Access</span><span class="op">&gt;</span>())
			.<span class="ident">to_const</span>()
		};
		<span class="kw">let</span> <span class="ident">aliased</span> <span class="op">=</span> <span class="kw">unsafe</span> {
			<span class="kw-2">&amp;</span><span class="kw-2">*</span>(<span class="ident">bits</span>.<span class="ident">as_bitspan</span>().<span class="ident">address</span>().<span class="ident">to_const</span>()
				<span class="kw">as</span> <span class="kw-2">*const</span> <span class="op">&lt;</span><span class="ident">u8</span> <span class="kw">as</span> <span class="ident">BitStore</span><span class="op">&gt;</span><span class="ident">::Alias</span>)
		};

		<span class="ident">BitAccess::set_bits</span>(<span class="ident">accessor</span>, <span class="ident">BitMask::ALL</span>);
		<span class="macro">assert_eq!</span>(<span class="ident">accessor</span>.<span class="ident">get</span>(), <span class="op">!</span><span class="number">0</span>);

		<span class="ident">BitAccess::clear_bits</span>(<span class="ident">accessor</span>, <span class="ident">BitMask::ALL</span>);
		<span class="macro">assert_eq!</span>(<span class="ident">accessor</span>.<span class="ident">get</span>(), <span class="number">0</span>);

		<span class="ident">BitAccess::invert_bits</span>(<span class="ident">accessor</span>, <span class="ident">BitMask::ALL</span>);
		<span class="macro">assert_eq!</span>(<span class="ident">accessor</span>.<span class="ident">get</span>(), <span class="op">!</span><span class="number">0</span>);

		<span class="macro">assert!</span>(<span class="ident">BitStore::get_bit</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>(<span class="ident">aliased</span>, <span class="ident">BitIdx::ZERO</span>));
		<span class="macro">assert_eq!</span>(<span class="ident">accessor</span>.<span class="ident">get</span>(), <span class="op">!</span><span class="number">0</span>);

		<span class="ident">BitAccess::write_bit</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>(<span class="ident">accessor</span>, <span class="ident">BitIdx::new</span>(<span class="number">1</span>).<span class="ident">unwrap</span>(), <span class="bool-val">false</span>);
		<span class="macro">assert_eq!</span>(<span class="ident">accessor</span>.<span class="ident">get</span>(), <span class="op">!</span><span class="number">2</span>);
	}

	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">not</span>(<span class="ident">miri</span>))]</span>
	<span class="kw">fn</span> <span class="ident">sanity_check_prefetch</span>() {
		<span class="kw">use</span> <span class="ident">core::cell::Cell</span>;
		<span class="macro">assert_eq!</span>(
			<span class="op">&lt;</span><span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">BitAccess</span><span class="op">&gt;</span><span class="ident">::get_writers</span>(<span class="bool-val">false</span>) <span class="kw">as</span> <span class="kw-2">*const</span> (),
			<span class="op">&lt;</span><span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">BitAccess</span><span class="op">&gt;</span><span class="ident">::clear_bits</span> <span class="kw">as</span> <span class="kw-2">*const</span> ()
		);

		<span class="macro">assert_eq!</span>(
			<span class="op">&lt;</span><span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">BitAccess</span><span class="op">&gt;</span><span class="ident">::get_writers</span>(<span class="bool-val">true</span>) <span class="kw">as</span> <span class="kw-2">*const</span> (),
			<span class="op">&lt;</span><span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="kw">as</span> <span class="ident">BitAccess</span><span class="op">&gt;</span><span class="ident">::set_bits</span> <span class="kw">as</span> <span class="kw-2">*const</span> ()
		);
	}

	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="kw">fn</span> <span class="ident">safe_wrappers</span>() {
		<span class="kw">use</span> <span class="ident"><span class="kw">super</span>::BitSafe</span>;

		<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="ident">Msb0</span>, <span class="ident">u8</span>; <span class="number">0</span>; <span class="number">24</span>];
		<span class="kw">let</span> (<span class="ident">l</span>, <span class="ident">c</span>): (<span class="kw-2">&amp;mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="ident">BitSafeU8</span><span class="op">&gt;</span>, <span class="kw">_</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at_mut</span>(<span class="number">4</span>);
		<span class="kw">let</span> (<span class="ident">c</span>, <span class="kw">_</span>): (<span class="kw-2">&amp;mut</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">Msb0</span>, <span class="ident">BitSafeU8</span><span class="op">&gt;</span>, <span class="kw">_</span>) <span class="op">=</span> <span class="ident">c</span>.<span class="ident">split_at_mut</span>(<span class="number">16</span>);

		<span class="comment">//  Get a write-capable shared reference to the base address,</span>
		<span class="kw">let</span> <span class="ident">l_redge</span>: <span class="kw-2">&amp;</span><span class="op">&lt;</span><span class="ident">BitSafeU8</span> <span class="kw">as</span> <span class="ident">BitSafe</span><span class="op">&gt;</span><span class="ident">::Rad</span> <span class="op">=</span>
			<span class="ident">l</span>.<span class="ident">domain_mut</span>().<span class="ident">region</span>().<span class="ident">unwrap</span>().<span class="number">2</span>.<span class="ident">unwrap</span>().<span class="number">0</span>;
		<span class="comment">//  and a write-incapable shared reference to the same base address.</span>
		<span class="kw">let</span> <span class="ident">c_ledge</span>: <span class="kw-2">&amp;</span><span class="ident">BitSafeU8</span> <span class="op">=</span> <span class="ident">c</span>.<span class="ident">domain</span>().<span class="ident">region</span>().<span class="ident">unwrap</span>().<span class="number">0</span>.<span class="ident">unwrap</span>().<span class="number">1</span>;

		<span class="comment">//  The split location means that the two subdomains share a location.</span>
		<span class="macro">assert_eq!</span>(
			<span class="ident">l_redge</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="ident">u8</span>,
			<span class="ident">c_ledge</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="kw">_</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="ident">u8</span>,
		);

		<span class="comment">//  The center reference can only read,</span>
		<span class="macro">assert_eq!</span>(<span class="ident">c_ledge</span>.<span class="ident">load</span>(), <span class="number">0</span>);
		<span class="comment">//  while the left reference can write,</span>
		<span class="ident">l_redge</span>.<span class="ident">set_bits</span>(<span class="ident">BitMask::new</span>(<span class="number">6</span>));
		<span class="comment">//  and be observed by the center.</span>
		<span class="macro">assert_eq!</span>(<span class="ident">c_ledge</span>.<span class="ident">load</span>(), <span class="number">6</span>);
	}
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="bitvec" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>