<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Service load measurement"><title>tower::load - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-9ee3a5e31a2afa3e.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="tower" data-themes="" data-resource-suffix="" data-rustdoc-version="1.75.0 (82e1608df 2023-12-21)" data-channel="1.75.0" data-search-js="search-8fbf244ebcf71464.js" data-settings-js="settings-74424d7eec62a23e.js" ><script src="../../static.files/storage-fec3eaa3851e447d.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-9dd44ab47b99a0fb.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-5d8b3c7633ad77ba.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../tower/index.html">tower</a><span class="version">0.4.13</span></h2></div><h2 class="location"><a href="#">Module load</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></section><h2><a href="../index.html">In crate tower</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">tower</a>::<wbr><a class="mod" href="#">load</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/tower/load/mod.rs.html#1-89">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Service load measurement</p>
<p>This module provides the <a href="trait.Load.html" title="trait tower::load::Load"><code>Load</code></a> trait, which allows measuring how loaded a service is.
It also provides several wrapper types that measure load in different ways:</p>
<ul>
<li><a href="struct.Constant.html" title="struct tower::load::Constant"><code>Constant</code></a> — Always returns the same constant load value for a service.</li>
<li><a href="pending_requests/struct.PendingRequests.html" title="struct tower::load::pending_requests::PendingRequests"><code>PendingRequests</code></a> — Measures load by tracking the number of in-flight requests.</li>
<li><a href="peak_ewma/struct.PeakEwma.html" title="struct tower::load::peak_ewma::PeakEwma"><code>PeakEwma</code></a> — Measures load using a moving average of the peak latency for the service.</li>
</ul>
<p>In general, you will want to use one of these when using the types in <a href="../balance/index.html" title="mod tower::balance"><code>tower::balance</code></a> which
balance services depending on their load. Which load metric to use depends on your exact
use-case, but the ones above should get you quite far!</p>
<p>When the <code>discover</code> feature is enabled, wrapper types for <a href="../discover/trait.Discover.html" title="trait tower::discover::Discover"><code>Discover</code></a> that
wrap the discovered services with the given load estimator are also provided.</p>
<h2 id="when-does-a-request-complete"><a href="#when-does-a-request-complete">When does a request complete?</a></h2>
<p>For many applications, the request life-cycle is relatively simple: when a service responds to
a request, that request is done, and the system can forget about it. However, for some
applications, the service may respond to the initial request while other parts of the system
are still acting on that request. In such an application, the system load must take these
requests into account as well, or risk the system underestimating its own load.</p>
<p>To support these use-cases, the load estimators in this module are parameterized by the
<a href="completion/trait.TrackCompletion.html" title="trait tower::load::completion::TrackCompletion"><code>TrackCompletion</code></a> trait, with <a href="completion/struct.CompleteOnResponse.html" title="struct tower::load::completion::CompleteOnResponse"><code>CompleteOnResponse</code></a> as the default type. The behavior of
<a href="completion/struct.CompleteOnResponse.html" title="struct tower::load::completion::CompleteOnResponse"><code>CompleteOnResponse</code></a> is what you would normally expect for a request-response cycle: when the
response is produced, the request is considered “finished”, and load goes down. This can be
overriden by your own user-defined type to track more complex request completion semantics. See
the documentation for <a href="completion/index.html" title="mod tower::load::completion"><code>completion</code></a> for more details.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tower::util::ServiceExt;
<span class="kw">use </span>tower::{load::Load, Service};
<span class="kw">async fn </span>simple_balance&lt;S1, S2, R&gt;(
    svc1: <span class="kw-2">&amp;mut </span>S1,
    svc2: <span class="kw-2">&amp;mut </span>S2,
    request: R
) -&gt; <span class="prelude-ty">Result</span>&lt;S1::Response, S1::Error&gt;
<span class="kw">where
    </span>S1: Load + Service&lt;R&gt;,
    S2: Load&lt;Metric = S1::Metric&gt; + Service&lt;R, Response = S1::Response, Error = S1::Error&gt;
{
    <span class="kw">if </span>svc1.load() &lt; svc2.load() {
        svc1.ready().<span class="kw">await</span><span class="question-mark">?</span>.call(request).<span class="kw">await
    </span>} <span class="kw">else </span>{
        svc2.ready().<span class="kw">await</span><span class="question-mark">?</span>.call(request).<span class="kw">await
    </span>}
}</code></pre></div>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.CompleteOnResponse"><code>pub use self::completion::<a class="struct" href="completion/struct.CompleteOnResponse.html" title="struct tower::load::completion::CompleteOnResponse">CompleteOnResponse</a>;</code></div></li><li><div class="item-name" id="reexport.TrackCompletion"><code>pub use self::completion::<a class="trait" href="completion/trait.TrackCompletion.html" title="trait tower::load::completion::TrackCompletion">TrackCompletion</a>;</code></div></li><li><div class="item-name" id="reexport.PeakEwma"><code>pub use self::peak_ewma::<a class="struct" href="peak_ewma/struct.PeakEwma.html" title="struct tower::load::peak_ewma::PeakEwma">PeakEwma</a>;</code></div></li><li><div class="item-name" id="reexport.PendingRequests"><code>pub use self::pending_requests::<a class="struct" href="pending_requests/struct.PendingRequests.html" title="struct tower::load::pending_requests::PendingRequests">PendingRequests</a>;</code></div></li><li><div class="item-name" id="reexport.PeakEwmaDiscover"><code>pub use self::peak_ewma::<a class="struct" href="peak_ewma/struct.PeakEwmaDiscover.html" title="struct tower::load::peak_ewma::PeakEwmaDiscover">PeakEwmaDiscover</a>;</code></div></li><li><div class="item-name" id="reexport.PendingRequestsDiscover"><code>pub use self::pending_requests::<a class="struct" href="pending_requests/struct.PendingRequestsDiscover.html" title="struct tower::load::pending_requests::PendingRequestsDiscover">PendingRequestsDiscover</a>;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="completion/index.html" title="mod tower::load::completion">completion</a></div><div class="desc docblock-short">Application-specific request completion semantics.</div></li><li><div class="item-name"><a class="mod" href="peak_ewma/index.html" title="mod tower::load::peak_ewma">peak_ewma</a></div><div class="desc docblock-short">A <code>Load</code> implementation that measures load using the PeakEWMA response latency.</div></li><li><div class="item-name"><a class="mod" href="pending_requests/index.html" title="mod tower::load::pending_requests">pending_requests</a></div><div class="desc docblock-short">A <a href="trait.Load.html" title="trait tower::load::Load"><code>Load</code></a> implementation that measures load using the number of in-flight requests.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Constant.html" title="struct tower::load::Constant">Constant</a></div><div class="desc docblock-short">Wraps a type so that it implements <a href="trait.Load.html" title="trait tower::load::Load"><code>Load</code></a> and returns a constant load metric.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Load.html" title="trait tower::load::Load">Load</a></div><div class="desc docblock-short">Types that implement this trait can give an estimate of how loaded they are.</div></li></ul></section></div></main></body></html>