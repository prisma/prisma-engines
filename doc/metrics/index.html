<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A lightweight metrics facade."><meta name="keywords" content="rust, rustlang, rust-lang, metrics"><title>metrics - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../metrics/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../metrics/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate metrics</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 0.19.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul></div><section><div class="block"><ul><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div></section></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../metrics/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">metrics</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/metrics/lib.rs.html#1-801">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A lightweight metrics facade.</p>
<p>The <code>metrics</code> crate provides a single metrics API that abstracts over the actual metrics
implementation.  Libraries can use the metrics API provided by this crate, and the consumer of
those libraries can choose the metrics implementation that is most suitable for its use case.</p>
<h2 id="overview"><a href="#overview">Overview</a></h2>
<p><code>metrics</code> exposes two main concepts: emitting a metric, and recording it.</p>
<h3 id="metric-types-or-kinds"><a href="#metric-types-or-kinds">Metric types, or kinds</a></h3>
<p>This crate supports three fundamental metric types, or kinds: counters, gauges, and histograms.</p>
<h4 id="counters"><a href="#counters">Counters</a></h4>
<p>A counter is a cumulative metric that represents a monotonically increasing value which can only
be increased or be reset to zero on restart. For example, you might use a counter to
represent the number of operations performed, or the number of errors that have occurred.</p>
<p>Counters are unsigned 64-bit integers.</p>
<p>If you have a value that goes up and down over time, consider using a gauge.</p>
<h4 id="gauges"><a href="#gauges">Gauges</a></h4>
<p>A gauge is a metric that can go up and down, arbitrarily, over time.</p>
<p>Gauges are typically used for measured, external values, such as temperature, throughput, or
things like current memory usage.  Even if the value is monotonically increasing, but there is
no way to store the delta in order to properly figure out how much to increment by, then a gauge
might be a suitable choice.</p>
<p>Gauges support two modes: incremental updates, or absolute updates.  This allows callers to use
them for external measurements – where no delta can be computed – as well as internal measurements.</p>
<p>Gauges are floating-point 64-bit numbers.</p>
<h4 id="histograms"><a href="#histograms">Histograms</a></h4>
<p>A histogram stores an arbitrary number of observations of a specific measurement and provides
statistical analysis over the observed values.  Typically, measurements such as request latency
are recorded with histograms: a specific action that is repeated over and over which can have a
varying result each time.</p>
<p>Histograms are used to explore the distribution of values, allowing a caller to understand the
modalities of the distribution, such as whether or not all values are grouped close together, or
spread evenly, or even whether or not there are multiple groupings or clusters.</p>
<p>Colloquially, histograms are usually associated with percentiles, although by definition, they
specifically deal with bucketed or binned values: how many values fell within 0-10, how many
fell within 11-20, and so on and so forth.  Percentiles, commonly associated with “summaries”,
deal with understanding how much of a distribution falls below or at a particular percentage of
that distribution: 50% of requests are slower than 500ms, 99% of requests are slower than
2450ms, and so on and so forth.</p>
<p>While we use the term “histogram” in <code>metrics</code>, we enforce no particular usage of true
histograms or summaries.  The choice of output is based entirely on the exporter being used to
ship your metric data out of your application.  For example, if you’re using
<a href="https://docs.rs/metrics-exporter-prometheus">metrics-exporter-prometheus</a>, Prometheus supports both histograms and summaries, and the
exporter can be configured to output our “histogram” data as either.  Other exporters may choose
to stick to using summaries, as is traditional, in order to generate percentile data.</p>
<p>Histograms take floating-point 64-bit numbers.</p>
<h3 id="emission"><a href="#emission">Emission</a></h3>
<p>Metrics are emitted by utilizing the registration or emission macros.  There is a macro for
registering and emitting each fundamental metric type:</p>
<ul>
<li><a href="macro.register_counter.html" title="register_counter!"><code>register_counter!</code></a>, <a href="macro.counter.html" title="counter!"><code>counter!</code></a>, and <a href="macro.increment_counter.html" title="increment_counter!"><code>increment_counter!</code></a> for counters</li>
<li><a href="macro.register_gauge.html" title="register_gauge!"><code>register_gauge!</code></a>, <a href="macro.gauge.html" title="gauge!"><code>gauge!</code></a>, <a href="macro.increment_gauge.html" title="increment_gauge!"><code>increment_gauge!</code></a>, and <a href="macro.decrement_gauge.html" title="decrement_gauge!"><code>decrement_gauge!</code></a> for gauges</li>
<li><a href="macro.register_histogram.html" title="register_histogram!"><code>register_histogram!</code></a> and <a href="macro.histogram.html" title="histogram!"><code>histogram!</code></a> for histograms</li>
</ul>
<p>Additionally, metrics can be described – setting either the unit of measure or long-form
description – by using the <code>describe_*</code> macros:</p>
<ul>
<li><a href="macro.describe_counter.html" title="describe_counter!"><code>describe_counter!</code></a> for counters</li>
<li><a href="macro.describe_gauge.html" title="describe_gauge!"><code>describe_gauge!</code></a> for gauges</li>
<li><a href="macro.describe_histogram.html" title="describe_histogram!"><code>describe_histogram!</code></a> for histograms</li>
</ul>
<p>In order to register or emit a metric, you need a way to record these events, which is where
<a href="trait.Recorder.html" title="Recorder"><code>Recorder</code></a> comes into play.</p>
<h3 id="recording"><a href="#recording">Recording</a></h3>
<p>The <a href="trait.Recorder.html" title="Recorder"><code>Recorder</code></a> trait defines the interface between the registration/emission macros, and
exporters, which is how we refer to concrete implementations of <a href="trait.Recorder.html" title="Recorder"><code>Recorder</code></a>.  The trait defines
what the exporters are doing – recording – but ultimately exporters are sending data from your
application to somewhere else: whether it be a third-party service or logging via standard out.
It’s “exporting” the metric data out of your application.</p>
<p>Each metric type is usually reserved for a specific type of use case, whether it be tracking a
single value or allowing the summation of multiple values, and the respective macros elaborate
more on the usage and invariants provided by each.</p>
<h2 id="getting-started"><a href="#getting-started">Getting Started</a></h2><h3 id="in-libraries"><a href="#in-libraries">In libraries</a></h3>
<p>Libraries need only include the <code>metrics</code> crate to emit metrics.  When an executable installs a
recorder, all included crates which emitting metrics will now emit their metrics to that record,
which allows library authors to seamless emit their own metrics without knowing or caring which
exporter implementation is chosen, or even if one is installed.</p>
<p>In cases where no global recorder is installed, a “noop” recorder lives in its place, which has
an incredibly very low overhead: an atomic load and comparison.  Libraries can safely instrument
their code without fear of ruining baseline performance.</p>
<p>By default, a “noop” recorder is present so that the macros can work even if no exporter has
been installed.  This recorder has extremely low overhead – a relaxed load and conditional –
and so, practically speaking, the overhead when no exporter is installed is extremely low.  You
can safely instrument applications knowing that you won’t pay a heavy performance cost even if
you’re not shipping metrics.</p>
<h4 id="examples"><a href="#examples">Examples</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">metrics</span>::{<span class="ident">counter</span>, <span class="ident">histogram</span>};

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">process</span>(<span class="ident">query</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) -&gt; <span class="ident">u64</span> {
    <span class="kw">let</span> <span class="ident">start</span> <span class="op">=</span> <span class="ident">Instant::now</span>();
    <span class="kw">let</span> <span class="ident">row_count</span> <span class="op">=</span> <span class="ident">run_query</span>(<span class="ident">query</span>);
    <span class="kw">let</span> <span class="ident">delta</span> <span class="op">=</span> <span class="ident">start</span>.<span class="ident">elapsed</span>();

    <span class="macro">histogram!</span>(<span class="string">&quot;process.query_time&quot;</span>, <span class="ident">delta</span>);
    <span class="macro">counter!</span>(<span class="string">&quot;process.query_row_count&quot;</span>, <span class="ident">row_count</span>);

    <span class="ident">row_count</span>
}</code></pre></div>
<h3 id="in-executables"><a href="#in-executables">In executables</a></h3>
<p>Executables, which themselves can emit their own metrics, are intended to install a global
recorder so that metrics can actually be recorded and exported somewhere.</p>
<p>Initialization of the global recorder isn’t required for macros to function, but any metrics
emitted before a global recorder is installed will not be recorded, so initialization and
installation of an exporter should happen as early as possible in the application lifecycle.</p>
<h4 id="warning"><a href="#warning">Warning</a></h4>
<p>The metrics system may only be initialized once.</p>
<p>For most use cases, you’ll be using an off-the-shelf exporter implementation that hooks up to an
existing metrics collection system, or interacts with the existing systems/processes that you use.</p>
<p>Out of the box, some exporter implementations are available for you to use:</p>
<ul>
<li><a href="https://docs.rs/metrics-exporter-tcp">metrics-exporter-tcp</a> - outputs metrics to clients over TCP</li>
<li><a href="https://docs.rs/metrics-exporter-prometheus">metrics-exporter-prometheus</a> - serves a Prometheus scrape endpoint</li>
</ul>
<p>You can also implement your own recorder if a suitable one doesn’t already exist.</p>
<h2 id="development"><a href="#development">Development</a></h2>
<p>The primary interface with <code>metrics</code> is through the <a href="trait.Recorder.html" title="Recorder"><code>Recorder</code></a> trait, so we’ll show examples
below of the trait and implementation notes.</p>
<h3 id="installing-a-basic-recorder"><a href="#installing-a-basic-recorder">Installing a basic recorder</a></h3>
<p>Here’s a basic example which writes metrics in text form via the <code>log</code> crate.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Recorders are installed by calling the [`set_recorder`] function.  Recorders should provide a</span>
<span class="comment">// function that wraps the creation and installation of the recorder:</span>

<span class="kw">static</span> <span class="ident">RECORDER</span>: <span class="ident">LogRecorder</span> <span class="op">=</span> <span class="ident">LogRecorder</span>;

<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">init</span>() -&gt; <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">SetRecorderError</span><span class="op">&gt;</span> {
    <span class="ident">metrics::set_recorder</span>(<span class="kw-2">&amp;</span><span class="ident">RECORDER</span>)
}</code></pre></div>
<h3 id="keys"><a href="#keys">Keys</a></h3>
<p>All metrics are, in essence, the combination of a metric type and metric identifier, such as a
histogram called “response_latency”.  You could conceivably have multiple metrics with the same
name, so long as they are of different types.</p>
<p>As the types are enforced/limited by the <a href="trait.Recorder.html" title="Recorder"><code>Recorder</code></a> trait itself, the remaining piece is the
identifier, which we handle by using <a href="struct.Key.html" title="Key"><code>Key</code></a>. Keys hold both the metric name, and potentially,
labels related to the metric. The metric name and labels are always string values.</p>
<p>Internally, <code>metrics</code> uses a clone-on-write “smart pointer” for these values to optimize cases
where the values are static strings, which can provide significant performance benefits.  These
smart pointers can also hold owned <code>String</code> values, though, so users can mix and match static
strings and owned strings without issue.</p>
<p>Two <a href="struct.Key.html" title="Key"><code>Key</code></a> objects can be checked for equality and considered to point to the same metric if
they are equal.  Equality checks both the name of the key and the labels of a key.  Labels are
<em>not</em> sorted prior to checking for equality, but insertion order is maintained, so any <a href="struct.Key.html" title="Key"><code>Key</code></a>
constructed from the same set of labels in the same order should be equal.</p>
<p>It is an implementation detail if a recorder wishes to do an deeper equality check that ignores
the order of labels, but practically speaking, metric emission, and thus labels, should be
fixed in ordering in nearly all cases, and so it typically is not a problem.</p>
<h3 id="registration"><a href="#registration">Registration</a></h3>
<p>Recorders must handle the “registration” of a metric.</p>
<p>In practice, registration solves two potential problems: providing metadata for a metric, and
creating an entry for a metric even though it has not been emitted yet.</p>
<p>Callers may wish to provide a human-readable description of what the metric is, or provide the
units the metrics uses.  Additionally, users may wish to register their metrics so that they
show up in the output of the installed exporter even if the metrics have yet to be emitted.
This allows callers to ensure the metrics output is stable, or allows them to expose all of the
potential metrics a system has to offer, again, even if they have not all yet been emitted.</p>
<p>As you can see from the trait, the registration methods treats the metadata as optional, and
the macros allow users to mix and match whichever fields they want to provide.</p>
<p>When a metric is registered, the expectation is that it will show up in output with a default
value, so, for example, a counter should be initialized to zero, a histogram would have no
values, and so on.</p>
<h3 id="emission-1"><a href="#emission-1">Emission</a></h3>
<p>Likewise, recorders must handle the emission of metrics as well.</p>
<p>Comparatively speaking, emission is not too different from registration: you have access to the
same <a href="struct.Key.html" title="Key"><code>Key</code></a> as well as the value being emitted.</p>
<p>For recorders which temporarily buffer or hold on to values before exporting, a typical approach
would be to utilize atomic variables for the storage.  For counters and gauges, this can be done
simply by using types like <a href="https://doc.rust-lang.org/1.63.0/core/sync/atomic/struct.AtomicU64.html"><code>AtomicU64</code></a>.  For histograms, this can be
slightly tricky as you must hold on to all of the distinct values.  In our helper crate,
<a href="https://docs.rs/metrics-util"><code>metrics-util</code></a>, we’ve provided a type called <a href="https://docs.rs/metrics-util/0.5.0/metrics_util/struct.AtomicBucket.html"><code>AtomicBucket</code></a>.  For
exporters that will want to get all of the current values in a batch, while clearing the bucket so
that values aren’t processed again, <a href="https://docs.rs/metrics-util/0.5.0/metrics_util/struct.AtomicBucket.html">AtomicBucket</a> provides a simple interface to do so, as well as
optimized performance on both the insertion and read side.</p>
<p>Combined together, exporter authors can use <a href="https://docs.rs/metrics-util/0.5.0/metrics_util/enum.Handle.html"><code>Handle</code></a>, also from the <code>metrics-util</code>
crate, which provides a consolidated type for holding metric data.  These types, and many more
from the <code>metrics-util</code> crate, form the basis of typical exporter behavior and have been exposed
to help you quickly build a new exporter.</p>
<h3 id="installing-recorders"><a href="#installing-recorders">Installing recorders</a></h3>
<p>In order to actually use an exporter, it must be installed as the “global” recorder.  This is a
static recorder that the registration and emission macros refer to behind-the-scenes.  <code>metrics</code>
provides a few methods to do so: <a href="fn.set_recorder.html" title="set_recorder"><code>set_recorder</code></a>, <a href="fn.set_boxed_recorder.html" title="set_boxed_recorder"><code>set_boxed_recorder</code></a>, and <a href="fn.set_recorder_racy.html" title="set_recorder_racy"><code>set_recorder_racy</code></a>.</p>
<p>Primarily, you’ll use <a href="fn.set_boxed_recorder.html" title="set_boxed_recorder"><code>set_boxed_recorder</code></a> to pass a boxed version of the exporter to be
installed.  This is due to the fact that most exporters won’t be able to be constructed
statically.  If you could construct your exporter statically, though, then you could instead
choose <a href="fn.set_recorder.html" title="set_recorder"><code>set_recorder</code></a>.</p>
<p>Similarly, <a href="fn.set_recorder_racy.html" title="set_recorder_racy"><code>set_recorder_racy</code></a> takes a static reference, but is also not thread safe, and
should only be used on platforms which do not support atomic operations, such as embedded
environments.</p>
<p>As users of <code>metrics</code>, you’ll typically see exporters provide methods to install themselves that
hide the nitty gritty details.  These methods will usually be aptly named, such as <code>install</code>.</p>
</div></details><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.absolute_counter.html" title="metrics::absolute_counter macro">absolute_counter</a></div><div class="item-right docblock-short"><p>Sets a counter to an absolute value.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.counter.html" title="metrics::counter macro">counter</a></div><div class="item-right docblock-short"><p>Increments a counter.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.decrement_gauge.html" title="metrics::decrement_gauge macro">decrement_gauge</a></div><div class="item-right docblock-short"><p>Decrements a gauge.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.describe_counter.html" title="metrics::describe_counter macro">describe_counter</a></div><div class="item-right docblock-short"><p>Describes a counter.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.describe_gauge.html" title="metrics::describe_gauge macro">describe_gauge</a></div><div class="item-right docblock-short"><p>Describes a gauge.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.describe_histogram.html" title="metrics::describe_histogram macro">describe_histogram</a></div><div class="item-right docblock-short"><p>Describes a histogram.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.gauge.html" title="metrics::gauge macro">gauge</a></div><div class="item-right docblock-short"><p>Updates a gauge.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.histogram.html" title="metrics::histogram macro">histogram</a></div><div class="item-right docblock-short"><p>Records a histogram.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.increment_counter.html" title="metrics::increment_counter macro">increment_counter</a></div><div class="item-right docblock-short"><p>Increments a counter by one.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.increment_gauge.html" title="metrics::increment_gauge macro">increment_gauge</a></div><div class="item-right docblock-short"><p>Increments a gauge.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.register_counter.html" title="metrics::register_counter macro">register_counter</a></div><div class="item-right docblock-short"><p>Registers a counter.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.register_gauge.html" title="metrics::register_gauge macro">register_gauge</a></div><div class="item-right docblock-short"><p>Registers a gauge.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.register_histogram.html" title="metrics::register_histogram macro">register_histogram</a></div><div class="item-right docblock-short"><p>Registers a histogram.</p>
</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Counter.html" title="metrics::Counter struct">Counter</a></div><div class="item-right docblock-short"><p>A counter.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Gauge.html" title="metrics::Gauge struct">Gauge</a></div><div class="item-right docblock-short"><p>A gauge.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Histogram.html" title="metrics::Histogram struct">Histogram</a></div><div class="item-right docblock-short"><p>A histogram.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Key.html" title="metrics::Key struct">Key</a></div><div class="item-right docblock-short"><p>A metric identifier.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.KeyHasher.html" title="metrics::KeyHasher struct">KeyHasher</a></div><div class="item-right docblock-short"><p>Key-specific hashing algorithm.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.KeyName.html" title="metrics::KeyName struct">KeyName</a></div><div class="item-right docblock-short"><p>Name component of a key.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Label.html" title="metrics::Label struct">Label</a></div><div class="item-right docblock-short"><p>Metadata for a metric key in the form of a key/value pair.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.NoopRecorder.html" title="metrics::NoopRecorder struct">NoopRecorder</a></div><div class="item-right docblock-short"><p>A no-op recorder.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.SetRecorderError.html" title="metrics::SetRecorderError struct">SetRecorderError</a></div><div class="item-right docblock-short"><p>The type returned by <a href="fn.set_recorder.html" title="set_recorder"><code>set_recorder</code></a> if <a href="fn.set_recorder.html" title="set_recorder"><code>set_recorder</code></a> has already been called.</p>
</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.GaugeValue.html" title="metrics::GaugeValue enum">GaugeValue</a></div><div class="item-right docblock-short"><p>Value of a gauge operation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Unit.html" title="metrics::Unit enum">Unit</a></div><div class="item-right docblock-short"><p>Units for a given metric.</p>
</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.CounterFn.html" title="metrics::CounterFn trait">CounterFn</a></div><div class="item-right docblock-short"><p>A counter handler.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.GaugeFn.html" title="metrics::GaugeFn trait">GaugeFn</a></div><div class="item-right docblock-short"><p>A gauge handler.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.HistogramFn.html" title="metrics::HistogramFn trait">HistogramFn</a></div><div class="item-right docblock-short"><p>A histogram handler.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.IntoF64.html" title="metrics::IntoF64 trait">IntoF64</a></div><div class="item-right docblock-short"><p>An object which can be converted into a <code>f64</code> representation.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.IntoLabels.html" title="metrics::IntoLabels trait">IntoLabels</a></div><div class="item-right docblock-short"><p>A value that can be converted to a vector of <a href="struct.Label.html" title="Label"><code>Label</code></a>s.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Recorder.html" title="metrics::Recorder trait">Recorder</a></div><div class="item-right docblock-short"><p>A trait for registering and recording metrics.</p>
</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.recorder.html" title="metrics::recorder fn">recorder</a></div><div class="item-right docblock-short"><p>Returns a reference to the recorder.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.set_boxed_recorder.html" title="metrics::set_boxed_recorder fn">set_boxed_recorder</a></div><div class="item-right docblock-short"><p>Sets the global recorder to a <code>Box&lt;Recorder&gt;</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.set_recorder.html" title="metrics::set_recorder fn">set_recorder</a></div><div class="item-right docblock-short"><p>Sets the global recorder to a <code>&amp;'static Recorder</code>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.set_recorder_racy.html" title="metrics::set_recorder_racy fn">set_recorder_racy</a><a title="unsafe function" href="#"><sup>⚠</sup></a></div><div class="item-right docblock-short"><p>A thread-unsafe version of <a href="fn.set_recorder.html" title="set_recorder"><code>set_recorder</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.try_recorder.html" title="metrics::try_recorder fn">try_recorder</a></div><div class="item-right docblock-short"><p>Returns a reference to the recorder.</p>
</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.SharedString.html" title="metrics::SharedString type">SharedString</a></div><div class="item-right docblock-short"><p>An allocation-optimized string.</p>
</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="metrics" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>