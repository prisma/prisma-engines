<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="“Fallible” iterators."><title>fallible_iterator - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-9bb858ba049f1f21.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="fallible_iterator" data-themes="" data-resource-suffix="" data-rustdoc-version="1.72.1 (d5c2e9c34 2023-09-13) (built from a source tarball)" data-channel="1.72.1" data-search-js="search-f6292fe389d70017.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ><script src="../static.files/storage-59fd9b8ccb335783.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../fallible_iterator/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../fallible_iterator/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate fallible_iterator</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.2.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">fallible_iterator</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/fallible_iterator/lib.rs.html#1-2606">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>“Fallible” iterators.</p>
<p>The iterator APIs in the Rust standard library do not support iteration
that can fail in a first class manner. These iterators are typically modeled
as iterating over <code>Result&lt;T, E&gt;</code> values; for example, the <code>Lines</code> iterator
returns <code>io::Result&lt;String&gt;</code>s. When simply iterating over these types, the
value being iterated over must be unwrapped in some way before it can be
used:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">for </span>line <span class="kw">in </span>reader.lines() {
    <span class="kw">let </span>line = line<span class="question-mark">?</span>;
    <span class="comment">// work with line
</span>}</code></pre></div>
<p>In addition, many of the additional methods on the <code>Iterator</code> trait will
not behave properly in the presence of errors when working with these kinds
of iterators. For example, if one wanted to count the number of lines of
text in a <code>Read</code>er, this might be a way to go about it:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">let </span>count = reader.lines().count();</code></pre></div>
<p>This will return the proper value when the reader operates successfully, but
if it encounters an IO error, the result will either be slightly higher than
expected if the error is transient, or it may run forever if the error is
returned repeatedly!</p>
<p>In contrast, a fallible iterator is built around the concept that a call to
<code>next</code> can fail. The trait has an additional <code>Error</code> associated type in
addition to the <code>Item</code> type, and <code>next</code> returns <code>Result&lt;Option&lt;Self::Item&gt;, Self::Error&gt;</code> rather than <code>Option&lt;Self::Item&gt;</code>. Methods like <code>count</code> return
<code>Result</code>s as well.</p>
<p>This does mean that fallible iterators are incompatible with Rust’s <code>for</code>
loop syntax, but <code>while let</code> loops offer a similar level of ergonomics:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">while let </span><span class="prelude-val">Some</span>(item) = iter.next()<span class="question-mark">? </span>{
    <span class="comment">// work with item
</span>}</code></pre></div>
<h3 id="fallible-closure-arguments"><a href="#fallible-closure-arguments">Fallible closure arguments</a></h3>
<p>Like <code>Iterator</code>, many <code>FallibleIterator</code> methods take closures as arguments.
These use the same signatures as their <code>Iterator</code> counterparts, except that
<code>FallibleIterator</code> expects the closures to be fallible: they return
<code>Result&lt;T, Self::Error&gt;</code> instead of simply <code>T</code>.</p>
<p>For example, the standard library’s <code>Iterator::filter</code> adapter method
filters the underlying iterator according to a predicate provided by the
user, whose return type is <code>bool</code>. In <code>FallibleIterator::filter</code>, however,
the predicate returns <code>Result&lt;bool, Self::Error&gt;</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>numbers = convert(<span class="string">&quot;100\n200\nfern\n400&quot;</span>.lines().map(<span class="prelude-val">Ok</span>::&lt;<span class="kw-2">&amp;</span>str, Box&lt;Error&gt;&gt;));
<span class="kw">let </span>big_numbers = numbers.filter(|n| <span class="prelude-val">Ok</span>(u64::from_str(n)<span class="question-mark">? </span>&gt; <span class="number">100</span>));
<span class="macro">assert!</span>(big_numbers.count().is_err());</code></pre></div>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Chain.html" title="struct fallible_iterator::Chain">Chain</a></div><div class="desc docblock-short">An iterator which yields the elements of one iterator followed by another.</div></li><li><div class="item-name"><a class="struct" href="struct.Cloned.html" title="struct fallible_iterator::Cloned">Cloned</a></div><div class="desc docblock-short">An iterator which clones the elements of the underlying iterator.</div></li><li><div class="item-name"><a class="struct" href="struct.Convert.html" title="struct fallible_iterator::Convert">Convert</a></div><div class="desc docblock-short">A fallible iterator that wraps a normal iterator over <code>Result</code>s.</div></li><li><div class="item-name"><a class="struct" href="struct.Cycle.html" title="struct fallible_iterator::Cycle">Cycle</a></div><div class="desc docblock-short">An iterator which cycles another endlessly.</div></li><li><div class="item-name"><a class="struct" href="struct.Enumerate.html" title="struct fallible_iterator::Enumerate">Enumerate</a></div><div class="desc docblock-short">An iterator that yields the iteration count as well as the values of the
underlying iterator.</div></li><li><div class="item-name"><a class="struct" href="struct.Filter.html" title="struct fallible_iterator::Filter">Filter</a></div><div class="desc docblock-short">An iterator which uses a fallible predicate to determine which values of the
underlying iterator should be yielded.</div></li><li><div class="item-name"><a class="struct" href="struct.FilterMap.html" title="struct fallible_iterator::FilterMap">FilterMap</a></div><div class="desc docblock-short">An iterator which both filters and maps the values of the underlying
iterator.</div></li><li><div class="item-name"><a class="struct" href="struct.FlatMap.html" title="struct fallible_iterator::FlatMap">FlatMap</a></div><div class="desc docblock-short">An iterator which maps each element to another iterator, yielding those iterator’s elements.</div></li><li><div class="item-name"><a class="struct" href="struct.Flatten.html" title="struct fallible_iterator::Flatten">Flatten</a></div><div class="desc docblock-short">An iterator which flattens an iterator of iterators, yielding those iterators’ elements.</div></li><li><div class="item-name"><a class="struct" href="struct.Fuse.html" title="struct fallible_iterator::Fuse">Fuse</a></div><div class="desc docblock-short">An iterator that yields <code>Ok(None)</code> forever after the underlying iterator
yields <code>Ok(None)</code> once.</div></li><li><div class="item-name"><a class="struct" href="struct.Inspect.html" title="struct fallible_iterator::Inspect">Inspect</a></div><div class="desc docblock-short">An iterator which passes each element to a closure before returning it.</div></li><li><div class="item-name"><a class="struct" href="struct.Iterator.html" title="struct fallible_iterator::Iterator">Iterator</a></div><div class="desc docblock-short">A normal (non-fallible) iterator which wraps a fallible iterator.</div></li><li><div class="item-name"><a class="struct" href="struct.Map.html" title="struct fallible_iterator::Map">Map</a></div><div class="desc docblock-short">An iterator which applies a fallible transform to the elements of the
underlying iterator.</div></li><li><div class="item-name"><a class="struct" href="struct.MapErr.html" title="struct fallible_iterator::MapErr">MapErr</a></div><div class="desc docblock-short">An iterator which applies a transform to the errors of the underlying
iterator.</div></li><li><div class="item-name"><a class="struct" href="struct.Peekable.html" title="struct fallible_iterator::Peekable">Peekable</a></div><div class="desc docblock-short">An iterator which can look at the next element without consuming it.</div></li><li><div class="item-name"><a class="struct" href="struct.Rev.html" title="struct fallible_iterator::Rev">Rev</a></div><div class="desc docblock-short">An iterator which yields elements of the underlying iterator in reverse
order.</div></li><li><div class="item-name"><a class="struct" href="struct.Scan.html" title="struct fallible_iterator::Scan">Scan</a></div><div class="desc docblock-short">An iterator which applies a stateful closure.</div></li><li><div class="item-name"><a class="struct" href="struct.Skip.html" title="struct fallible_iterator::Skip">Skip</a></div><div class="desc docblock-short">An iterator which skips initial elements.</div></li><li><div class="item-name"><a class="struct" href="struct.SkipWhile.html" title="struct fallible_iterator::SkipWhile">SkipWhile</a></div><div class="desc docblock-short">An iterator which skips initial elements based on a predicate.</div></li><li><div class="item-name"><a class="struct" href="struct.StepBy.html" title="struct fallible_iterator::StepBy">StepBy</a></div><div class="desc docblock-short">An iterator which steps through the elements of the underlying iterator by a certain amount.</div></li><li><div class="item-name"><a class="struct" href="struct.Take.html" title="struct fallible_iterator::Take">Take</a></div><div class="desc docblock-short">An iterator which yields a limited number of elements from the underlying
iterator.</div></li><li><div class="item-name"><a class="struct" href="struct.TakeWhile.html" title="struct fallible_iterator::TakeWhile">TakeWhile</a></div><div class="desc docblock-short">An iterator which yields elements based on a predicate.</div></li><li><div class="item-name"><a class="struct" href="struct.Zip.html" title="struct fallible_iterator::Zip">Zip</a></div><div class="desc docblock-short">An iterator that yields pairs of this iterator’s and another iterator’s
values.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.DoubleEndedFallibleIterator.html" title="trait fallible_iterator::DoubleEndedFallibleIterator">DoubleEndedFallibleIterator</a></div><div class="desc docblock-short">A fallible iterator able to yield elements from both ends.</div></li><li><div class="item-name"><a class="trait" href="trait.FallibleIterator.html" title="trait fallible_iterator::FallibleIterator">FallibleIterator</a></div><div class="desc docblock-short">An <code>Iterator</code>-like trait that allows for calculation of items to fail.</div></li><li><div class="item-name"><a class="trait" href="trait.FromFallibleIterator.html" title="trait fallible_iterator::FromFallibleIterator">FromFallibleIterator</a></div><div class="desc docblock-short">Conversion from a fallible iterator.</div></li><li><div class="item-name"><a class="trait" href="trait.IntoFallibleIterator.html" title="trait fallible_iterator::IntoFallibleIterator">IntoFallibleIterator</a></div><div class="desc docblock-short">Conversion into a <code>FallibleIterator</code>.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.convert.html" title="fn fallible_iterator::convert">convert</a></div><div class="desc docblock-short">Converts an <code>Iterator&lt;Item = Result&lt;T, E&gt;&gt;</code> into a <code>FallibleIterator&lt;Item = T, Error = E&gt;</code>.</div></li></ul></section></div></main></body></html>