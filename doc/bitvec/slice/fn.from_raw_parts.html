<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Forms a bit-slice from a bit-pointer and a length."><meta name="keywords" content="rust, rustlang, rust-lang, from_raw_parts"><title>from_raw_parts in bitvec::slice - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><div class="sidebar-elems"><h2 class="location"><a href="index.html">In bitvec::slice</a></h2></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../bitvec/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Function <a href="../index.html">bitvec</a>::<wbr><a href="index.html">slice</a>::<wbr><a class="fn" href="#">from_raw_parts</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2332-2341">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust fn"><code>pub unsafe fn from_raw_parts&lt;'a, O, T&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;data: <a class="struct" href="../prelude/struct.BitPtr.html" title="struct bitvec::prelude::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, O, T&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;len: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;&amp;'a <a class="struct" href="struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;O, T&gt;, <a class="enum" href="../ptr/enum.BitSpanError.html" title="enum bitvec::ptr::BitSpanError">BitSpanError</a>&lt;T&gt;&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Forms a bit-slice from a bit-pointer and a length.</p>
<p>The <code>len</code> argument is the number of <strong>bits</strong>, not the number of bytes or
elements.</p>
<h2 id="original"><a href="#original">Original</a></h2>
<p><a href="https://doc.rust-lang.org/1.63.0/core/slice/raw/fn.from_raw_parts.html"><code>slice::from_raw_parts</code></a></p>
<h2 id="api-differences"><a href="#api-differences">API Differences</a></h2>
<p>This takes a <a href="../prelude/struct.BitPtr.html"><code>BitPtr</code></a> as its base address, rather than a raw <code>*Bit</code>
pointer, as <code>bitvec</code> does not provide raw pointers to individual bits.</p>
<p>It returns a <code>Result</code>, because the <code>len</code> argument may be invalid to encode
into a <code>&amp;BitSlice</code> reference.</p>
<h2 id="safety"><a href="#safety">Safety</a></h2>
<p>Behavior is undefined if any of the following conditions are violated:</p>
<ul>
<li><code>data</code> must be valid for reads for <code>len</code> many bits, and it must be
properly aligned. This means in particular:
<ul>
<li>The entire memory range of this slice must be contained within a single
allocated object! Slices can never span across multiple allocated
objects. See <a href="#incorrect-usage">below</a> for an example incorrectly not taking this into
account.</li>
<li><code>data</code> must be non-null, and its <code>T</code> portion must be aligned. Both of
these conditions are checked during safe construction of the <a href="../prelude/struct.BitPtr.html"><code>BitPtr</code></a>,
and <code>unsafe</code> construction of it <strong>must not</strong> violate them. Doing so will
cause incorrect behavior in the crate.</li>
</ul>
</li>
<li><code>data</code> must point to <code>len</code> consecutive bits within properly initialized
memory elements <code>T</code>.</li>
<li>The memory referenced by the returned slice must not be mutated for the
duration of the lifetime <code>'a</code>, except if <code>T</code> is an atomic or a <code>Cell</code>
type.</li>
<li><code>len</code> cannot exceed <a href="struct.BitSlice.html#associatedconstant.MAX_BITS"><code>BitSlice::MAX_BITS</code></a>.</li>
</ul>
<h2 id="caveat"><a href="#caveat">Caveat</a></h2>
<p>The lifetime for the returned slice is inferred from its usage. To prevent
accidental misuse, it’s suggested to tie the lifetime to whichever source
lifetime is safe in the context, such as by providing a helper function
taking the lifetime of a host value for the slice, or by explicit
annotation.</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">bitvec::slice</span> <span class="kw">as</span> <span class="ident">bv_slice</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">42u8</span>;
<span class="kw">let</span> <span class="ident">bitptr</span> <span class="op">=</span> <span class="ident">BitPtr::from</span>(<span class="kw-2">&amp;</span><span class="ident">x</span>);
<span class="kw">let</span> <span class="ident">bits</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">LocalBits</span>, <span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="kw">unsafe</span> {
  <span class="ident">bv_slice::from_raw_parts</span>(<span class="ident">bitptr</span>, <span class="number">8</span>)
}
.<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="ident">x</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span><span class="op">&gt;</span>());</code></pre></div>
<h4 id="incorrect-usage"><a href="#incorrect-usage">Incorrect Usage</a></h4>
<p>The following <code>join_slices</code> function is <strong>unsound</strong> ⚠️</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">bitvec::slice</span> <span class="kw">as</span> <span class="ident">bv_slice</span>;

<span class="kw">fn</span> <span class="ident">join_bitslices</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>(
  <span class="ident">fst</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>,
  <span class="ident">snd</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>,
) -&gt; <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">BitSlice</span><span class="op">&lt;</span><span class="ident">O</span>, <span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">O</span>: <span class="ident">BitOrder</span>, <span class="ident">T</span>: <span class="ident">BitStore</span> {
  <span class="kw">let</span> <span class="ident">fst_end</span> <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="ident">fst</span>.<span class="ident">as_bitptr</span>().<span class="ident">wrapping_add</span>(<span class="ident">fst</span>.<span class="ident">len</span>())
  };
  <span class="kw">let</span> <span class="ident">snd_start</span> <span class="op">=</span> <span class="ident">snd</span>.<span class="ident">as_bitptr</span>();
  <span class="macro">assert_eq!</span>(<span class="ident">snd_start</span>, <span class="ident">fst_end</span>, <span class="string">&quot;Slices must be adjacent&quot;</span>);
  <span class="kw">unsafe</span> {
    <span class="ident">bv_slice::from_raw_parts</span>(<span class="ident">fst</span>.<span class="ident">as_bitptr</span>(), <span class="ident">fst</span>.<span class="ident">len</span>() <span class="op">+</span> <span class="ident">snd</span>.<span class="ident">len</span>())
  }
  .<span class="ident">unwrap</span>()
}

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> [<span class="number">0u8</span>; <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> [<span class="op">!</span><span class="number">0u8</span>; <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">join_bitslices</span>(
  <span class="ident">a</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span><span class="op">&gt;</span>(),
  <span class="ident">b</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">LocalBits</span><span class="op">&gt;</span>(),
);</code></pre></div>
<p>In this example, the compiler may elect to place <code>a</code> and <code>b</code> in adjacent
stack slots, but because they are still <em>separate allocation</em> regions, it is
illegal for a single region descriptor to be created over both of them.</p>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="bitvec" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>