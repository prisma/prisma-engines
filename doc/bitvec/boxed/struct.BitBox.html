<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Fixed-Size, Heap-Allocated, Bit Slice"><meta name="keywords" content="rust, rustlang, rust-lang, BitBox"><title>BitBox in bitvec::boxed - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../../dark.css" disabled><link rel="stylesheet" type="text/css" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../../bitvec/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">BitBox</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><ul><li><a href="#method.as_bitslice">as_bitslice</a></li><li><a href="#method.as_mut_bitslice">as_mut_bitslice</a></li><li><a href="#method.as_raw_mut_slice">as_raw_mut_slice</a></li><li><a href="#method.as_raw_slice">as_raw_slice</a></li><li><a href="#method.fill_uninitialized">fill_uninitialized</a></li><li><a href="#method.force_align">force_align</a></li><li><a href="#method.from_bitslice">from_bitslice</a></li><li><a href="#method.from_boxed_slice">from_boxed_slice</a></li><li><a href="#method.from_raw">from_raw</a></li><li><a href="#method.into_bitvec">into_bitvec</a></li><li><a href="#method.into_boxed_slice">into_boxed_slice</a></li><li><a href="#method.into_raw">into_raw</a></li><li><a href="#method.leak">leak</a></li><li><a href="#method.try_from_boxed_slice">try_from_boxed_slice</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#deref-methods-BitSlice%3CT%2C%20O%3E">Methods from Deref&lt;Target=BitSlice&lt;T, O&gt;&gt;</a></h3><ul><li><a href="#method.align_to">align_to</a></li><li><a href="#method.align_to_mut">align_to_mut</a></li><li><a href="#method.all">all</a></li><li><a href="#method.any">any</a></li><li><a href="#method.as_bitptr">as_bitptr</a></li><li><a href="#method.as_bitptr_range">as_bitptr_range</a></li><li><a href="#method.as_mut_bitptr">as_mut_bitptr</a></li><li><a href="#method.as_mut_bitptr_range">as_mut_bitptr_range</a></li><li><a href="#method.as_mut_ptr">as_mut_ptr</a></li><li><a href="#method.as_mut_ptr_range">as_mut_ptr_range</a></li><li><a href="#method.as_ptr">as_ptr</a></li><li><a href="#method.as_ptr_range">as_ptr_range</a></li><li><a href="#method.bit_domain">bit_domain</a></li><li><a href="#method.bit_domain_mut">bit_domain_mut</a></li><li><a href="#method.chunks">chunks</a></li><li><a href="#method.chunks_exact">chunks_exact</a></li><li><a href="#method.chunks_exact_mut">chunks_exact_mut</a></li><li><a href="#method.chunks_mut">chunks_mut</a></li><li><a href="#method.clone_from_bitslice">clone_from_bitslice</a></li><li><a href="#method.clone_from_slice">clone_from_slice</a></li><li><a href="#method.contains">contains</a></li><li><a href="#method.copy_from_bitslice">copy_from_bitslice</a></li><li><a href="#method.copy_from_slice">copy_from_slice</a></li><li><a href="#method.copy_within">copy_within</a></li><li><a href="#method.copy_within_unchecked">copy_within_unchecked</a></li><li><a href="#method.count_ones">count_ones</a></li><li><a href="#method.count_zeros">count_zeros</a></li><li><a href="#method.domain">domain</a></li><li><a href="#method.domain_mut">domain_mut</a></li><li><a href="#method.ends_with">ends_with</a></li><li><a href="#method.fill">fill</a></li><li><a href="#method.fill_with">fill_with</a></li><li><a href="#method.first">first</a></li><li><a href="#method.first_mut">first_mut</a></li><li><a href="#method.first_one">first_one</a></li><li><a href="#method.first_zero">first_zero</a></li><li><a href="#method.get">get</a></li><li><a href="#method.get_mut">get_mut</a></li><li><a href="#method.get_unchecked">get_unchecked</a></li><li><a href="#method.get_unchecked_mut">get_unchecked_mut</a></li><li><a href="#method.is_empty">is_empty</a></li><li><a href="#method.iter">iter</a></li><li><a href="#method.iter_mut">iter_mut</a></li><li><a href="#method.iter_ones">iter_ones</a></li><li><a href="#method.iter_zeros">iter_zeros</a></li><li><a href="#method.last">last</a></li><li><a href="#method.last_mut">last_mut</a></li><li><a href="#method.last_one">last_one</a></li><li><a href="#method.last_zero">last_zero</a></li><li><a href="#method.leading_ones">leading_ones</a></li><li><a href="#method.leading_zeros">leading_zeros</a></li><li><a href="#method.len">len</a></li><li><a href="#method.not_all">not_all</a></li><li><a href="#method.not_any">not_any</a></li><li><a href="#method.rchunks">rchunks</a></li><li><a href="#method.rchunks_exact">rchunks_exact</a></li><li><a href="#method.rchunks_exact_mut">rchunks_exact_mut</a></li><li><a href="#method.rchunks_mut">rchunks_mut</a></li><li><a href="#method.repeat">repeat</a></li><li><a href="#method.replace">replace</a></li><li><a href="#method.replace_unchecked">replace_unchecked</a></li><li><a href="#method.reverse">reverse</a></li><li><a href="#method.rotate_left">rotate_left</a></li><li><a href="#method.rotate_right">rotate_right</a></li><li><a href="#method.rsplit">rsplit</a></li><li><a href="#method.rsplit_mut">rsplit_mut</a></li><li><a href="#method.rsplitn">rsplitn</a></li><li><a href="#method.rsplitn_mut">rsplitn_mut</a></li><li><a href="#method.set">set</a></li><li><a href="#method.set_aliased">set_aliased</a></li><li><a href="#method.set_aliased_unchecked">set_aliased_unchecked</a></li><li><a href="#method.set_unchecked">set_unchecked</a></li><li><a href="#method.shift_left">shift_left</a></li><li><a href="#method.shift_right">shift_right</a></li><li><a href="#method.some">some</a></li><li><a href="#method.split">split</a></li><li><a href="#method.split_at">split_at</a></li><li><a href="#method.split_at_mut">split_at_mut</a></li><li><a href="#method.split_at_unchecked">split_at_unchecked</a></li><li><a href="#method.split_at_unchecked_mut">split_at_unchecked_mut</a></li><li><a href="#method.split_first">split_first</a></li><li><a href="#method.split_first_mut">split_first_mut</a></li><li><a href="#method.split_inclusive">split_inclusive</a></li><li><a href="#method.split_inclusive_mut">split_inclusive_mut</a></li><li><a href="#method.split_last">split_last</a></li><li><a href="#method.split_last_mut">split_last_mut</a></li><li><a href="#method.split_mut">split_mut</a></li><li><a href="#method.splitn">splitn</a></li><li><a href="#method.splitn_mut">splitn_mut</a></li><li><a href="#method.starts_with">starts_with</a></li><li><a href="#method.strip_prefix">strip_prefix</a></li><li><a href="#method.strip_suffix">strip_suffix</a></li><li><a href="#method.swap">swap</a></li><li><a href="#method.swap_unchecked">swap_unchecked</a></li><li><a href="#method.swap_with_bitslice">swap_with_bitslice</a></li><li><a href="#method.swap_with_slice">swap_with_slice</a></li><li><a href="#method.to_bitvec">to_bitvec</a></li><li><a href="#method.to_vec">to_vec</a></li><li><a href="#method.trailing_ones">trailing_ones</a></li><li><a href="#method.trailing_zeros">trailing_zeros</a></li><li><a href="#method.windows">windows</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-AsMut%3CBitSlice%3CT%2C%20O%3E%3E">AsMut&lt;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E">AsRef&lt;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-Binary">Binary</a></li><li><a href="#impl-BitAnd%3CRhs%3E">BitAnd&lt;Rhs&gt;</a></li><li><a href="#impl-BitAndAssign%3C%26BitBox%3CT%2C%20O%3E%3E">BitAndAssign&lt;&amp;BitBox&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BitAndAssign%3CBitBox%3CT%2C%20O%3E%3E">BitAndAssign&lt;BitBox&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BitAndAssign%3CRhs%3E">BitAndAssign&lt;Rhs&gt;</a></li><li><a href="#impl-BitField">BitField</a></li><li><a href="#impl-BitOr%3CRhs%3E">BitOr&lt;Rhs&gt;</a></li><li><a href="#impl-BitOrAssign%3C%26BitBox%3CT%2C%20O%3E%3E">BitOrAssign&lt;&amp;BitBox&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BitOrAssign%3CBitBox%3CT%2C%20O%3E%3E">BitOrAssign&lt;BitBox&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BitOrAssign%3CRhs%3E">BitOrAssign&lt;Rhs&gt;</a></li><li><a href="#impl-BitXor%3CRhs%3E">BitXor&lt;Rhs&gt;</a></li><li><a href="#impl-BitXorAssign%3C%26BitBox%3CT%2C%20O%3E%3E">BitXorAssign&lt;&amp;BitBox&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BitXorAssign%3CBitBox%3CT%2C%20O%3E%3E">BitXorAssign&lt;BitBox&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BitXorAssign%3CRhs%3E">BitXorAssign&lt;Rhs&gt;</a></li><li><a href="#impl-Borrow%3CBitSlice%3CT%2C%20O%3E%3E">Borrow&lt;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-BorrowMut%3CBitSlice%3CT%2C%20O%3E%3E">BorrowMut&lt;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-Clone">Clone</a></li><li><a href="#impl-Debug">Debug</a></li><li><a href="#impl-Default">Default</a></li><li><a href="#impl-Deref">Deref</a></li><li><a href="#impl-DerefMut">DerefMut</a></li><li><a href="#impl-Display">Display</a></li><li><a href="#impl-Drop">Drop</a></li><li><a href="#impl-Eq">Eq</a></li><li><a href="#impl-From%3C%26BitSlice%3CT%2C%20O%3E%3E">From&lt;&amp;BitSlice&lt;T, O&gt;&gt;</a></li><li><a href="#impl-From%3CBitArray%3CA%2C%20O%3E%3E">From&lt;BitArray&lt;A, O&gt;&gt;</a></li><li><a href="#impl-From%3CBitBox%3CT%2C%20O%3E%3E">From&lt;BitBox&lt;T, O&gt;&gt;</a></li><li><a href="#impl-From%3CBitBox%3CT%2C%20O%3E%3E-1">From&lt;BitBox&lt;T, O&gt;&gt;</a></li><li><a href="#impl-From%3CBitVec%3CT%2C%20O%3E%3E">From&lt;BitVec&lt;T, O&gt;&gt;</a></li><li><a href="#impl-From%3CBox%3CT%2C%20Global%3E%3E">From&lt;Box&lt;T, Global&gt;&gt;</a></li><li><a href="#impl-From%3CCow%3C%27a%2C%20BitSlice%3CT%2C%20O%3E%3E%3E">From&lt;Cow&lt;&#39;a, BitSlice&lt;T, O&gt;&gt;&gt;</a></li><li><a href="#impl-FromIterator%3CI%3E">FromIterator&lt;I&gt;</a></li><li><a href="#impl-Hash">Hash</a></li><li><a href="#impl-Index%3CIdx%3E">Index&lt;Idx&gt;</a></li><li><a href="#impl-IndexMut%3CIdx%3E">IndexMut&lt;Idx&gt;</a></li><li><a href="#impl-IntoIterator">IntoIterator</a></li><li><a href="#impl-LowerHex">LowerHex</a></li><li><a href="#impl-Not">Not</a></li><li><a href="#impl-Octal">Octal</a></li><li><a href="#impl-Ord">Ord</a></li><li><a href="#impl-PartialEq%3CBitBox%3CT2%2C%20O2%3E%3E">PartialEq&lt;BitBox&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CBitBox%3CT2%2C%20O2%3E%3E-1">PartialEq&lt;BitBox&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CBitBox%3CT2%2C%20O2%3E%3E-2">PartialEq&lt;BitBox&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialEq%3CRhs%3E">PartialEq&lt;Rhs&gt;</a></li><li><a href="#impl-PartialOrd%3CBitBox%3CT2%2C%20O2%3E%3E">PartialOrd&lt;BitBox&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CBitBox%3CT2%2C%20O2%3E%3E-1">PartialOrd&lt;BitBox&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CBitBox%3CT2%2C%20O2%3E%3E-2">PartialOrd&lt;BitBox&lt;T2, O2&gt;&gt;</a></li><li><a href="#impl-PartialOrd%3CRhs%3E">PartialOrd&lt;Rhs&gt;</a></li><li><a href="#impl-Pointer">Pointer</a></li><li><a href="#impl-Send">Send</a></li><li><a href="#impl-Sync">Sync</a></li><li><a href="#impl-TryFrom%3CBox%3C%5BT%5D%2C%20Global%3E%3E">TryFrom&lt;Box&lt;[T], Global&gt;&gt;</a></li><li><a href="#impl-Unpin">Unpin</a></li><li><a href="#impl-UpperHex">UpperHex</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-UnwindSafe">UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-Conv">Conv</a></li><li><a href="#impl-FmtForward">FmtForward</a></li><li><a href="#impl-From%3CT%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a></li><li><a href="#impl-Pipe">Pipe</a></li><li><a href="#impl-Tap">Tap</a></li><li><a href="#impl-ToOwned">ToOwned</a></li><li><a href="#impl-ToString">ToString</a></li><li><a href="#impl-TryConv">TryConv</a></li><li><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></li></ul></div></section><h2 class="location"><a href="index.html">In bitvec::boxed</a></h2></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../bitvec/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><div id="settings-menu" tabindex="-1">
                                <a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div>
                        </div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Struct <a href="../index.html">bitvec</a>::<wbr><a href="index.html">boxed</a>::<wbr><a class="struct" href="#">BitBox</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/bitvec/boxed.rs.html#43-50">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code><div class="code-attribute">#[repr(transparent)]</div>pub struct BitBox&lt;T&nbsp;=&nbsp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, O&nbsp;=&nbsp;<a class="struct" href="../order/struct.Lsb0.html" title="struct bitvec::order::Lsb0">Lsb0</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span> { /* private fields */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="fixed-size-heap-allocated-bit-slice"><a href="#fixed-size-heap-allocated-bit-slice">Fixed-Size, Heap-Allocated, Bit Slice</a></h2>
<p><code>BitBox</code> is a heap-allocated <a href="../slice/struct.BitSlice.html"><code>BitSlice</code></a> region. It is a distinct type because
the implementation of bit-slice pointers means that <code>Box&lt;BitSlice&gt;</code> cannot
exist. It can be created by cloning a bit-slice into the heap, or by freezing
the allocation of a <a href="../vec/struct.BitVec.html"><code>BitVec</code></a></p>
<h3 id="original"><a href="#original">Original</a></h3>
<p><a href="https://doc.rust-lang.org/1.63.0/alloc/boxed/struct.Box.html"><code>Box&lt;[T]&gt;</code></a></p>
<h3 id="api-differences"><a href="#api-differences">API Differences</a></h3>
<p>As with <code>BitSlice</code>, this takes a pair of <a href="../order/trait.BitOrder.html"><code>BitOrder</code></a> and <a href="../store/trait.BitStore.html"><code>BitStore</code></a> type
parameters to govern the buffer’s memory representation. Because <code>BitSlice</code> is
unsized, <code>BitBox</code> has almost none of the <code>Box</code> API, and is difficult to use
directly.</p>
<h3 id="behavior"><a href="#behavior">Behavior</a></h3>
<p><code>BitBox</code>, like <code>&amp;BitSlice</code>, is an opaque pointer to a bit-addressed slice
region. Unlike <code>&amp;BitSlice</code>, it uses the allocator to guarantee that it is the
sole accessor to the referent buffer, and is able to use that uniqueness
guarantee to specialize some <code>BitSlice</code> behavior to be faster or more efficient.</p>
<h3 id="safety"><a href="#safety">Safety</a></h3>
<p><code>BitBox</code> is, essentially, a <code>NonNull&lt;BitSlice&lt;T, O&gt;&gt;</code> pointer. The internal
value is opaque and cannot be inspected or modified by user code.</p>
<p>If you attempt to do so, your program becomes inconsistent. You will likely
break the allocator’s internal state and cause a crash. No guarantees of crash
<em>or</em> recovery are provided. Do not inspect or modify the <code>BitBox</code> handle value.</p>
<h3 id="construction"><a href="#construction">Construction</a></h3>
<p>The simplest way to construct a <code>BitBox</code> is by using the <a href="../macro.bitbox.html"><code>bitbox!</code></a> macro. You
can also explicitly clone a <code>BitSlice</code> with <a href="struct.BitBox.html#method.from_bitslice"><code>BitBox::from_bitslice</code></a>, or freeze
a <code>BitVec</code> with <a href="../vec/struct.BitVec.html#method.into_boxed_bitslice"><code>BitVec::into_boxed_bitslice</code></a>.</p>
<h3 id="examples"><a href="#examples">Examples</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">BitBox::from_bitslice</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);
<span class="kw">let</span> <span class="ident">b</span> <span class="op">=</span> <span class="macro">bitbox!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="kw">let</span> <span class="ident">b_raw</span>: <span class="kw-2">*mut</span> <span class="ident">BitSlice</span> <span class="op">=</span> <span class="ident">BitBox::into_raw</span>(<span class="ident">b</span>);
<span class="kw">let</span> <span class="ident">b_reformed</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">BitBox::from_raw</span>(<span class="ident">b_raw</span>) };</code></pre></div>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><div id="implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/api.rs.html#16-139">source</a></span><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_raw" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/api.rs.html#60-64">source</a></span><a href="#method.from_raw" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.from_raw" class="fnname">from_raw</a>(raw: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.pointer.html">*mut </a><a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;) -&gt; Self</h4></section></summary><div class="docblock"><p>Constructs a bit-box from a raw bit-slice pointer.</p>
<p>This converts a <code>*mut BitSlice</code> pointer that had previously been
produced by either <a href="struct.BitBox.html#method.into_raw"><code>::into_raw()</code></a> or <a href="struct.BitBox.html#method.leak"><code>::leak()</code></a> and restores the
bit-box containing it.</p>
<h6 id="original-1"><a href="#original-1">Original</a></h6>
<p><a href="https://doc.rust-lang.org/1.63.0/alloc/boxed/struct.Box.html#method.from_raw"><code>Box::from_raw</code></a></p>
<h6 id="safety-1"><a href="#safety-1">Safety</a></h6>
<p>You must only call this function on pointers produced by leaking a prior
<code>BitBox</code>; you may not modify the value of a pointer returned by
<a href="struct.BitBox.html#method.into_raw"><code>::into_raw()</code></a>, nor may you conjure pointer values of your own. Doing
so will corrupt the allocator state.</p>
<p>You must only call this function on any given leaked pointer at most
once. Not calling it at all will merely render the allocated memory
unreachable for the duration of the program runtime, a normal (and safe)
memory leak. Calling it once restores ordinary functionality, and
ensures ordinary destruction at or before program termination. However,
calling it more than once on the same pointer will introduce data races,
use-after-free, and/or double-free errors.</p>
<h6 id="examples-1"><a href="#examples-1">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bb</span> <span class="op">=</span> <span class="macro">bitbox!</span>[<span class="number">0</span>; <span class="number">80</span>];
<span class="kw">let</span> <span class="ident">ptr</span>: <span class="kw-2">*mut</span> <span class="ident">BitSlice</span> <span class="op">=</span> <span class="ident">BitBox::into_raw</span>(<span class="ident">bb</span>);
<span class="kw">let</span> <span class="ident">bb</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">BitBox::from_raw</span>(<span class="ident">ptr</span>) };
<span class="comment">// unsafe { BitBox::from_raw(ptr) }; // UAF crash!</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_raw" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/api.rs.html#93-95">source</a></span><a href="#method.into_raw" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_raw" class="fnname">into_raw</a>(this: Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.pointer.html">*mut </a><a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</h4></section></summary><div class="docblock"><p>Consumes the bit-box, returning a raw bit-slice pointer.</p>
<p>Bit-slice pointers are always correctly encoded and non-null. The
referent region is dereferenceäble *as a <code>BitSlice</code> for the remainder of
the program, or until it is first passed to <a href="struct.BitBox.html#method.from_raw"><code>::from_raw()</code></a>, whichever
comes first. Once the pointer is first passed to <code>::from_raw()</code>, all
copies of that pointer become invalid to dereference.</p>
<h6 id="original-2"><a href="#original-2">Original</a></h6>
<p><a href="https://doc.rust-lang.org/1.63.0/alloc/boxed/struct.Box.html#method.into_raw"><code>Box::into_raw</code></a></p>
<h6 id="examples-2"><a href="#examples-2">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bb</span> <span class="op">=</span> <span class="macro">bitbox!</span>[<span class="number">0</span>; <span class="number">80</span>];
<span class="kw">let</span> <span class="ident">ptr</span> <span class="op">=</span> <span class="ident">BitBox::into_raw</span>(<span class="ident">bb</span>);
<span class="kw">let</span> <span class="ident">bb</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">BitBox::from_raw</span>(<span class="ident">ptr</span>) };</code></pre></div>
<p>You <strong>may not</strong> deällocate pointers produced by this function through
any other means.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.leak" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/api.rs.html#127-130">source</a></span><a href="#method.leak" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.leak" class="fnname">leak</a>&lt;'a&gt;(this: Self) -&gt; &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a,&nbsp;</span></h4></section></summary><div class="docblock"><p>Deliberately leaks the allocated memory, returning an
<code>&amp;'static mut BitSlice</code> reference.</p>
<p>This differs from <a href="struct.BitBox.html#method.into_raw"><code>::into_raw()</code></a> in that the reference is safe to use
and can be tracked by the Rust borrow-checking system. Like the
bit-slice pointer produced by <code>::into_raw()</code>, this reference can be
un-leaked by passing it into <a href="struct.BitBox.html#method.from_raw"><code>::from_raw()</code></a> to reclaim the memory.</p>
<h6 id="original-3"><a href="#original-3">Original</a></h6>
<p><a href="https://doc.rust-lang.org/1.63.0/alloc/boxed/struct.Box.html#method.leak"><code>Box::leak</code></a></p>
<h6 id="examples-3"><a href="#examples-3">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bb</span> <span class="op">=</span> <span class="macro">bitbox!</span>[<span class="number">0</span>; <span class="number">80</span>];
<span class="kw">let</span> <span class="ident">static_ref</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="kw-2">mut</span> <span class="ident">BitSlice</span> <span class="op">=</span> <span class="ident">BitBox::leak</span>(<span class="ident">bb</span>);

<span class="ident">static_ref</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
<span class="macro">assert!</span>(<span class="ident">static_ref</span>[<span class="number">0</span>]);
<span class="kw">let</span> <span class="kw">_</span> <span class="op">=</span> <span class="kw">unsafe</span> {
  <span class="ident">BitBox::from_raw</span>(<span class="ident">static_ref</span>)
};</code></pre></div>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed.rs.html#52-365">source</a></span><a href="#impl-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_bitslice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed.rs.html#88-90">source</a></span><a href="#method.from_bitslice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.from_bitslice" class="fnname">from_bitslice</a>(slice: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;) -&gt; Self</h4></section></summary><div class="docblock"><p>Copies a bit-slice region into a new bit-box allocation.</p>
<p>The referent memory is <code>memcpy</code>d into the heap, exactly preserving the
original bit-slice’s memory layout and contents. This allows the
function to run as fast as possible, but misaligned source bit-slices
may result in decreased performance or unexpected layout behavior during
use. You can use <a href="struct.BitBox.html#method.force_align"><code>.force_align()</code></a> to ensure that the referent
bit-slice is aligned in memory.</p>
<h6 id="notes"><a href="#notes">Notes</a></h6>
<p>Bits in the allocation of the source bit-slice, but outside its own
description of that memory, have an <strong>unspecified</strong>, but initialized,
value. You may not rely on their contents in any way, and you <em>should</em>
call <a href="struct.BitBox.html#method.force_align"><code>.force_align()</code></a> and/or <a href="struct.BitBox.html#method.fill_uninitialized"><code>.fill_uninitialized()</code></a> if you are
going to inspect the underlying memory of the new allocation.</p>
<h6 id="examples-4"><a href="#examples-4">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b0101_1011u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">bb</span> <span class="op">=</span> <span class="ident">BitBox::from_bitslice</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">2</span> ..]);
<span class="macro">assert_eq!</span>(<span class="ident">bb</span>, <span class="ident">bits</span>[<span class="number">2</span> ..]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_boxed_slice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed.rs.html#114-117">source</a></span><a href="#method.from_boxed_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.from_boxed_slice" class="fnname">from_boxed_slice</a>(boxed: <a class="struct" href="https://doc.rust-lang.org/1.63.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.slice.html">[T]</a>&gt;) -&gt; Self</h4></section></summary><div class="docblock"><p>Converts a <code>Box&lt;[T]&gt;</code> into a <code>BitBox&lt;T, O&gt;</code>, in place.</p>
<p>This does not affect the referent buffer, and only transforms the
handle.</p>
<h6 id="panics"><a href="#panics">Panics</a></h6>
<p>This panics if the provided <code>boxed</code> slice is too long to view as a
bit-slice region.</p>
<h6 id="examples-5"><a href="#examples-5">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">boxed</span>: <span class="ident">Box</span><span class="op">&lt;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Box::new</span>([<span class="number">0</span>; <span class="number">40</span>]);
<span class="kw">let</span> <span class="ident">addr</span> <span class="op">=</span> <span class="ident">boxed</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">bb</span> <span class="op">=</span> <span class="ident">BitBox</span>::<span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span><span class="ident">::from_boxed_slice</span>(<span class="ident">boxed</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bb</span>, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">320</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">addr</span>, <span class="ident">bb</span>.<span class="ident">as_raw_slice</span>().<span class="ident">as_ptr</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from_boxed_slice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed.rs.html#144-151">source</a></span><a href="#method.try_from_boxed_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.try_from_boxed_slice" class="fnname">try_from_boxed_slice</a>(boxed: <a class="struct" href="https://doc.rust-lang.org/1.63.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.slice.html">[T]</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, <a class="struct" href="https://doc.rust-lang.org/1.63.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.slice.html">[T]</a>&gt;&gt;</h4></section></summary><div class="docblock"><p>Attempts to convert an ordinary boxed slice into a boxed bit-slice.</p>
<p>This does not perform a copy or reällocation; it only attempts to
transform the handle. Because <code>Box&lt;[T]&gt;</code> can be longer than <code>BitBox</code>es,
it may fail, and will return the original handle if it does.</p>
<p>It is unlikely that you have a single <code>Box&lt;[_]&gt;</code> that is too large to
convert into a bit-box. You can find the length restrictions as the
bit-slice associated constants <a href="../slice/struct.BitSlice.html#associatedconstant.MAX_BITS"><code>MAX_BITS</code></a> and <a href="../slice/struct.BitSlice.html#associatedconstant.MAX_ELTS"><code>MAX_ELTS</code></a>.</p>
<h6 id="examples-6"><a href="#examples-6">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">boxed</span>: <span class="ident">Box</span><span class="op">&lt;</span>[<span class="ident">u8</span>]<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Box::new</span>([<span class="number">0u8</span>; <span class="number">40</span>]);
<span class="kw">let</span> <span class="ident">addr</span> <span class="op">=</span> <span class="ident">boxed</span>.<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">bb</span> <span class="op">=</span> <span class="ident">BitBox</span>::<span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span><span class="ident">::try_from_boxed_slice</span>(<span class="ident">boxed</span>).<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">bb</span>, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">320</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">addr</span>, <span class="ident">bb</span>.<span class="ident">as_raw_slice</span>().<span class="ident">as_ptr</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_boxed_slice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed.rs.html#170-174">source</a></span><a href="#method.into_boxed_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_boxed_slice" class="fnname">into_boxed_slice</a>(self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.63.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.slice.html">[T]</a>&gt;</h4></section></summary><div class="docblock"><p>Converts the bit-box back into an ordinary boxed element slice.</p>
<p>This does not touch the allocator or the buffer contents; it is purely a
handle transform.</p>
<h6 id="examples-7"><a href="#examples-7">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bb</span> <span class="op">=</span> <span class="macro">bitbox!</span>[<span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let</span> <span class="ident">addr</span> <span class="op">=</span> <span class="ident">bb</span>.<span class="ident">as_raw_slice</span>().<span class="ident">as_ptr</span>();
<span class="kw">let</span> <span class="ident">boxed</span> <span class="op">=</span> <span class="ident">bb</span>.<span class="ident">into_boxed_slice</span>();
<span class="macro">assert_eq!</span>(<span class="ident">boxed</span>[..], [<span class="number">0</span>][..]);
<span class="macro">assert_eq!</span>(<span class="ident">addr</span>, <span class="ident">boxed</span>.<span class="ident">as_ptr</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_bitvec" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed.rs.html#208-226">source</a></span><a href="#method.into_bitvec" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.into_bitvec" class="fnname">into_bitvec</a>(self) -&gt; <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Converts the bit-box into a bit-vector.</p>
<p>This uses the Rust allocator API, and does not guarantee whether or not
a reällocation occurs internally.</p>
<p>The resulting bit-vector can be converted back into a bit-box via
<a href="../vec/struct.BitVec.html#method.into_boxed_bitslice"><code>BitBox::into_boxed_bitslice</code></a>.</p>
<h6 id="original-4"><a href="#original-4">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.into_vec"><code>slice::into_vec</code></a></p>
<h6 id="api-differences-1"><a href="#api-differences-1">API Differences</a></h6>
<p>The original function is implemented in an <code>impl&lt;T&gt; [T]</code> block, despite
taking a <code>Box&lt;[T]&gt;</code> receiver. Since <code>BitBox</code> cannot be used as an
explicit receiver outside its own <code>impl</code> blocks, the method is relocated
here.</p>
<h6 id="examples-8"><a href="#examples-8">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bb</span> <span class="op">=</span> <span class="macro">bitbox!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="ident">bb</span>.<span class="ident">into_bitvec</span>();

<span class="macro">assert_eq!</span>(<span class="ident">bv</span>, <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_bitslice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed.rs.html#230-232">source</a></span><a href="#method.as_bitslice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_bitslice" class="fnname">as_bitslice</a>(&amp;self) -&gt; &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Explicitly views the bit-box as a bit-slice.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_bitslice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed.rs.html#236-238">source</a></span><a href="#method.as_mut_bitslice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_mut_bitslice" class="fnname">as_mut_bitslice</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Explicitly views the bit-box as a mutable bit-slice.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_raw_slice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed.rs.html#245-249">source</a></span><a href="#method.as_raw_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_raw_slice" class="fnname">as_raw_slice</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.slice.html">[T]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.u8.html">u8</a>]</span><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.u8.html">u8</a>]</span><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.u8.html">u8</a>]</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Views the bit-box as a slice of its underlying memory elements.</p>
<p>Because bit-boxes uniquely own their buffer, they can safely view the
underlying buffer without dealing with contending neighbors.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_raw_mut_slice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed.rs.html#256-260">source</a></span><a href="#method.as_raw_mut_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_raw_mut_slice" class="fnname">as_raw_mut_slice</a>(&amp;mut self) -&gt; &amp;mut <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.slice.html">[T]</a><span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.u8.html">u8</a>]</span><code class="content"><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;[<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.u8.html">u8</a>]</span><span class="where fmt-newline">impl&lt;'_&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.u8.html">u8</a>]</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Views the bit-box as a mutable slice of its underlying memory elements.</p>
<p>Because bit-boxes uniquely own their buffer, they can safely view the
underlying buffer without dealing with contending neighbors.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fill_uninitialized" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed.rs.html#294-303">source</a></span><a href="#method.fill_uninitialized" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.fill_uninitialized" class="fnname">fill_uninitialized</a>(&amp;mut self, value: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Sets the unused bits outside the <code>BitBox</code> buffer to a fixed value.</p>
<p>This method modifies all bits that the allocated buffer owns but which
are outside the <code>self.as_bitslice()</code> view. <code>bitvec</code> guarantees that all
owned bits are initialized to <em>some</em> value, but does not guarantee
<em>which</em> value. This method can be used to make all such unused bits have
a known value after the call, so that viewing the underlying memory
directly has consistent results.</p>
<p>Note that the crate implementation guarantees that all bits owned by its
handles are stably initialized according to the language and compiler
rules! <code>bitvec</code> will never cause UB by using uninitialized memory.</p>
<h6 id="examples-9"><a href="#examples-9">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="number">0b1011_0101u8</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bb</span> <span class="op">=</span> <span class="ident">BitBox::from_bitslice</span>(<span class="kw-2">&amp;</span><span class="ident">bits</span>[<span class="number">2</span> .. <span class="number">6</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">bb</span>.<span class="ident">count_ones</span>(), <span class="number">3</span>);
<span class="comment">// Remember, the two bits on each edge are unspecified, and cannot be</span>
<span class="comment">// observed! They must be masked away for the test to be meaningful.</span>
<span class="macro">assert_eq!</span>(<span class="ident">bb</span>.<span class="ident">as_raw_slice</span>()[<span class="number">0</span>] <span class="op">&amp;</span> <span class="number">0x3C</span>, <span class="number">0b00_1101_00u8</span>);

<span class="ident">bb</span>.<span class="ident">fill_uninitialized</span>(<span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bb</span>.<span class="ident">as_raw_slice</span>(), <span class="kw-2">&amp;</span>[<span class="number">0b00_1101_00u8</span>]);

<span class="ident">bb</span>.<span class="ident">fill_uninitialized</span>(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bb</span>.<span class="ident">as_raw_slice</span>(), <span class="kw-2">&amp;</span>[<span class="number">0b11_1101_11u8</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.force_align" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed.rs.html#338-349">source</a></span><a href="#method.force_align" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.force_align" class="fnname">force_align</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Ensures that the allocated buffer has no dead bits between the start of
the buffer and the start of the live bit-slice.</p>
<p>This is useful for ensuring a consistent memory layout in bit-boxes
created by cloning an arbitrary bit-slice into the heap. As bit-slices
can begin and end anywhere in memory, the <a href="struct.BitBox.html#method.from_bitslice"><code>::from_bitslice()</code></a> function
does not attempt to normalize them and only does a fast element-wise
copy when creating the bit-box.</p>
<p>The value of dead bits that are in the allocation but not in the live
region are <em>initialized</em>, but do not have a <em>specified</em> value. After
calling this method, you should use <a href="struct.BitBox.html#method.fill_uninitialized"><code>.fill_uninitialized()</code></a> to set the
excess bits in the buffer to a fixed value.</p>
<h6 id="examples-10"><a href="#examples-10">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="number">0b10_1101_01u8</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>()[<span class="number">2</span> .. <span class="number">6</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bb</span> <span class="op">=</span> <span class="ident">BitBox::from_bitslice</span>(<span class="ident">bits</span>);
<span class="comment">// Remember, the two bits on each edge are unspecified, and cannot be</span>
<span class="comment">// observed! They must be masked away for the test to be meaningful.</span>
<span class="macro">assert_eq!</span>(<span class="ident">bb</span>.<span class="ident">as_raw_slice</span>()[<span class="number">0</span>] <span class="op">&amp;</span> <span class="number">0x3C</span>, <span class="number">0b00_1101_00u8</span>);

<span class="ident">bb</span>.<span class="ident">force_align</span>();
<span class="ident">bb</span>.<span class="ident">fill_uninitialized</span>(<span class="bool-val">false</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bb</span>.<span class="ident">as_raw_slice</span>(), <span class="kw-2">&amp;</span>[<span class="number">0b1101_0000u8</span>]);</code></pre></div>
</div></details></div></details></div><h2 id="deref-methods-BitSlice%3CT%2C%20O%3E" class="small-section-header"><span>Methods from <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt;</span><a href="#deref-methods-BitSlice%3CT%2C%20O%3E" class="anchor"></a></h2><div id="deref-methods-BitSlice%3CT%2C%20O%3E-1"><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.len" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#87-89">source</a></span><a href="#method.len" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.len" class="fnname">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Gets the number of bits in the bit-slice.</p>
<h6 id="original-5"><a href="#original-5">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.len"><code>slice::len</code></a></p>
<h6 id="examples-11"><a href="#examples-11">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].<span class="ident">len</span>(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">10</span>].<span class="ident">len</span>(), <span class="number">10</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.is_empty" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#106-108">source</a></span><a href="#method.is_empty" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.is_empty" class="fnname">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if the bit-slice is empty (length zero).</p>
<h6 id="original-6"><a href="#original-6">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.is_empty"><code>slice::is_empty</code></a></p>
<h6 id="examples-12"><a href="#examples-12">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].<span class="ident">is_empty</span>());
<span class="macro">assert!</span>(<span class="op">!</span><span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">10</span>].<span class="ident">is_empty</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.first" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#133-135">source</a></span><a href="#method.first" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.first" class="fnname">first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../ptr/struct.BitRef.html" title="struct bitvec::ptr::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Gets a reference to the first bit of the bit-slice, or <code>None</code> if it is
empty.</p>
<h6 id="original-7"><a href="#original-7">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.first"><code>slice::first</code></a></p>
<h6 id="api-differences-2"><a href="#api-differences-2">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>.</p>
<h6 id="examples-13"><a href="#examples-13">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>.<span class="ident">first</span>().<span class="ident">as_deref</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].<span class="ident">first</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.first_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#164-166">source</a></span><a href="#method.first_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.first_mut" class="fnname">first_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../ptr/struct.BitRef.html" title="struct bitvec::ptr::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Gets a mutable reference to the first bit of the bit-slice, or <code>None</code> if
it is empty.</p>
<h6 id="original-8"><a href="#original-8">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.first_mut"><code>slice::first_mut</code></a></p>
<h6 id="api-differences-3"><a href="#api-differences-3">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>. This must be bound as <code>mut</code> in order to write
through it.</p>
<h6 id="examples-14"><a href="#examples-14">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>; <span class="number">3</span>];
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">mut</span> <span class="ident">first</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">first_mut</span>() {
  <span class="kw-2">*</span><span class="ident">first</span> <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);

<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="kw-2">mut</span>].<span class="ident">first_mut</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_first" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#191-199">source</a></span><a href="#method.split_first" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_first" class="fnname">split_first</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../ptr/struct.BitRef.html" title="struct bitvec::ptr::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Self)&gt;</h4></section></summary><div class="docblock"><p>Splits the bit-slice into a reference to its first bit, and the rest of
the bit-slice. Returns <code>None</code> when empty.</p>
<h6 id="original-9"><a href="#original-9">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_first"><code>slice::split_first</code></a></p>
<h6 id="api-differences-4"><a href="#api-differences-4">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>.</p>
<h6 id="examples-15"><a href="#examples-15">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let</span> (<span class="ident">first</span>, <span class="ident">rest</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_first</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">first</span>, <span class="kw-2">&amp;</span><span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(<span class="ident">rest</span>, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_first_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#227-237">source</a></span><a href="#method.split_first_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_first_mut" class="fnname">split_first_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../ptr/struct.BitRef.html" title="struct bitvec::ptr::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;, &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;)&gt;</h4></section></summary><div class="docblock"><p>Splits the bit-slice into mutable references of its first bit, and the
rest of the bit-slice. Returns <code>None</code> when empty.</p>
<h6 id="original-10"><a href="#original-10">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_first_mut"><code>slice::split_first_mut</code></a></p>
<h6 id="api-differences-5"><a href="#api-differences-5">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>. This must be bound as <code>mut</code> in order to write
through it.</p>
<h6 id="examples-16"><a href="#examples-16">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>; <span class="number">3</span>];
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="kw-2">mut</span> <span class="ident">first</span>, <span class="ident">rest</span>)) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_first_mut</span>() {
  <span class="kw-2">*</span><span class="ident">first</span> <span class="op">=</span> <span class="bool-val">true</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">rest</span>, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
}
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_last" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#262-270">source</a></span><a href="#method.split_last" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_last" class="fnname">split_last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../ptr/struct.BitRef.html" title="struct bitvec::ptr::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Self)&gt;</h4></section></summary><div class="docblock"><p>Splits the bit-slice into a reference to its last bit, and the rest of
the bit-slice. Returns <code>None</code> when empty.</p>
<h6 id="original-11"><a href="#original-11">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_last"><code>slice::split_last</code></a></p>
<h6 id="api-differences-6"><a href="#api-differences-6">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>.</p>
<h6 id="examples-17"><a href="#examples-17">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> (<span class="ident">last</span>, <span class="ident">rest</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_last</span>().<span class="ident">unwrap</span>();
<span class="macro">assert_eq!</span>(<span class="ident">last</span>, <span class="kw-2">&amp;</span><span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(<span class="ident">rest</span>, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_last_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#298-308">source</a></span><a href="#method.split_last_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_last_mut" class="fnname">split_last_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;(<a class="struct" href="../ptr/struct.BitRef.html" title="struct bitvec::ptr::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;, &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;)&gt;</h4></section></summary><div class="docblock"><p>Splits the bit-slice into mutable references to its last bit, and the
rest of the bit-slice. Returns <code>None</code> when empty.</p>
<h6 id="original-12"><a href="#original-12">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_last_mut"><code>slice::split_last_mut</code></a></p>
<h6 id="api-differences-7"><a href="#api-differences-7">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>. This must be bound as <code>mut</code> in order to write
through it.</p>
<h6 id="examples-18"><a href="#examples-18">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>; <span class="number">3</span>];
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>((<span class="kw-2">mut</span> <span class="ident">last</span>, <span class="ident">rest</span>)) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_last_mut</span>() {
  <span class="kw-2">*</span><span class="ident">last</span> <span class="op">=</span> <span class="bool-val">true</span>;
  <span class="macro">assert_eq!</span>(<span class="ident">rest</span>, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
}
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.last" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#333-338">source</a></span><a href="#method.last" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.last" class="fnname">last</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../ptr/struct.BitRef.html" title="struct bitvec::ptr::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Gets a reference to the last bit of the bit-slice, or <code>None</code> if it is
empty.</p>
<h6 id="original-13"><a href="#original-13">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.last"><code>slice::last</code></a></p>
<h6 id="api-differences-8"><a href="#api-differences-8">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>.</p>
<h6 id="examples-19"><a href="#examples-19">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>.<span class="ident">last</span>().<span class="ident">as_deref</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].<span class="ident">last</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.last_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#367-372">source</a></span><a href="#method.last_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.last_mut" class="fnname">last_mut</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="../ptr/struct.BitRef.html" title="struct bitvec::ptr::BitRef">BitRef</a>&lt;'_, <a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Gets a mutable reference to the last bit of the bit-slice, or <code>None</code> if
it is empty.</p>
<h6 id="original-14"><a href="#original-14">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.last_mut"><code>slice::last_mut</code></a></p>
<h6 id="api-differences-9"><a href="#api-differences-9">API Differences</a></h6>
<p><code>bitvec</code> uses a custom structure for both read-only and mutable
references to <code>bool</code>. This must be bound as <code>mut</code> in order to write
through it.</p>
<h6 id="examples-20"><a href="#examples-20">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>; <span class="number">3</span>];
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="kw-2">mut</span> <span class="ident">last</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">last_mut</span>() {
  <span class="kw-2">*</span><span class="ident">last</span> <span class="op">=</span> <span class="bool-val">true</span>;
}
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);

<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="kw-2">mut</span>].<span class="ident">last_mut</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#404-407">source</a></span><a href="#method.get" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get" class="fnname">get</a>&lt;'a, I&gt;(&amp;'a self, index: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;I::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, T, O&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Gets a reference to a single bit or a subsection of the bit-slice,
depending on the type of <code>index</code>.</p>
<ul>
<li>If given a <code>usize</code>, this produces a reference structure to the <code>bool</code>
at the position.</li>
<li>If given any form of range, this produces a smaller bit-slice.</li>
</ul>
<p>This returns <code>None</code> if the <code>index</code> departs the bounds of <code>self</code>.</p>
<h6 id="original-15"><a href="#original-15">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get"><code>slice::get</code></a></p>
<h6 id="api-differences-10"><a href="#api-differences-10">API Differences</a></h6>
<p><code>BitSliceIndex</code> uses discrete types for immutable and mutable
references, rather than a single referent type.</p>
<h6 id="examples-21"><a href="#examples-21">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">1</span>).<span class="ident">as_deref</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="bool-val">true</span>));
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">0</span> .. <span class="number">2</span>), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert!</span>(<span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">3</span>).<span class="ident">is_none</span>());
<span class="macro">assert!</span>(<span class="ident">bits</span>.<span class="ident">get</span>(<span class="number">0</span> .. <span class="number">4</span>).<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#439-442">source</a></span><a href="#method.get_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_mut" class="fnname">get_mut</a>&lt;'a, I&gt;(&amp;'a mut self, index: I) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;I::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, T, O&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Gets a mutable reference to a single bit or a subsection of the
bit-slice, depending on the type of <code>index</code>.</p>
<ul>
<li>If given a <code>usize</code>, this produces a reference structure to the <code>bool</code>
at the position.</li>
<li>If given any form of range, this produces a smaller bit-slice.</li>
</ul>
<p>This returns <code>None</code> if the <code>index</code> departs the bounds of <code>self</code>.</p>
<h6 id="original-16"><a href="#original-16">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_mut"><code>slice::get_mut</code></a></p>
<h6 id="api-differences-11"><a href="#api-differences-11">API Differences</a></h6>
<p><code>BitSliceIndex</code> uses discrete types for immutable and mutable
references, rather than a single referent type.</p>
<h6 id="examples-22"><a href="#examples-22">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>; <span class="number">3</span>];

<span class="kw-2">*</span><span class="ident">bits</span>.<span class="ident">get_mut</span>(<span class="number">0</span>).<span class="ident">unwrap</span>() <span class="op">=</span> <span class="bool-val">true</span>;
<span class="ident">bits</span>.<span class="ident">get_mut</span>(<span class="number">1</span> ..).<span class="ident">unwrap</span>().<span class="ident">fill</span>(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">3</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#480-483">source</a></span><a href="#method.get_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked" class="fnname">get_unchecked</a>&lt;'a, I&gt;(&amp;'a self, index: I) -&gt; I::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, T, O&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Gets a reference to a single bit or to a subsection of the bit-slice,
without bounds checking.</p>
<p>This has the same arguments and behavior as <a href="../slice/struct.BitSlice.html#method.get"><code>.get()</code></a>, except that it
does not check that <code>index</code> is in bounds.</p>
<h6 id="original-17"><a href="#original-17">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked"><code>slice::get_unchecked</code></a></p>
<h6 id="safety-2"><a href="#safety-2">Safety</a></h6>
<p>You must ensure that <code>index</code> is within bounds (within the range <code>0 .. self.len()</code>), or this method will introduce memory safety and/or
undefined behavior.</p>
<p>It is library-level undefined behavior to index beyond the length of any
bit-slice, even if you <strong>know</strong> that the offset remains within an
allocation as measured by Rust or LLVM.</p>
<h6 id="examples-23"><a href="#examples-23">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b0001_0010u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()[.. <span class="number">3</span>];

<span class="kw">unsafe</span> {
  <span class="macro">assert!</span>(<span class="ident">bits</span>.<span class="ident">get_unchecked</span>(<span class="number">1</span>));
  <span class="macro">assert!</span>(<span class="ident">bits</span>.<span class="ident">get_unchecked</span>(<span class="number">4</span>));
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_unchecked_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#522-525">source</a></span><a href="#method.get_unchecked_mut" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked_mut" class="fnname">get_unchecked_mut</a>&lt;'a, I&gt;(&amp;'a mut self, index: I) -&gt; I::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, T, O&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Gets a mutable reference to a single bit or a subsection of the
bit-slice, depending on the type of <code>index</code>.</p>
<p>This has the same arguments and behavior as <a href="../slice/struct.BitSlice.html#method.get_mut"><code>.get_mut()</code></a>, except that
it does not check that <code>index</code> is in bounds.</p>
<h6 id="original-18"><a href="#original-18">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked_mut"><code>slice::get_unchecked_mut</code></a></p>
<h6 id="safety-3"><a href="#safety-3">Safety</a></h6>
<p>You must ensure that <code>index</code> is within bounds (within the range <code>0 .. self.len()</code>), or this method will introduce memory safety and/or
undefined behavior.</p>
<p>It is library-level undefined behavior to index beyond the length of any
bit-slice, even if you <strong>know</strong> that the offset remains within an
allocation as measured by Rust or LLVM.</p>
<h6 id="examples-24"><a href="#examples-24">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()[.. <span class="number">3</span>];

<span class="kw">unsafe</span> {
  <span class="ident">bits</span>.<span class="ident">get_unchecked_mut</span>(<span class="number">1</span>).<span class="ident">commit</span>(<span class="bool-val">true</span>);
  <span class="ident">bits</span>.<span class="ident">get_unchecked_mut</span>(<span class="number">4</span> .. <span class="number">6</span>).<span class="ident">fill</span>(<span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0b0011_0010</span>);</code></pre></div>
</div></details><section id="method.as_ptr" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#531-533">source</a></span><a href="#method.as_ptr" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_ptr" class="fnname">as_ptr</a>(&amp;self) -&gt; <a class="struct" href="../ptr/struct.BitPtr.html" title="struct bitvec::ptr::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span> Deprecated: <p>use <code>.as_bitptr()</code> instead</p>
</div></span><section id="method.as_mut_ptr" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#539-541">source</a></span><a href="#method.as_mut_ptr" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_mut_ptr" class="fnname">as_mut_ptr</a>(&amp;mut self) -&gt; <a class="struct" href="../ptr/struct.BitPtr.html" title="struct bitvec::ptr::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T, O&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span> Deprecated: <p>use <code>.as_mut_bitptr()</code> instead</p>
</div></span><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ptr_range" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#557-559">source</a></span><a href="#method.as_ptr_range" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_ptr_range" class="fnname">as_ptr_range</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.63.0/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="struct" href="../ptr/struct.BitPtr.html" title="struct bitvec::ptr::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Produces a range of bit-pointers to each bit in the bit-slice.</p>
<p>This is a standard-library range, which has no real functionality for
pointer types. You should prefer <a href="../slice/struct.BitSlice.html#method.as_bitptr_range"><code>.as_bitptr_range()</code></a> instead, as it
produces a custom structure that provides expected ranging
functionality.</p>
<h6 id="original-19"><a href="#original-19">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr_range"><code>slice::as_ptr_range</code></a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_ptr_range" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#575-577">source</a></span><a href="#method.as_mut_ptr_range" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_mut_ptr_range" class="fnname">as_mut_ptr_range</a>(&amp;mut self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.63.0/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="struct" href="../ptr/struct.BitPtr.html" title="struct bitvec::ptr::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T, O&gt;&gt;</h4></section></summary><div class="docblock"><p>Produces a range of mutable bit-pointers to each bit in the bit-slice.</p>
<p>This is a standard-library range, which has no real functionality for
pointer types. You should prefer <a href="../slice/struct.BitSlice.html#method.as_mut_bitptr_range"><code>.as_mut_bitptr_range()</code></a> instead, as
it produces a custom structure that provides expected ranging
functionality.</p>
<h6 id="original-20"><a href="#original-20">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_mut_ptr_range"><code>slice::as_mut_ptr_range</code></a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.swap" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#599-606">source</a></span><a href="#method.swap" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.swap" class="fnname">swap</a>(&amp;mut self, a: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, b: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Exchanges the bit values at two indices.</p>
<h6 id="original-21"><a href="#original-21">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.swap"><code>slice::swap</code></a></p>
<h6 id="panics-1"><a href="#panics-1">Panics</a></h6>
<p>This panics if either <code>a</code> or <code>b</code> are out of bounds.</p>
<h6 id="examples-25"><a href="#examples-25">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">1</span>];
<span class="ident">bits</span>.<span class="ident">swap</span>(<span class="number">0</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.reverse" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#624-631">source</a></span><a href="#method.reverse" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.reverse" class="fnname">reverse</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Reverses the order of bits in a bit-slice.</p>
<h6 id="original-22"><a href="#original-22">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.reverse"><code>slice::reverse</code></a></p>
<h6 id="examples-26"><a href="#examples-26">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="ident">bits</span>.<span class="ident">reverse</span>();
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.iter" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#666-668">source</a></span><a href="#method.iter" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.iter" class="fnname">iter</a>(&amp;self) -&gt; <a class="struct" href="../slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.Iter.html" title="struct bitvec::slice::Iter">Iter</a>&lt;'a, T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a> as <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, T, O&gt;&gt;::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Immut" title="type bitvec::slice::BitSliceIndex::Immut">Immut</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Produces an iterator over each bit in the bit-slice.</p>
<h6 id="original-23"><a href="#original-23">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.iter"><code>slice::iter</code></a></p>
<h6 id="api-differences-12"><a href="#api-differences-12">API Differences</a></h6>
<p>This iterator yields proxy-reference structures, not <code>&amp;bool</code>. It can be
adapted to yield <code>&amp;bool</code> with the <a href="../slice/struct.Iter.html#method.by_refs"><code>.by_refs()</code></a> method, or <code>bool</code> with
<a href="../slice/struct.Iter.html#method.by_vals"><code>.by_vals()</code></a>.</p>
<p>This iterator, and its adapters, are fast. Do not try to be more clever
than them by abusing <code>.as_bitptr_range()</code>.</p>
<h6 id="examples-27"><a href="#examples-27">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">iter</span>();

<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>());
<span class="macro">assert!</span>( <span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>());
<span class="macro">assert!</span>( <span class="ident">iter</span>.<span class="ident">next_back</span>().<span class="ident">unwrap</span>());
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">iter</span>.<span class="ident">next_back</span>().<span class="ident">unwrap</span>());
<span class="macro">assert!</span>( <span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.iter_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#706-708">source</a></span><a href="#method.iter_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.iter_mut" class="fnname">iter_mut</a>(&amp;mut self) -&gt; <a class="struct" href="../slice/struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.IterMut.html" title="struct bitvec::slice::IterMut">IterMut</a>&lt;'a, T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a> as <a class="trait" href="../slice/trait.BitSliceIndex.html" title="trait bitvec::slice::BitSliceIndex">BitSliceIndex</a>&lt;'a, T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;&gt;::<a class="associatedtype" href="../slice/trait.BitSliceIndex.html#associatedtype.Mut" title="type bitvec::slice::BitSliceIndex::Mut">Mut</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Produces a mutable iterator over each bit in the bit-slice.</p>
<h6 id="original-24"><a href="#original-24">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.iter_mut"><code>slice::iter_mut</code></a></p>
<h6 id="api-differences-13"><a href="#api-differences-13">API Differences</a></h6>
<p>This iterator yields proxy-reference structures, not <code>&amp;mut bool</code>. In
addition, it marks each proxy as alias-tainted.</p>
<p>If you are using this in an ordinary loop and <strong>not</strong> keeping multiple
yielded proxy-references alive at the same scope, you may use the
<a href="../slice/struct.IterMut.html#method.remove_alias"><code>.remove_alias()</code></a> adapter to undo the alias marking.</p>
<p>This iterator is fast. Do not try to be more clever than it by abusing
<code>.as_mut_bitptr_range()</code>.</p>
<h6 id="examples-28"><a href="#examples-28">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>; <span class="number">4</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">iter_mut</span>();

<span class="ident">iter</span>.<span class="ident">nth</span>(<span class="number">1</span>).<span class="ident">unwrap</span>().<span class="ident">commit</span>(<span class="bool-val">true</span>); <span class="comment">// index 1</span>
<span class="ident">iter</span>.<span class="ident">next_back</span>().<span class="ident">unwrap</span>().<span class="ident">commit</span>(<span class="bool-val">true</span>); <span class="comment">// index 3</span>

<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_some</span>()); <span class="comment">// index 2</span>
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>()); <span class="comment">// complete</span>
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.windows" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#738-740">source</a></span><a href="#method.windows" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.windows" class="fnname">windows</a>(&amp;self, size: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.Windows.html" title="struct bitvec::slice::Windows">Windows</a>&lt;'a, T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Iterates over consecutive windowing subslices in a bit-slice.</p>
<p>Windows are overlapping views of the bit-slice. Each window advances one
bit from the previous, so in a bit-slice <code>[A, B, C, D, E]</code>, calling
<code>.windows(3)</code> will yield <code>[A, B, C]</code>, <code>[B, C, D]</code>, and <code>[C, D, E]</code>.</p>
<h6 id="original-25"><a href="#original-25">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.windows"><code>slice::windows</code></a></p>
<h6 id="panics-2"><a href="#panics-2">Panics</a></h6>
<p>This panics if <code>size</code> is <code>0</code>.</p>
<h6 id="examples-29"><a href="#examples-29">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">windows</span>(<span class="number">3</span>);

<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]));
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.chunks" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#783-785">source</a></span><a href="#method.chunks" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.chunks" class="fnname">chunks</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.Chunks.html" title="struct bitvec::slice::Chunks">Chunks</a>&lt;'a, T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Iterates over non-overlapping subslices of a bit-slice.</p>
<p>Unlike <code>.windows()</code>, the subslices this yields do not overlap with each
other. If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the
last chunk yielded will be shorter.</p>
<h6 id="original-26"><a href="#original-26">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks"><code>slice::chunks</code></a></p>
<h6 id="sibling-methods"><a href="#sibling-methods">Sibling Methods</a></h6>
<ul>
<li><a href="../slice/struct.BitSlice.html#method.chunks_mut"><code>.chunks_mut()</code></a> has the same division logic, but each yielded
bit-slice is mutable.</li>
<li><a href="../slice/struct.BitSlice.html#method.chunks_exact"><code>.chunks_exact()</code></a> does not yield the final chunk if it is shorter
than <code>chunk_size</code>.</li>
<li><a href="../slice/struct.BitSlice.html#method.rchunks"><code>.rchunks()</code></a> iterates from the back of the bit-slice to the front,
with the final, possibly-shorter, segment at the front edge.</li>
</ul>
<h6 id="panics-3"><a href="#panics-3">Panics</a></h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-30"><a href="#examples-30">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">chunks</span>(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]));
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">1</span>]));
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.chunks_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#834-836">source</a></span><a href="#method.chunks_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.chunks_mut" class="fnname">chunks_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.ChunksMut.html" title="struct bitvec::slice::ChunksMut">ChunksMut</a>&lt;'a, T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Iterates over non-overlapping mutable subslices of a bit-slice.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="../slice/struct.ChunksMut.html#method.remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-27"><a href="#original-27">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_mut"><code>slice::chunks_mut</code></a></p>
<h6 id="sibling-methods-1"><a href="#sibling-methods-1">Sibling Methods</a></h6>
<ul>
<li><a href="../slice/struct.BitSlice.html#method.chunks"><code>.chunks()</code></a> has the same division logic, but each yielded bit-slice
is immutable.</li>
<li><a href="../slice/struct.BitSlice.html#method.chunks_exact_mut"><code>.chunks_exact_mut()</code></a> does not yield the final chunk if it is
shorter than <code>chunk_size</code>.</li>
<li><a href="../slice/struct.BitSlice.html#method.rchunks_mut"><code>.rchunks_mut()</code></a> iterates from the back of the bit-slice to the
front, with the final, possibly-shorter, segment at the front edge.</li>
</ul>
<h6 id="panics-4"><a href="#panics-4">Panics</a></h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-31"><a href="#examples-31">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="ident">u8</span>, <span class="ident">Msb0</span>; <span class="number">0</span>; <span class="number">5</span>];

<span class="kw">for</span> (<span class="ident">idx</span>, <span class="ident">chunk</span>) <span class="kw">in</span> <span class="kw">unsafe</span> {
  <span class="ident">bits</span>.<span class="ident">chunks_mut</span>(<span class="number">2</span>).<span class="ident">remove_alias</span>()
}.<span class="ident">enumerate</span>() {
  <span class="ident">chunk</span>.<span class="ident">store</span>(<span class="ident">idx</span> <span class="op">+</span> <span class="number">1</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="comment">//                     ^^^^  ^^^^  ^</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.chunks_exact" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#880-882">source</a></span><a href="#method.chunks_exact" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.chunks_exact" class="fnname">chunks_exact</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.ChunksExact.html" title="struct bitvec::slice::ChunksExact">ChunksExact</a>&lt;'a, T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Iterates over non-overlapping subslices of a bit-slice.</p>
<p>If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the last
few bits are not yielded by the iterator at all. They can be accessed
with the <a href="../slice/struct.ChunksExact.html#method.remainder"><code>.remainder()</code></a> method if the iterator is bound to a name.</p>
<h6 id="original-28"><a href="#original-28">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_exact"><code>slice::chunks_exact</code></a></p>
<h6 id="sibling-methods-2"><a href="#sibling-methods-2">Sibling Methods</a></h6>
<ul>
<li><a href="../slice/struct.BitSlice.html#method.chunks"><code>.chunks()</code></a> yields any leftover bits at the end as a shorter chunk
during iteration.</li>
<li><a href="../slice/struct.BitSlice.html#method.chunks_exact_mut"><code>.chunks_exact_mut()</code></a> has the same division logic, but each yielded
bit-slice is mutable.</li>
<li><a href="../slice/struct.BitSlice.html#method.rchunks_exact"><code>.rchunks_exact()</code></a> iterates from the back of the bit-slice to the
front, with the unyielded remainder segment at the front edge.</li>
</ul>
<h6 id="panics-5"><a href="#panics-5">Panics</a></h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-32"><a href="#examples-32">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">chunks_exact</span>(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]));
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">remainder</span>(), <span class="macro">bits!</span>[<span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.chunks_exact_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#938-943">source</a></span><a href="#method.chunks_exact_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.chunks_exact_mut" class="fnname">chunks_exact_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a><br>) -&gt; <a class="struct" href="../slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.ChunksExactMut.html" title="struct bitvec::slice::ChunksExactMut">ChunksExactMut</a>&lt;'a, T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Iterates over non-overlapping mutable subslices of a bit-slice.</p>
<p>If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the last
few bits are not yielded by the iterator at all. They can be accessed
with the <a href="../slice/struct.ChunksExactMut.html#method.into_remainder"><code>.into_remainder()</code></a> method if the iterator is bound to a
name.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="../slice/struct.ChunksExactMut.html#method.remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-29"><a href="#original-29">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.chunks_exact_mut"><code>slice::chunks_exact_mut</code></a></p>
<h6 id="sibling-methods-3"><a href="#sibling-methods-3">Sibling Methods</a></h6>
<ul>
<li><a href="../slice/struct.BitSlice.html#method.chunks_mut"><code>.chunks_mut()</code></a> yields any leftover bits at the end as a shorter
chunk during iteration.</li>
<li><a href="../slice/struct.BitSlice.html#method.chunks_exact"><code>.chunks_exact()</code></a> has the same division logic, but each yielded
bit-slice is immutable.</li>
<li><a href="../slice/struct.BitSlice.html#method.rchunks_exact_mut"><code>.rchunks_exact_mut()</code></a> iterates from the back of the bit-slice
forwards, with the unyielded remainder segment at the front edge.</li>
</ul>
<h6 id="panics-6"><a href="#panics-6">Panics</a></h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-33"><a href="#examples-33">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="ident">u8</span>, <span class="ident">Msb0</span>; <span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">chunks_exact_mut</span>(<span class="number">2</span>);

<span class="kw">for</span> (<span class="ident">idx</span>, <span class="ident">chunk</span>) <span class="kw">in</span> <span class="ident">iter</span>.<span class="ident">by_ref</span>().<span class="ident">enumerate</span>() {
  <span class="ident">chunk</span>.<span class="ident">store</span>(<span class="ident">idx</span> <span class="op">+</span> <span class="number">1</span>);
}
<span class="ident">iter</span>.<span class="ident">into_remainder</span>().<span class="ident">store</span>(<span class="number">1u8</span>);

<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="comment">//                       remainder ^</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rchunks" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#987-989">source</a></span><a href="#method.rchunks" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rchunks" class="fnname">rchunks</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RChunks.html" title="struct bitvec::slice::RChunks">RChunks</a>&lt;'a, T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Iterates over non-overlapping subslices of a bit-slice, from the back
edge.</p>
<p>Unlike <code>.chunks()</code>, this aligns its chunks to the back edge of <code>self</code>.
If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the
leftover partial chunk is <code>self[0 .. len % chunk_size]</code>.</p>
<h6 id="original-30"><a href="#original-30">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks"><code>slice::rchunks</code></a></p>
<h6 id="sibling-methods-4"><a href="#sibling-methods-4">Sibling Methods</a></h6>
<ul>
<li><a href="../slice/struct.BitSlice.html#method.rchunks_mut"><code>.rchunks_mut()</code></a> has the same division logic, but each yielded
bit-slice is mutable.</li>
<li><a href="../slice/struct.BitSlice.html#method.rchunks_exact"><code>.rchunks_exact()</code></a> does not yield the final chunk if it is shorter
than <code>chunk_size</code>.</li>
<li><a href="../slice/struct.BitSlice.html#method.chunks"><code>.chunks()</code></a> iterates from the front of the bit-slice to the back,
with the final, possibly-shorter, segment at the back edge.</li>
</ul>
<h6 id="panics-7"><a href="#panics-7">Panics</a></h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-34"><a href="#examples-34">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rchunks</span>(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>]));
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rchunks_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1038-1040">source</a></span><a href="#method.rchunks_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rchunks_mut" class="fnname">rchunks_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RChunksMut.html" title="struct bitvec::slice::RChunksMut">RChunksMut</a>&lt;'a, T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Iterates over non-overlapping mutable subslices of a bit-slice, from the
back edge.</p>
<p>Unlike <code>.chunks_mut()</code>, this aligns its chunks to the back edge of
<code>self</code>. If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then
the leftover partial chunk is <code>self[0 .. len % chunk_size]</code>.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded values for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="../slice/struct.RChunksMut.html#method.remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-31"><a href="#original-31">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks_mut"><code>slice::rchunks_mut</code></a></p>
<h6 id="sibling-methods-5"><a href="#sibling-methods-5">Sibling Methods</a></h6>
<ul>
<li><a href="../slice/struct.BitSlice.html#method.rchunks"><code>.rchunks()</code></a> has the same division logic, but each yielded bit-slice
is immutable.</li>
<li><a href="../slice/struct.BitSlice.html#method.rchunks_exact_mut"><code>.rchunks_exact_mut()</code></a> does not yield the final chunk if it is
shorter than <code>chunk_size</code>.</li>
<li><a href="../slice/struct.BitSlice.html#method.chunks_mut"><code>.chunks_mut()</code></a> iterates from the front of the bit-slice to the
back, with the final, possibly-shorter, segment at the back edge.</li>
</ul>
<h6 id="examples-35"><a href="#examples-35">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="ident">u8</span>, <span class="ident">Msb0</span>; <span class="number">0</span>; <span class="number">5</span>];
<span class="kw">for</span> (<span class="ident">idx</span>, <span class="ident">chunk</span>) <span class="kw">in</span> <span class="kw">unsafe</span> {
  <span class="ident">bits</span>.<span class="ident">rchunks_mut</span>(<span class="number">2</span>).<span class="ident">remove_alias</span>()
}.<span class="ident">enumerate</span>() {
  <span class="ident">chunk</span>.<span class="ident">store</span>(<span class="ident">idx</span> <span class="op">+</span> <span class="number">1</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="comment">//           remainder ^  ^^^^  ^^^^</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rchunks_exact" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1085-1087">source</a></span><a href="#method.rchunks_exact" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rchunks_exact" class="fnname">rchunks_exact</a>(&amp;self, chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RChunksExact.html" title="struct bitvec::slice::RChunksExact">RChunksExact</a>&lt;'a, T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Iterates over non-overlapping subslices of a bit-slice, from the back
edge.</p>
<p>If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the first
few bits are not yielded by the iterator at all. They can be accessed
with the <a href="../slice/struct.RChunksExact.html#method.remainder"><code>.remainder()</code></a> method if the iterator is bound to a name.</p>
<h6 id="original-32"><a href="#original-32">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rchunks_exact"><code>slice::rchunks_exact</code></a></p>
<h6 id="sibling-methods-6"><a href="#sibling-methods-6">Sibling Methods</a></h6>
<ul>
<li><a href="../slice/struct.BitSlice.html#method.rchunks"><code>.rchunks()</code></a> yields any leftover bits at the front as a shorter
chunk during iteration.</li>
<li><a href="../slice/struct.BitSlice.html#method.rchunks_exact_mut"><code>.rchunks_exact_mut()</code></a> has the same division logic, but each yielded
bit-slice is mutable.</li>
<li><a href="../slice/struct.BitSlice.html#method.chunks_exact"><code>.chunks_exact()</code></a> iterates from the front of the bit-slice to the
back, with the unyielded remainder segment at the back edge.</li>
</ul>
<h6 id="panics-8"><a href="#panics-8">Panics</a></h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-36"><a href="#examples-36">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rchunks_exact</span>(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">remainder</span>(), <span class="macro">bits!</span>[<span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rchunks_exact_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1140-1145">source</a></span><a href="#method.rchunks_exact_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rchunks_exact_mut" class="fnname">rchunks_exact_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;chunk_size: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a><br>) -&gt; <a class="struct" href="../slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'a, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RChunksExactMut.html" title="struct bitvec::slice::RChunksExactMut">RChunksExactMut</a>&lt;'a, T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Iterates over non-overlapping mutable subslices of a bit-slice, from the
back edge.</p>
<p>If <code>self.len()</code> is not an even multiple of <code>chunk_size</code>, then the first
few bits are not yielded by the iterator at all. They can be accessed
with the <a href="../slice/struct.RChunksExactMut.html#method.into_remainder"><code>.into_remainder()</code></a> method if the iterator is bound to a
name.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="../slice/struct.RChunksExactMut.html#method.remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="sibling-methods-7"><a href="#sibling-methods-7">Sibling Methods</a></h6>
<ul>
<li><a href="../slice/struct.BitSlice.html#method.rchunks_mut"><code>.rchunks_mut()</code></a> yields any leftover bits at the front as a shorter
chunk during iteration.</li>
<li><a href="../slice/struct.BitSlice.html#method.rchunks_exact"><code>.rchunks_exact()</code></a> has the same division logic, but each yielded
bit-slice is immutable.</li>
<li><a href="../slice/struct.BitSlice.html#method.chunks_exact_mut"><code>.chunks_exact_mut()</code></a> iterates from the front of the bit-slice
backwards, with the unyielded remainder segment at the back edge.</li>
</ul>
<h6 id="panics-9"><a href="#panics-9">Panics</a></h6>
<p>This panics if <code>chunk_size</code> is <code>0</code>.</p>
<h6 id="examples-37"><a href="#examples-37">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="ident">u8</span>, <span class="ident">Msb0</span>; <span class="number">0</span>; <span class="number">5</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rchunks_exact_mut</span>(<span class="number">2</span>);

<span class="kw">for</span> (<span class="ident">idx</span>, <span class="ident">chunk</span>) <span class="kw">in</span> <span class="ident">iter</span>.<span class="ident">by_ref</span>().<span class="ident">enumerate</span>() {
  <span class="ident">chunk</span>.<span class="ident">store</span>(<span class="ident">idx</span> <span class="op">+</span> <span class="number">1</span>);
}
<span class="ident">iter</span>.<span class="ident">into_remainder</span>().<span class="ident">store</span>(<span class="number">1u8</span>);

<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="comment">//           remainder ^</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1188-1191">source</a></span><a href="#method.split_at" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_at" class="fnname">split_at</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Self, <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class="docblock"><p>Splits a bit-slice in two parts at an index.</p>
<p>The returned bit-slices are <code>self[.. mid]</code> and <code>self[mid ..]</code>. <code>mid</code> is
included in the right bit-slice, not the left.</p>
<p>If <code>mid</code> is <code>0</code> then the left bit-slice is empty; if it is <code>self.len()</code>
then the right bit-slice is empty.</p>
<p>This method guarantees that even when either partition is empty, the
encoded bit-pointer values of the bit-slice references is <code>&amp;self[0]</code> and
<code>&amp;self[mid]</code>.</p>
<h6 id="original-33"><a href="#original-33">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_at"><code>slice::split_at</code></a></p>
<h6 id="panics-10"><a href="#panics-10">Panics</a></h6>
<p>This panics if <code>mid</code> is greater than <code>self.len()</code>. It is allowed to be
equal to the length, in which case the right bit-slice is simply empty.</p>
<h6 id="examples-38"><a href="#examples-38">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">base</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">as_bitptr</span>();

<span class="kw">let</span> (<span class="ident">a</span>, <span class="ident">b</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at</span>(<span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe</span> { <span class="ident">a</span>.<span class="ident">as_bitptr</span>().<span class="ident">offset_from</span>(<span class="ident">base</span>) }, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe</span> { <span class="ident">b</span>.<span class="ident">as_bitptr</span>().<span class="ident">offset_from</span>(<span class="ident">base</span>) }, <span class="number">0</span>);

<span class="kw">let</span> (<span class="ident">a</span>, <span class="ident">b</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at</span>(<span class="number">6</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe</span> { <span class="ident">b</span>.<span class="ident">as_bitptr</span>().<span class="ident">offset_from</span>(<span class="ident">base</span>) }, <span class="number">6</span>);

<span class="kw">let</span> (<span class="ident">a</span>, <span class="ident">b</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at</span>(<span class="number">3</span>);
<span class="macro">assert_eq!</span>(<span class="ident">a</span>, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">3</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">b</span>, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">3</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1244-1250">source</a></span><a href="#method.split_at_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_at_mut" class="fnname">split_at_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;mid: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a><br>) -&gt; (&amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;, &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;)</h4></section></summary><div class="docblock"><p>Splits a mutable bit-slice in two parts at an index.</p>
<p>The returned bit-slices are <code>self[.. mid]</code> and <code>self[mid ..]</code>. <code>mid</code> is
included in the right bit-slice, not the left.</p>
<p>If <code>mid</code> is <code>0</code> then the left bit-slice is empty; if it is <code>self.len()</code>
then the right bit-slice is empty.</p>
<p>This method guarantees that even when either partition is empty, the
encoded bit-pointer values of the bit-slice references is <code>&amp;self[0]</code> and
<code>&amp;self[mid]</code>.</p>
<h6 id="original-34"><a href="#original-34">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_mut"><code>slice::split_at_mut</code></a></p>
<h6 id="api-differences-14"><a href="#api-differences-14">API Differences</a></h6>
<p>The end bits of the left half and the start bits of the right half might
be stored in the same memory element. In order to avoid breaking
<code>bitvec</code>’s memory-safety guarantees, both bit-slices are marked as
<code>T::Alias</code>. This marking allows them to be used without interfering with
each other when they interact with memory.</p>
<h6 id="panics-11"><a href="#panics-11">Panics</a></h6>
<p>This panics if <code>mid</code> is greater than <code>self.len()</code>. It is allowed to be
equal to the length, in which case the right bit-slice is simply empty.</p>
<h6 id="examples-39"><a href="#examples-39">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="ident">u8</span>, <span class="ident">Msb0</span>; <span class="number">0</span>; <span class="number">6</span>];
<span class="kw">let</span> <span class="ident">base</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">as_mut_bitptr</span>();

<span class="kw">let</span> (<span class="ident">a</span>, <span class="ident">b</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at_mut</span>(<span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe</span> { <span class="ident">a</span>.<span class="ident">as_mut_bitptr</span>().<span class="ident">offset_from</span>(<span class="ident">base</span>) }, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe</span> { <span class="ident">b</span>.<span class="ident">as_mut_bitptr</span>().<span class="ident">offset_from</span>(<span class="ident">base</span>) }, <span class="number">0</span>);

<span class="kw">let</span> (<span class="ident">a</span>, <span class="ident">b</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at_mut</span>(<span class="number">6</span>);
<span class="macro">assert_eq!</span>(<span class="kw">unsafe</span> { <span class="ident">b</span>.<span class="ident">as_mut_bitptr</span>().<span class="ident">offset_from</span>(<span class="ident">base</span>) }, <span class="number">6</span>);

<span class="kw">let</span> (<span class="ident">a</span>, <span class="ident">b</span>) <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_at_mut</span>(<span class="number">3</span>);
<span class="ident">a</span>.<span class="ident">store</span>(<span class="number">3</span>);
<span class="ident">b</span>.<span class="ident">store</span>(<span class="number">5</span>);

<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1327-1330">source</a></span><a href="#method.split" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split" class="fnname">split</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="../slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'a, T, O, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Iterates over subslices separated by bits that match a predicate. The
matched bit is <em>not</em> contained in the yielded bit-slices.</p>
<h6 id="original-35"><a href="#original-35">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split"><code>slice::split</code></a></p>
<h6 id="api-differences-15"><a href="#api-differences-15">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-8"><a href="#sibling-methods-8">Sibling Methods</a></h6>
<ul>
<li><a href="../slice/struct.BitSlice.html#method.split_mut"><code>.split_mut()</code></a> has the same splitting logic, but each yielded
bit-slice is mutable.</li>
<li><a href="../slice/struct.BitSlice.html#method.split_inclusive"><code>.split_inclusive()</code></a> includes the matched bit in the yielded
bit-slice.</li>
<li><a href="../slice/struct.BitSlice.html#method.rsplit"><code>.rsplit()</code></a> iterates from the back of the bit-slice instead of the
front.</li>
<li><a href="../slice/struct.BitSlice.html#method.splitn"><code>.splitn()</code></a> times out after <code>n</code> yields.</li>
</ul>
<h6 id="examples-40"><a href="#examples-40">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//                     ^</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">pos</span>, <span class="ident">_bit</span><span class="op">|</span> <span class="ident">pos</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">2</span>);

<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits!</span>[<span class="number">0</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
<p>If the first bit is matched, then an empty bit-slice will be the first
item yielded by the iterator. Similarly, if the last bit in the
bit-slice matches, then an empty bit-slice will be the last item
yielded.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                     ^</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>);

<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">is_empty</span>());
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
<p>If two matched bits are directly adjacent, then an empty bit-slice will
be yielded between them:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                  ^  ^</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="op">!</span><span class="kw-2">*</span><span class="ident">bit</span>);

<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">is_empty</span>());
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1381-1384">source</a></span><a href="#method.split_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_mut" class="fnname">split_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="../slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'a, T, O, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate. The matched bit is <em>not</em> contained in the yielded bit-slices.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="../slice/struct.SplitMut.html#method.remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-36"><a href="#original-36">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_mut"><code>slice::split_mut</code></a></p>
<h6 id="api-differences-16"><a href="#api-differences-16">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-9"><a href="#sibling-methods-9">Sibling Methods</a></h6>
<ul>
<li><a href="../slice/struct.BitSlice.html#method.split"><code>.split()</code></a> has the same splitting logic, but each yielded bit-slice
is immutable.</li>
<li><a href="../slice/struct.BitSlice.html#method.split_inclusive_mut"><code>.split_inclusive_mut()</code></a> includes the matched bit in the yielded
bit-slice.</li>
<li><a href="../slice/struct.BitSlice.html#method.rsplit_mut"><code>.rsplit_mut()</code></a> iterates from the back of the bit-slice instead of
the front.</li>
<li><a href="../slice/struct.BitSlice.html#method.splitn_mut"><code>.splitn_mut()</code></a> times out after <code>n</code> yields.</li>
</ul>
<h6 id="examples-41"><a href="#examples-41">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//                         ^     ^</span>
<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">split_mut</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>) {
  <span class="ident">group</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_inclusive" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1424-1427">source</a></span><a href="#method.split_inclusive" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_inclusive" class="fnname">split_inclusive</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="../slice/struct.SplitInclusive.html" title="struct bitvec::slice::SplitInclusive">SplitInclusive</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.SplitInclusive.html" title="struct bitvec::slice::SplitInclusive">SplitInclusive</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.SplitInclusive.html" title="struct bitvec::slice::SplitInclusive">SplitInclusive</a>&lt;'a, T, O, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Iterates over subslices separated by bits that match a predicate. Unlike
<code>.split()</code>, this <em>does</em> include the matching bit as the last bit in the
yielded bit-slice.</p>
<h6 id="original-37"><a href="#original-37">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_inclusive"><code>slice::split_inclusive</code></a></p>
<h6 id="api-differences-17"><a href="#api-differences-17">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-10"><a href="#sibling-methods-10">Sibling Methods</a></h6>
<ul>
<li><a href="../slice/struct.BitSlice.html#method.split_inclusive_mut"><code>.split_inclusive_mut()</code></a> has the same splitting logic, but each
yielded bit-slice is mutable.</li>
<li><a href="../slice/struct.BitSlice.html#method.split"><code>.split()</code></a> does not include the matched bit in the yielded
bit-slice.</li>
</ul>
<h6 id="examples-42"><a href="#examples-42">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                     ^     ^</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split_inclusive</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>);

<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_inclusive_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1474-1482">source</a></span><a href="#method.split_inclusive_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.split_inclusive_mut" class="fnname">split_inclusive_mut</a>&lt;F&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;pred: F<br>) -&gt; <a class="struct" href="../slice/struct.SplitInclusiveMut.html" title="struct bitvec::slice::SplitInclusiveMut">SplitInclusiveMut</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.SplitInclusiveMut.html" title="struct bitvec::slice::SplitInclusiveMut">SplitInclusiveMut</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.SplitInclusiveMut.html" title="struct bitvec::slice::SplitInclusiveMut">SplitInclusiveMut</a>&lt;'a, T, O, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate. Unlike <code>.split_mut()</code>, this <em>does</em> include the matching bit
as the last bit in the bit-slice.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="../slice/struct.SplitInclusiveMut.html#method.remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-38"><a href="#original-38">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.split_inclusive_mut"><code>slice::split_inclusive_mut</code></a></p>
<h6 id="api-differences-18"><a href="#api-differences-18">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-11"><a href="#sibling-methods-11">Sibling Methods</a></h6>
<ul>
<li><a href="../slice/struct.BitSlice.html#method.split_inclusive"><code>.split_inclusive()</code></a> has the same splitting logic, but each yielded
bit-slice is immutable.</li>
<li><a href="../slice/struct.BitSlice.html#method.split_mut"><code>.split_mut()</code></a> does not include the matched bit in the yielded
bit-slice.</li>
</ul>
<h6 id="examples-43"><a href="#examples-43">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="comment">//                         ^</span>
<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">split_inclusive_mut</span>(<span class="op">|</span><span class="ident">pos</span>, <span class="ident">_bit</span><span class="op">|</span> <span class="ident">pos</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">2</span>) {
  <span class="ident">group</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplit" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1557-1560">source</a></span><a href="#method.rsplit" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rsplit" class="fnname">rsplit</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="../slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'a, T, O, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Iterates over subslices separated by bits that match a predicate, from
the back edge. The matched bit is <em>not</em> contained in the yielded
bit-slices.</p>
<h6 id="original-39"><a href="#original-39">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplit"><code>slice::rsplit</code></a></p>
<h6 id="api-differences-19"><a href="#api-differences-19">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-12"><a href="#sibling-methods-12">Sibling Methods</a></h6>
<ul>
<li><a href="../slice/struct.BitSlice.html#method.rsplit_mut"><code>.rsplit_mut()</code></a> has the same splitting logic, but each yielded
bit-slice is mutable.</li>
<li><a href="../slice/struct.BitSlice.html#method.split"><code>.split()</code></a> iterates from the front of the bit-slice instead of the
back.</li>
<li><a href="../slice/struct.BitSlice.html#method.rsplitn"><code>.rsplitn()</code></a> times out after <code>n</code> yields.</li>
</ul>
<h6 id="examples-44"><a href="#examples-44">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//                     ^</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rsplit</span>(<span class="op">|</span><span class="ident">pos</span>, <span class="ident">_bit</span><span class="op">|</span> <span class="ident">pos</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">2</span>);

<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits!</span>[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
<p>If the last bit is matched, then an empty bit-slice will be the first
item yielded by the iterator. Similarly, if the first bit in the
bit-slice matches, then an empty bit-slice will be the last item
yielded.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                     ^</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rsplit</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>);

<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">is_empty</span>());
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
<p>If two yielded bits are directly adjacent, then an empty bit-slice will
be yielded between them:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="comment">//                  ^  ^</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="op">!</span><span class="kw-2">*</span><span class="ident">bit</span>);

<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>().<span class="ident">is_empty</span>());
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits!</span>[<span class="number">1</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplit_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1609-1612">source</a></span><a href="#method.rsplit_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rsplit_mut" class="fnname">rsplit_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="../slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'a, T, O, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate, from the back. The matched bit is <em>not</em> contained in the
yielded bit-slices.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="../slice/struct.RSplitMut.html#method.remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-40"><a href="#original-40">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplit_mut"><code>slice::rsplit_mut</code></a></p>
<h6 id="api-differences-20"><a href="#api-differences-20">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-13"><a href="#sibling-methods-13">Sibling Methods</a></h6>
<ul>
<li><a href="../slice/struct.BitSlice.html#method.rsplit"><code>.rsplit()</code></a> has the same splitting logic, but each yielded bit-slice
is immutable.</li>
<li><a href="../slice/struct.BitSlice.html#method.split_mut"><code>.split_mut()</code></a> iterates from the front of the bit-slice to the back.</li>
<li><a href="../slice/struct.BitSlice.html#method.rsplitn_mut"><code>.rsplitn_mut()</code></a> iterates from the front of the bit-slice to the
back.</li>
</ul>
<h6 id="examples-45"><a href="#examples-45">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//                         ^     ^</span>
<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">rsplit_mut</span>(<span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>) {
  <span class="ident">group</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.splitn" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1654-1657">source</a></span><a href="#method.splitn" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.splitn" class="fnname">splitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../slice/struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.SplitN.html" title="struct bitvec::slice::SplitN">SplitN</a>&lt;'a, T, O, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="struct" href="../slice/struct.Split.html" title="struct bitvec::slice::Split">Split</a>&lt;'a, T, O, P&gt; as <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Iterates over subslices separated by bits that match a predicate, giving
up after yielding <code>n</code> times. The <code>n</code>th yield contains the rest of the
bit-slice. As with <code>.split()</code>, the yielded bit-slices do not contain the
matched bit.</p>
<h6 id="original-41"><a href="#original-41">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.splitn"><code>slice::splitn</code></a></p>
<h6 id="api-differences-21"><a href="#api-differences-21">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-14"><a href="#sibling-methods-14">Sibling Methods</a></h6>
<ul>
<li><a href="../slice/struct.BitSlice.html#method.splitn_mut"><code>.splitn_mut()</code></a> has the same splitting logic, but each yielded
bit-slice is mutable.</li>
<li><a href="../slice/struct.BitSlice.html#method.rsplitn"><code>.rsplitn()</code></a> iterates from the back of the bit-slice instead of the
front.</li>
<li><a href="../slice/struct.BitSlice.html#method.split"><code>.split()</code></a> has the same splitting logic, but never times out.</li>
</ul>
<h6 id="examples-46"><a href="#examples-46">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">splitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>);

<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.splitn_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1706-1709">source</a></span><a href="#method.splitn_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.splitn_mut" class="fnname">splitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../slice/struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.SplitNMut.html" title="struct bitvec::slice::SplitNMut">SplitNMut</a>&lt;'a, T, O, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="struct" href="../slice/struct.SplitMut.html" title="struct bitvec::slice::SplitMut">SplitMut</a>&lt;'a, T, O, P&gt; as <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate, giving up after yielding <code>n</code> times. The <code>n</code>th yield contains
the rest of the bit-slice. As with <code>.split_mut()</code>, the yielded
bit-slices do not contain the matched bit.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="../slice/struct.SplitNMut.html#method.remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-42"><a href="#original-42">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.splitn_mut"><code>slice::splitn_mut</code></a></p>
<h6 id="api-differences-22"><a href="#api-differences-22">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-15"><a href="#sibling-methods-15">Sibling Methods</a></h6>
<ul>
<li><a href="../slice/struct.BitSlice.html#method.splitn"><code>.splitn()</code></a> has the same splitting logic, but each yielded bit-slice
is immutable.</li>
<li><a href="../slice/struct.BitSlice.html#method.rsplitn_mut"><code>.rsplitn_mut()</code></a> iterates from the back of the bit-slice instead of
the front.</li>
<li><a href="../slice/struct.BitSlice.html#method.split_mut"><code>.split_mut()</code></a> has the same splitting logic, but never times out.</li>
</ul>
<h6 id="examples-47"><a href="#examples-47">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">splitn_mut</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>) {
  <span class="ident">group</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplitn" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1752-1755">source</a></span><a href="#method.rsplitn" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rsplitn" class="fnname">rsplitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../slice/struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RSplitN.html" title="struct bitvec::slice::RSplitN">RSplitN</a>&lt;'a, T, O, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="struct" href="../slice/struct.RSplit.html" title="struct bitvec::slice::RSplit">RSplit</a>&lt;'a, T, O, P&gt; as <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate from the back edge, giving up after yielding <code>n</code> times. The
<code>n</code>th yield contains the rest of the bit-slice. As with <code>.split_mut()</code>,
the yielded bit-slices do not contain the matched bit.</p>
<h6 id="original-43"><a href="#original-43">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplitn"><code>slice::rsplitn</code></a></p>
<h6 id="api-differences-23"><a href="#api-differences-23">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-16"><a href="#sibling-methods-16">Sibling Methods</a></h6>
<ul>
<li><a href="../slice/struct.BitSlice.html#method.rsplitn_mut"><code>.rsplitn_mut()</code></a> has the same splitting logic, but each yielded
bit-slice is mutable.</li>
<li><a href="../slice/struct.BitSlice.html#method.splitn"><code>.splitn()</code></a>: iterates from the front of the bit-slice instead of the
back.</li>
<li><a href="../slice/struct.BitSlice.html#method.rsplit"><code>.rsplit()</code></a> has the same splitting logic, but never times out.</li>
</ul>
<h6 id="examples-48"><a href="#examples-48">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//                        ^</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">rsplitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">_pos</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>);

<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits!</span>[<span class="number">0</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">unwrap</span>(), <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert!</span>(<span class="ident">iter</span>.<span class="ident">next</span>().<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rsplitn_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1805-1808">source</a></span><a href="#method.rsplitn_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rsplitn_mut" class="fnname">rsplitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../slice/struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'_, T, O, F&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'a, T, O, P&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;'a, T, O, P&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.RSplitNMut.html" title="struct bitvec::slice::RSplitNMut">RSplitNMut</a>&lt;'a, T, O, P&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;P: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = &lt;<a class="struct" href="../slice/struct.RSplitMut.html" title="struct bitvec::slice::RSplitMut">RSplitMut</a>&lt;'a, T, O, P&gt; as <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" title="type core::iter::traits::iterator::Iterator::Item">Item</a>;</span></code></span></span></span></span> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Iterates over mutable subslices separated by bits that match a
predicate from the back edge, giving up after yielding <code>n</code> times. The
<code>n</code>th yield contains the rest of the bit-slice. As with <code>.split_mut()</code>,
the yielded bit-slices do not contain the matched bit.</p>
<p>Iterators do not require that each yielded item is destroyed before the
next is produced. This means that each bit-slice yielded must be marked
as aliased. If you are using this in a loop that does not collect
multiple yielded subslices for the same scope, then you can remove the
alias marking by calling the (<code>unsafe</code>) method <a href="../slice/struct.RSplitNMut.html#method.remove_alias"><code>.remove_alias()</code></a> on
the iterator.</p>
<h6 id="original-44"><a href="#original-44">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rsplitn_mut"><code>slice::rsplitn_mut</code></a></p>
<h6 id="api-differences-24"><a href="#api-differences-24">API Differences</a></h6>
<p>The predicate function receives the index being tested as well as the
bit value at that index. This allows the predicate to have more than one
bit of information about the bit-slice being traversed.</p>
<h6 id="sibling-methods-17"><a href="#sibling-methods-17">Sibling Methods</a></h6>
<ul>
<li><a href="../slice/struct.BitSlice.html#method.rsplitn"><code>.rsplitn()</code></a> has the same splitting logic, but each yielded
bit-slice is immutable.</li>
<li><a href="../slice/struct.BitSlice.html#method.splitn_mut"><code>.splitn_mut()</code></a> iterates from the front of the bit-slice instead of
the back.</li>
<li><a href="../slice/struct.BitSlice.html#method.rsplit_mut"><code>.rsplit_mut()</code></a> has the same splitting logic, but never times out.</li>
</ul>
<h6 id="examples-49"><a href="#examples-49">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">bits</span>.<span class="ident">rsplitn_mut</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">_idx</span>, <span class="ident">bit</span><span class="op">|</span> <span class="kw-2">*</span><span class="ident">bit</span>) {
  <span class="ident">group</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);
<span class="comment">//                     ^ group 2         ^ group 1</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.contains" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1831-1838">source</a></span><a href="#method.contains" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.contains" class="fnname">contains</a>&lt;T2, O2&gt;(&amp;self, other: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Tests if the bit-slice contains the given sequence anywhere within it.</p>
<p>This scans over <code>self.windows(other.len())</code> until one of the windows
matches. The search key does not need to share type parameters with the
bit-slice being tested, as the comparison is bit-wise. However, sharing
type parameters will accelerate the comparison.</p>
<h6 id="original-45"><a href="#original-45">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.contains"><code>slice::contains</code></a></p>
<h6 id="examples-50"><a href="#examples-50">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert!</span>( <span class="ident">bits</span>.<span class="ident">contains</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bits</span>.<span class="ident">contains</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.starts_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1871-1879">source</a></span><a href="#method.starts_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.starts_with" class="fnname">starts_with</a>&lt;T2, O2&gt;(&amp;self, needle: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Tests if the bit-slice begins with the given sequence.</p>
<p>The search key does not need to share type parameters with the bit-slice
being tested, as the comparison is bit-wise. However, sharing type
parameters will accelerate the comparison.</p>
<h6 id="original-46"><a href="#original-46">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.starts_with"><code>slice::starts_with</code></a></p>
<h6 id="examples-51"><a href="#examples-51">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert!</span>( <span class="ident">bits</span>.<span class="ident">starts_with</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bits</span>.<span class="ident">starts_with</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]));</code></pre></div>
<p>This always returns <code>true</code> if the needle is empty:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">empty</span> <span class="op">=</span> <span class="macro">bits!</span>[];
<span class="macro">assert!</span>(<span class="ident">bits</span>.<span class="ident">starts_with</span>(<span class="ident">empty</span>));
<span class="macro">assert!</span>(<span class="ident">empty</span>.<span class="ident">starts_with</span>(<span class="ident">empty</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ends_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1912-1920">source</a></span><a href="#method.ends_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.ends_with" class="fnname">ends_with</a>&lt;T2, O2&gt;(&amp;self, needle: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a> <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Tests if the bit-slice ends with the given sequence.</p>
<p>The search key does not need to share type parameters with the bit-slice
being tested, as the comparison is bit-wise. However, sharing type
parameters will accelerate the comparison.</p>
<h6 id="original-47"><a href="#original-47">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.ends_with"><code>slice::ends_with</code></a></p>
<h6 id="examples-52"><a href="#examples-52">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert!</span>( <span class="ident">bits</span>.<span class="ident">ends_with</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]));
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bits</span>.<span class="ident">ends_with</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]));</code></pre></div>
<p>This always returns <code>true</code> if the needle is empty:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">empty</span> <span class="op">=</span> <span class="macro">bits!</span>[];
<span class="macro">assert!</span>(<span class="ident">bits</span>.<span class="ident">ends_with</span>(<span class="ident">empty</span>));
<span class="macro">assert!</span>(<span class="ident">empty</span>.<span class="ident">ends_with</span>(<span class="ident">empty</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.strip_prefix" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1951-1965">source</a></span><a href="#method.strip_prefix" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.strip_prefix" class="fnname">strip_prefix</a>&lt;T2, O2&gt;(&amp;self, prefix: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Removes a prefix bit-slice, if present.</p>
<p>Like <a href="../slice/struct.BitSlice.html#method.starts_with"><code>.starts_with()</code></a>, the search key does not need to share type
parameters with the bit-slice being stripped. If
<code>self.starts_with(suffix)</code>, then this returns <code>Some(&amp;self[prefix.len() ..])</code>, otherwise it returns <code>None</code>.</p>
<h6 id="original-48"><a href="#original-48">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.strip_prefix"><code>slice::strip_prefix</code></a></p>
<h6 id="api-differences-25"><a href="#api-differences-25">API Differences</a></h6>
<p><code>BitSlice</code> does not support pattern searches; instead, it permits <code>self</code>
and <code>prefix</code> to differ in type parameters.</p>
<h6 id="examples-53"><a href="#examples-53">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>.<span class="ident">strip_prefix</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]).<span class="ident">unwrap</span>(), <span class="ident">bits</span>[<span class="number">2</span> ..]);
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>.<span class="ident">strip_prefix</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>,]).<span class="ident">unwrap</span>(), <span class="ident">bits</span>[<span class="number">4</span> ..]);
<span class="macro">assert!</span>(<span class="ident">bits</span>.<span class="ident">strip_prefix</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]).<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.strip_suffix" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#1996-2010">source</a></span><a href="#method.strip_suffix" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.strip_suffix" class="fnname">strip_suffix</a>&lt;T2, O2&gt;(&amp;self, suffix: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Removes a suffix bit-slice, if present.</p>
<p>Like <a href="Self::ends_with."><code>.ends_with()</code></a>, the search key does not need to share type
parameters with the bit-slice being stripped. If
<code>self.ends_with(suffix)</code>, then this returns <code>Some(&amp;self[.. self.len() - suffix.len()])</code>, otherwise it returns <code>None</code>.</p>
<h6 id="original-49"><a href="#original-49">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.strip_suffix"><code>slice::strip_suffix</code></a></p>
<h6 id="api-differences-26"><a href="#api-differences-26">API Differences</a></h6>
<p><code>BitSlice</code> does not support pattern searches; instead, it permits <code>self</code>
and <code>suffix</code> to differ in type parameters.</p>
<h6 id="examples-54"><a href="#examples-54">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>.<span class="ident">strip_suffix</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]).<span class="ident">unwrap</span>(), <span class="ident">bits</span>[.. <span class="number">7</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>.<span class="ident">strip_suffix</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]).<span class="ident">unwrap</span>(), <span class="ident">bits</span>[.. <span class="number">5</span>]);
<span class="macro">assert!</span>(<span class="ident">bits</span>.<span class="ident">strip_suffix</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>]).<span class="ident">is_none</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rotate_left" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2037-2058">source</a></span><a href="#method.rotate_left" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rotate_left" class="fnname">rotate_left</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Rotates the contents of a bit-slice to the left (towards the zero
index).</p>
<p>This essentially splits the bit-slice at <code>by</code>, then exchanges the two
pieces. <code>self[.. by]</code> becomes the first section, and is then followed by
<code>self[.. by]</code>.</p>
<p>The implementation is batch-accelerated where possible. It should have a
runtime complexity much lower than <code>O(by)</code>.</p>
<h6 id="original-50"><a href="#original-50">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rotate_left"><code>slice::rotate_left</code></a></p>
<h6 id="examples-55"><a href="#examples-55">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//      split occurs here ^</span>
<span class="ident">bits</span>.<span class="ident">rotate_left</span>(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.rotate_right" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2085-2107">source</a></span><a href="#method.rotate_right" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.rotate_right" class="fnname">rotate_right</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Rotates the contents of a bit-slice to the right (away from the zero
index).</p>
<p>This essentially splits the bit-slice at <code>self.len() - by</code>, then
exchanges the two pieces. <code>self[len - by ..]</code> becomes the first section,
and is then followed by <code>self[.. len - by]</code>.</p>
<p>The implementation is batch-accelerated where possible. It should have a
runtime complexity much lower than <code>O(by)</code>.</p>
<h6 id="original-51"><a href="#original-51">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.rotate_right"><code>slice::rotate_right</code></a></p>
<h6 id="examples-56"><a href="#examples-56">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];
<span class="comment">//            split occurs here ^</span>
<span class="ident">bits</span>.<span class="ident">rotate_right</span>(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fill" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2129-2147">source</a></span><a href="#method.fill" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.fill" class="fnname">fill</a>(&amp;mut self, value: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Fills the bit-slice with a given bit.</p>
<p>This is a recent stabilization in the standard library. <code>bitvec</code>
previously offered this behavior as the novel API <code>.set_all()</code>. That
method name is now removed in favor of this standard-library analogue.</p>
<h6 id="original-52"><a href="#original-52">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.fill"><code>slice::fill</code></a></p>
<h6 id="examples-57"><a href="#examples-57">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>; <span class="number">5</span>];
<span class="ident">bits</span>.<span class="ident">fill</span>(<span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>; <span class="number">5</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fill_with" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2170-2177">source</a></span><a href="#method.fill_with" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.fill_with" class="fnname">fill_with</a>&lt;F&gt;(&amp;mut self, func: F) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Fills the bit-slice with bits produced by a generator function.</p>
<h6 id="original-53"><a href="#original-53">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.fill_with"><code>slice::fill_with</code></a></p>
<h6 id="api-differences-27"><a href="#api-differences-27">API Differences</a></h6>
<p>The generator function receives the index of the bit being initialized
as an argument.</p>
<h6 id="examples-58"><a href="#examples-58">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>; <span class="number">5</span>];
<span class="ident">bits</span>.<span class="ident">fill_with</span>(<span class="op">|</span><span class="ident">idx</span><span class="op">|</span> <span class="ident">idx</span> <span class="op">%</span> <span class="number">2</span> <span class="op">==</span> <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
</div></details><section id="method.clone_from_slice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2183-2189">source</a></span><a href="#method.clone_from_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.clone_from_slice" class="fnname">clone_from_slice</a>&lt;T2, O2&gt;(&amp;mut self, src: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span> Deprecated: <p>use <code>.clone_from_bitslice()</code> instead</p>
</div></span><section id="method.copy_from_slice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2195-2197">source</a></span><a href="#method.copy_from_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.copy_from_slice" class="fnname">copy_from_slice</a>(&amp;mut self, src: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Self)</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span> Deprecated: <p>use <code>.copy_from_bitslice()</code> instead</p>
</div></span><details class="rustdoc-toggle method-toggle" open><summary><section id="method.copy_within" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2228-2239">source</a></span><a href="#method.copy_within" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.copy_within" class="fnname">copy_within</a>&lt;R&gt;(&amp;mut self, src: R, dest: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../../wyz/range/trait.RangeExt.html" title="trait wyz::range::RangeExt">RangeExt</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Copies a span of bits to another location in the bit-slice.</p>
<p><code>src</code> is the range of bit-indices in the bit-slice to copy, and <code>dest is the starting index of the destination range. </code>src<code>and</code>dest .. dest +
src.len()<code>are permitted to overlap; the copy will automatically detect and manage this. However, both</code>src<code>and</code>dest .. dest + src.len()<code>**must** fall within the bounds of</code>self`.</p>
<h6 id="original-54"><a href="#original-54">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.copy_within"><code>slice::copy_within</code></a></p>
<h6 id="panics-12"><a href="#panics-12">Panics</a></h6>
<p>This panics if either the source or destination range exceed
<code>self.len()</code>.</p>
<h6 id="examples-59"><a href="#examples-59">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="ident">bits</span>.<span class="ident">copy_within</span>(<span class="number">1</span> .. <span class="number">5</span>, <span class="number">8</span>);
<span class="comment">//                        v  v  v  v</span>
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>]);
<span class="comment">//                                             ^  ^  ^  ^</span></code></pre></div>
</div></details><section id="method.swap_with_slice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2244-2250">source</a></span><a href="#method.swap_with_slice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.swap_with_slice" class="fnname">swap_with_slice</a>&lt;T2, O2&gt;(&amp;mut self, other: &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span> Deprecated: <p>use <code>.swap_with_bitslice()</code> instead</p>
</div></span><details class="rustdoc-toggle method-toggle" open><summary><section id="method.align_to" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2294-2302">source</a></span><a href="#method.align_to" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.align_to" class="fnname">align_to</a>&lt;U&gt;(&amp;self) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Self, &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;U, O&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Self) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Produces bit-slice view(s) with different underlying storage types.</p>
<p>This may have unexpected effects, and you cannot assume that
<code>before[idx] == after[idx]</code>! Consult the <a href="https://bitvecto-rs.github.io/bitvec/memory-layout.html">tables in the manual</a>
for information about memory layouts.</p>
<h6 id="original-55"><a href="#original-55">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.align_to"><code>slice::align_to</code></a></p>
<h6 id="notes-1"><a href="#notes-1">Notes</a></h6>
<p>Unlike the standard library documentation, this explicitly guarantees
that the middle bit-slice will have maximal size. You may rely on this
property.</p>
<h6 id="safety-4"><a href="#safety-4">Safety</a></h6>
<p>You may not use this to cast away alias protections. Rust does not have
support for higher-kinded types, so this cannot express the relation
<code>Outer&lt;T&gt; -&gt; Outer&lt;U&gt; where Outer: BitStoreContainer</code>, but memory safety
does require that you respect this rule. Reälign integers to integers,
<code>Cell</code>s to <code>Cell</code>s, and atomics to atomics, but do not cross these
boundaries.</p>
<h6 id="examples-60"><a href="#examples-60">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bytes</span>: [<span class="ident">u8</span>; <span class="number">7</span>] <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">bytes</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> (<span class="ident">pfx</span>, <span class="ident">mid</span>, <span class="ident">sfx</span>) <span class="op">=</span> <span class="kw">unsafe</span> {
  <span class="ident">bits</span>.<span class="ident">align_to</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>()
};
<span class="macro">assert!</span>(<span class="ident">pfx</span>.<span class="ident">len</span>() <span class="op">&lt;</span><span class="op">=</span> <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="ident">mid</span>.<span class="ident">len</span>(), <span class="number">48</span>);
<span class="macro">assert!</span>(<span class="ident">sfx</span>.<span class="ident">len</span>() <span class="op">&lt;</span><span class="op">=</span> <span class="number">8</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.align_to_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2346-2356">source</a></span><a href="#method.align_to_mut" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.align_to_mut" class="fnname">align_to_mut</a>&lt;U&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self<br>) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>Self, &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;U, O&gt;, <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>Self) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Produces bit-slice view(s) with different underlying storage types.</p>
<p>This may have unexpected effects, and you cannot assume that
<code>before[idx] == after[idx]</code>! Consult the <a href="https://bitvecto-rs.github.io/bitvec/memory-layout.html">tables in the manual</a>
for information about memory layouts.</p>
<h6 id="original-56"><a href="#original-56">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.align_to_mut"><code>slice::align_to_mut</code></a></p>
<h6 id="notes-2"><a href="#notes-2">Notes</a></h6>
<p>Unlike the standard library documentation, this explicitly guarantees
that the middle bit-slice will have maximal size. You may rely on this
property.</p>
<h6 id="safety-5"><a href="#safety-5">Safety</a></h6>
<p>You may not use this to cast away alias protections. Rust does not have
support for higher-kinded types, so this cannot express the relation
<code>Outer&lt;T&gt; -&gt; Outer&lt;U&gt; where Outer: BitStoreContainer</code>, but memory safety
does require that you respect this rule. Reälign integers to integers,
<code>Cell</code>s to <code>Cell</code>s, and atomics to atomics, but do not cross these
boundaries.</p>
<h6 id="examples-61"><a href="#examples-61">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">bytes</span>: [<span class="ident">u8</span>; <span class="number">7</span>] <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">bytes</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> (<span class="ident">pfx</span>, <span class="ident">mid</span>, <span class="ident">sfx</span>) <span class="op">=</span> <span class="kw">unsafe</span> {
  <span class="ident">bits</span>.<span class="ident">align_to_mut</span>::<span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;</span>()
};
<span class="macro">assert!</span>(<span class="ident">pfx</span>.<span class="ident">len</span>() <span class="op">&lt;</span><span class="op">=</span> <span class="number">8</span>);
<span class="macro">assert_eq!</span>(<span class="ident">mid</span>.<span class="ident">len</span>(), <span class="number">48</span>);
<span class="macro">assert!</span>(<span class="ident">sfx</span>.<span class="ident">len</span>() <span class="op">&lt;</span><span class="op">=</span> <span class="number">8</span>);</code></pre></div>
</div></details></div><div class="impl-items"><section id="method.to_vec" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2368-2370">source</a></span><a href="#method.to_vec" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.to_vec" class="fnname">to_vec</a>(&amp;self) -&gt; <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Unalias" title="type bitvec::store::BitStore::Unalias">Unalias</a>, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span></code></span></span></span></span></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span> Deprecated: <p>use <code>.to_bitvec()</code> instead</p>
</div></span><details class="rustdoc-toggle method-toggle" open><summary><section id="method.repeat" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice/api.rs.html#2398-2410">source</a></span><a href="#method.repeat" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.repeat" class="fnname">repeat</a>(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Unalias" title="type bitvec::store::BitStore::Unalias">Unalias</a>, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Creates a bit-vector by repeating a bit-slice <code>n</code> times.</p>
<h6 id="original-57"><a href="#original-57">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.repeat"><code>slice::repeat</code></a></p>
<h6 id="panics-13"><a href="#panics-13">Panics</a></h6>
<p>This method panics if <code>self.len() * n</code> exceeds the <code>BitVec</code> capacity.</p>
<h6 id="examples-62"><a href="#examples-62">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].<span class="ident">repeat</span>(<span class="number">3</span>), <span class="macro">bitvec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);</code></pre></div>
<p>This panics by exceeding bit-vector maximum capacity:</p>

<div class='information'><div class='tooltip should_panic'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered should_panic"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].<span class="ident">repeat</span>(<span class="ident">BitSlice</span>::<span class="op">&lt;</span><span class="ident">usize</span>, <span class="ident">Lsb0</span><span class="op">&gt;</span><span class="ident">::MAX_BITS</span>);</code></pre></div>
</div></details></div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_bitptr" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#449-451">source</a></span><a href="#method.as_bitptr" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_bitptr" class="fnname">as_bitptr</a>(&amp;self) -&gt; <a class="struct" href="../ptr/struct.BitPtr.html" title="struct bitvec::ptr::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;</h4></section></summary><div class="docblock"><p>Gets a raw pointer to the zeroth bit of the bit-slice.</p>
<h6 id="original-58"><a href="#original-58">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr"><code>slice::as_ptr</code></a></p>
<h6 id="api-differences-28"><a href="#api-differences-28">API Differences</a></h6>
<p>This is renamed in order to indicate that it is returning a <code>bitvec</code>
structure, not a raw pointer.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_bitptr" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#464-466">source</a></span><a href="#method.as_mut_bitptr" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_mut_bitptr" class="fnname">as_mut_bitptr</a>(&amp;mut self) -&gt; <a class="struct" href="../ptr/struct.BitPtr.html" title="struct bitvec::ptr::BitPtr">BitPtr</a>&lt;<a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T, O&gt;</h4></section></summary><div class="docblock"><p>Gets a raw, write-capable pointer to the zeroth bit of the bit-slice.</p>
<h6 id="original-59"><a href="#original-59">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_mut_ptr"><code>slice::as_mut_ptr</code></a></p>
<h6 id="api-differences-29"><a href="#api-differences-29">API Differences</a></h6>
<p>This is renamed in order to indicate that it is returning a <code>bitvec</code>
structure, not a raw pointer.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_bitptr_range" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#488-490">source</a></span><a href="#method.as_bitptr_range" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_bitptr_range" class="fnname">as_bitptr_range</a>(&amp;self) -&gt; <a class="struct" href="../ptr/struct.BitPtrRange.html" title="struct bitvec::ptr::BitPtrRange">BitPtrRange</a>&lt;<a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../ptr/struct.BitPtrRange.html" title="struct bitvec::ptr::BitPtrRange">BitPtrRange</a>&lt;M, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;M, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../ptr/struct.BitPtrRange.html" title="struct bitvec::ptr::BitPtrRange">BitPtrRange</a>&lt;M, T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../ptr/trait.Mutability.html" title="trait bitvec::ptr::Mutability">Mutability</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="struct" href="../ptr/struct.BitPtr.html" title="struct bitvec::ptr::BitPtr">BitPtr</a>&lt;M, T, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Views the bit-slice as a half-open range of bit-pointers, to its first
bit <em>in</em> the bit-slice and first bit <em>beyond</em> it.</p>
<h6 id="original-60"><a href="#original-60">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_ptr_range"><code>slice::as_ptr_range</code></a></p>
<h6 id="api-differences-30"><a href="#api-differences-30">API Differences</a></h6>
<p>This is renamed to indicate that it returns a <code>bitvec</code> structure, rather
than an ordinary <code>Range</code>.</p>
<h6 id="notes-3"><a href="#notes-3">Notes</a></h6>
<p><code>BitSlice</code> does define a <a href="../slice/struct.BitSlice.html#method.as_ptr_range"><code>.as_ptr_range()</code></a>, which returns a
<code>Range&lt;BitPtr&gt;</code>. <code>BitPtrRange</code> has additional capabilities that
<code>Range&lt;*const T&gt;</code> and <code>Range&lt;BitPtr&gt;</code> do not.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut_bitptr_range" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#510-512">source</a></span><a href="#method.as_mut_bitptr_range" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.as_mut_bitptr_range" class="fnname">as_mut_bitptr_range</a>(&amp;mut self) -&gt; <a class="struct" href="../ptr/struct.BitPtrRange.html" title="struct bitvec::ptr::BitPtrRange">BitPtrRange</a>&lt;<a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../ptr/struct.BitPtrRange.html" title="struct bitvec::ptr::BitPtrRange">BitPtrRange</a>&lt;M, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;M, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../ptr/struct.BitPtrRange.html" title="struct bitvec::ptr::BitPtrRange">BitPtrRange</a>&lt;M, T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: <a class="trait" href="../ptr/trait.Mutability.html" title="trait bitvec::ptr::Mutability">Mutability</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="struct" href="../ptr/struct.BitPtr.html" title="struct bitvec::ptr::BitPtr">BitPtr</a>&lt;M, T, O&gt;;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Views the bit-slice as a half-open range of write-capable bit-pointers,
to its first bit <em>in</em> the bit-slice and the first bit <em>beyond</em> it.</p>
<h6 id="original-61"><a href="#original-61">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.as_mut_ptr_range"><code>slice::as_mut_ptr_range</code></a></p>
<h6 id="api-differences-31"><a href="#api-differences-31">API Differences</a></h6>
<p>This is renamed to indicate that it returns a <code>bitvec</code> structure, rather
than an ordinary <code>Range</code>.</p>
<h6 id="notes-4"><a href="#notes-4">Notes</a></h6>
<p><code>BitSlice</code> does define a [<code>.as_mut_ptr_range()</code>], which returns a
<code>Range&lt;BitPtr&gt;</code>. <code>BitPtrRange</code> has additional capabilities that
<code>Range&lt;*mut T&gt;</code> and <code>Range&lt;BitPtr&gt;</code> do not.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from_bitslice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#552-576">source</a></span><a href="#method.clone_from_bitslice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.clone_from_bitslice" class="fnname">clone_from_bitslice</a>&lt;T2, O2&gt;(&amp;mut self, src: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Copies the bits from <code>src</code> into <code>self</code>.</p>
<p><code>self</code> and <code>src</code> must have the same length.</p>
<h6 id="performance"><a href="#performance">Performance</a></h6>
<p>If <code>src</code> has the same type arguments as <code>self</code>, it will use the same
implementation as <a href="../slice/struct.BitSlice.html#method.copy_from_bitslice"><code>.copy_from_bitslice()</code></a>; if you know that this will
always be the case, you should prefer to use that method directly.</p>
<p>Only <code>.copy_from_bitslice()</code> is <em>able</em> to perform acceleration; this
method is <em>always</em> required to perform a bit-by-bit crawl over both
bit-slices.</p>
<h6 id="original-62"><a href="#original-62">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.clone_from_slice"><code>slice::clone_from_slice</code></a></p>
<h6 id="api-differences-32"><a href="#api-differences-32">API Differences</a></h6>
<p>This is renamed to reflect that it copies from another bit-slice, not
from an element slice.</p>
<p>In order to support general usage, it allows <code>src</code> to have different
type parameters than <code>self</code>, at the cost of performance optimizations.</p>
<h6 id="panics-14"><a href="#panics-14">Panics</a></h6>
<p>This panics if the two bit-slices have different lengths.</p>
<h6 id="examples-63"><a href="#examples-63">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.copy_from_bitslice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#597-654">source</a></span><a href="#method.copy_from_bitslice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.copy_from_bitslice" class="fnname">copy_from_bitslice</a>(&amp;mut self, src: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class="docblock"><p>Copies all bits from <code>src</code> into <code>self</code>, using batched acceleration when
possible.</p>
<p><code>self</code> and <code>src</code> must have the same length.</p>
<h6 id="original-63"><a href="#original-63">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.copy_from_slice"><code>slice::copy_from_slice</code></a></p>
<h6 id="panics-15"><a href="#panics-15">Panics</a></h6>
<p>This panics if the two bit-slices have different lengths.</p>
<h6 id="examples-64"><a href="#examples-64">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.swap_with_bitslice" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#691-717">source</a></span><a href="#method.swap_with_bitslice" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.swap_with_bitslice" class="fnname">swap_with_bitslice</a>&lt;T2, O2&gt;(&amp;mut self, other: &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T2, O2&gt;) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h4></section></summary><div class="docblock"><p>Swaps the contents of two bit-slices.</p>
<p><code>self</code> and <code>other</code> must have the same length.</p>
<h6 id="original-64"><a href="#original-64">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.swap_with_slice"><code>slice::swap_with_slice</code></a></p>
<h6 id="api-differences-33"><a href="#api-differences-33">API Differences</a></h6>
<p>This method is renamed, as it takes a bit-slice rather than an element
slice.</p>
<h6 id="panics-16"><a href="#panics-16">Panics</a></h6>
<p>This panics if the two bit-slices have different lengths.</p>
<h6 id="examples-65"><a href="#examples-65">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">one</span> <span class="op">=</span> [<span class="number">0xA5u8</span>, <span class="number">0x69</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">two</span> <span class="op">=</span> <span class="number">0x1234u16</span>;
<span class="kw">let</span> <span class="ident">one_bits</span> <span class="op">=</span> <span class="ident">one</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();
<span class="kw">let</span> <span class="ident">two_bits</span> <span class="op">=</span> <span class="ident">two</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>();

<span class="ident">one_bits</span>.<span class="ident">swap_with_bitslice</span>(<span class="ident">two_bits</span>);

<span class="macro">assert_eq!</span>(<span class="ident">one</span>, [<span class="number">0x2C</span>, <span class="number">0x48</span>]);
<span class="macro">assert_eq!</span>(<span class="ident">two</span>, <span class="number">0x96A5</span>);</code></pre></div>
</div></details></div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#753-755">source</a></span><a href="#method.set" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.set" class="fnname">set</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Writes a new value into a single bit.</p>
<p>This is the replacement for <code>*slice[index] = value;</code>, as <code>bitvec</code> is not
able to express that under the current <code>IndexMut</code> API signature.</p>
<h6 id="parameters"><a href="#parameters">Parameters</a></h6>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The bit-index to set. It must be in <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The new bit-value to write into the bit at <code>index</code>.</li>
</ul>
<h6 id="panics-17"><a href="#panics-17">Panics</a></h6>
<p>This panics if <code>index</code> is out of bounds.</p>
<h6 id="examples-66"><a href="#examples-66">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">1</span>];
<span class="ident">bits</span>.<span class="ident">set</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
<span class="ident">bits</span>.<span class="ident">set</span>(<span class="number">1</span>, <span class="bool-val">false</span>);

<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_unchecked" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#787-789">source</a></span><a href="#method.set_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.set_unchecked" class="fnname">set_unchecked</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Writes a new value into a single bit, without bounds checking.</p>
<h6 id="parameters-1"><a href="#parameters-1">Parameters</a></h6>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>index</code>: The bit-index to set. It must be in <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The new bit-value to write into the bit at <code>index</code>.</li>
</ul>
<h6 id="safety-6"><a href="#safety-6">Safety</a></h6>
<p>You must ensure that <code>index</code> is in the range <code>0 .. self.len()</code>.</p>
<p>This performs bit-pointer offset arithmetic without doing any bounds
checks. If <code>index</code> is out of bounds, then this will issue an
out-of-bounds access and will trigger memory unsafety.</p>
<h6 id="examples-67"><a href="#examples-67">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()[.. <span class="number">2</span>];
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>.<span class="ident">len</span>(), <span class="number">2</span>);
<span class="kw">unsafe</span> {
  <span class="ident">bits</span>.<span class="ident">set_unchecked</span>(<span class="number">3</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">8</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.replace" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#807-810">source</a></span><a href="#method.replace" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.replace" class="fnname">replace</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Writes a new value into a bit, and returns its previous value.</p>
<h6 id="panics-18"><a href="#panics-18">Panics</a></h6>
<p>This panics if <code>index</code> is not less than <code>self.len()</code>.</p>
<h6 id="examples-68"><a href="#examples-68">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>];
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">bits</span>.<span class="ident">replace</span>(<span class="number">0</span>, <span class="bool-val">true</span>));
<span class="macro">assert!</span>(<span class="ident">bits</span>[<span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.replace_unchecked" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#833-839">source</a></span><a href="#method.replace_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.replace_unchecked" class="fnname">replace_unchecked</a>(&amp;mut self, index: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Writes a new value into a bit, returning the previous value, without
bounds checking.</p>
<h6 id="safety-7"><a href="#safety-7">Safety</a></h6>
<p><code>index</code> must be less than <code>self.len()</code>.</p>
<h6 id="examples-69"><a href="#examples-69">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">old</span> <span class="op">=</span> <span class="kw">unsafe</span> {
  <span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="kw-2">&amp;mut</span> <span class="ident">bits</span>[.. <span class="number">1</span>];
  <span class="ident">a</span>.<span class="ident">replace_unchecked</span>(<span class="number">1</span>, <span class="bool-val">true</span>)
};
<span class="macro">assert!</span>(<span class="op">!</span><span class="ident">old</span>);
<span class="macro">assert!</span>(<span class="ident">bits</span>[<span class="number">1</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.swap_unchecked" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#856-860">source</a></span><a href="#method.swap_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.swap_unchecked" class="fnname">swap_unchecked</a>(&amp;mut self, a: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, b: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Swaps two bits in a bit-slice, without bounds checking.</p>
<p>See <a href="../slice/struct.BitSlice.html#method.swap"><code>.swap()</code></a> for documentation.</p>
<h6 id="safety-8"><a href="#safety-8">Safety</a></h6>
<p>You must ensure that <code>a</code> and <code>b</code> are both in the range <code>0 .. self.len()</code>.</p>
<p>This method performs bit-pointer offset arithmetic without doing any
bounds checks. If <code>a</code> or <code>b</code> are out of bounds, then this will issue an
out-of-bounds access and will trigger memory unsafety.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at_unchecked" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#877-886">source</a></span><a href="#method.split_at_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.split_at_unchecked" class="fnname">split_at_unchecked</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>) -&gt; (<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Self, <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class="docblock"><p>Splits a bit-slice at an index, without bounds checking.</p>
<p>See <a href="../slice/struct.BitSlice.html#method.split_at"><code>.split_at()</code></a> for documentation.</p>
<h6 id="safety-9"><a href="#safety-9">Safety</a></h6>
<p>You must ensure that <code>mid</code> is in the range <code>0 ..= self.len()</code>.</p>
<p>This method produces new bit-slice references. If <code>mid</code> is out of
bounds, its behavior is <strong>library-level</strong> undefined. You must
conservatively assume that an out-of-bounds split point produces
compiler-level UB.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.split_at_unchecked_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#903-914">source</a></span><a href="#method.split_at_unchecked_mut" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.split_at_unchecked_mut" class="fnname">split_at_unchecked_mut</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;mid: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a><br>) -&gt; (&amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;, &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Alias" title="type bitvec::store::BitStore::Alias">Alias</a>, O&gt;)</h4></section></summary><div class="docblock"><p>Splits a mutable bit-slice at an index, without bounds checking.</p>
<p>See <a href="../slice/struct.BitSlice.html#method.split_at_mut"><code>.split_at_mut()</code></a> for documentation.</p>
<h6 id="safety-10"><a href="#safety-10">Safety</a></h6>
<p>You must ensure that <code>mid</code> is in the range <code>0 ..= self.len()</code>.</p>
<p>This method produces new bit-slice references. If <code>mid</code> is out of
bounds, its behavior is <strong>library-level</strong> undefined. You must
conservatively assume that an out-of-bounds split point produces
compiler-level UB.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.copy_within_unchecked" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#950-970">source</a></span><a href="#method.copy_within_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.copy_within_unchecked" class="fnname">copy_within_unchecked</a>&lt;R&gt;(&amp;mut self, src: R, dest: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: <a class="trait" href="../../wyz/range/trait.RangeExt.html" title="trait wyz::range::RangeExt">RangeExt</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>&gt;,&nbsp;</span></h4></section></summary><div class="docblock"><p>Copies bits from one region of the bit-slice to another region of
itself, without doing bounds checks.</p>
<p>The regions are allowed to overlap.</p>
<h6 id="parameters-2"><a href="#parameters-2">Parameters</a></h6>
<ul>
<li><code>&amp;mut self</code></li>
<li><code>src</code>: The range within <code>self</code> from which to copy.</li>
<li><code>dst</code>: The starting index within <code>self</code> at which to paste.</li>
</ul>
<h6 id="effects"><a href="#effects">Effects</a></h6>
<p><code>self[src]</code> is copied to <code>self[dest .. dest + src.len()]</code>. The bits of
<code>self[src]</code> are in an unspecified, but initialized, state.</p>
<h6 id="safety-11"><a href="#safety-11">Safety</a></h6>
<p><code>src.end()</code> and <code>dest + src.len()</code> must be entirely within bounds.</p>
<h6 id="examples-70"><a href="#examples-70">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">data</span> <span class="op">=</span> <span class="number">0b1011_0000u8</span>;
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="ident">data</span>.<span class="ident">view_bits_mut</span>::<span class="op">&lt;</span><span class="ident">Msb0</span><span class="op">&gt;</span>();

<span class="kw">unsafe</span> {
  <span class="ident">bits</span>.<span class="ident">copy_within_unchecked</span>(.. <span class="number">4</span>, <span class="number">2</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">data</span>, <span class="number">0b1010_1100</span>);</code></pre></div>
</div></details></div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bit_domain" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#999-1001">source</a></span><a href="#method.bit_domain" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.bit_domain" class="fnname">bit_domain</a>(&amp;self) -&gt; <a class="enum" href="../domain/enum.BitDomain.html" title="enum bitvec::domain::BitDomain">BitDomain</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;</h4></section></summary><div class="docblock"><p>Partitions a bit-slice into maybe-contended and known-uncontended parts.</p>
<p>The documentation of <code>BitDomain</code> goes into this in more detail. In
short, this produces a <code>&amp;BitSlice</code> that is as large as possible without
requiring alias protection, as well as any bits that were not able to be
included in the unaliased bit-slice.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bit_domain_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1012-1014">source</a></span><a href="#method.bit_domain_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.bit_domain_mut" class="fnname">bit_domain_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../domain/enum.BitDomain.html" title="enum bitvec::domain::BitDomain">BitDomain</a>&lt;'_, <a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T, O&gt;</h4></section></summary><div class="docblock"><p>Partitions a mutable bit-slice into maybe-contended and
known-uncontended parts.</p>
<p>The documentation of <code>BitDomain</code> goes into this in more detail. In
short, this produces a <code>&amp;mut BitSlice</code> that is as large as possible
without requiring alias protection, as well as any bits that were not
able to be included in the unaliased bit-slice.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.domain" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1025-1027">source</a></span><a href="#method.domain" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.domain" class="fnname">domain</a>(&amp;self) -&gt; <a class="enum" href="../domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="enum" href="../domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="enum" href="../domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Views the underlying memory of a bit-slice, removing alias protections
where possible.</p>
<p>The documentation of <code>Domain</code> goes into this in more detail. In short,
this produces a <code>&amp;[T]</code> slice with alias protections removed, covering
all elements that <code>self</code> completely fills. Partially-used elements on
either the front or back edge of the slice are returned separately.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.domain_mut" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1038-1040">source</a></span><a href="#method.domain_mut" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.domain_mut" class="fnname">domain_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'_, <a class="struct" href="../ptr/struct.Mut.html" title="struct bitvec::ptr::Mut">Mut</a>, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="enum" href="../domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="enum" href="../domain/enum.Domain.html" title="enum bitvec::domain::Domain">Domain</a>&lt;'_, <a class="struct" href="../ptr/struct.Const.html" title="struct bitvec::ptr::Const">Const</a>, T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Mem" title="type bitvec::store::BitStore::Mem">Mem</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Views the underlying memory of a bit-slice, removing alias protections
where possible.</p>
<p>The documentation of <code>Domain</code> goes into this in more detail. In short,
this produces a <code>&amp;mut [T]</code> slice with alias protections removed,
covering all elements that <code>self</code> completely fills. Partially-used
elements on the front or back edge of the slice are returned separately.</p>
</div></details></div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.count_ones" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1062-1075">source</a></span><a href="#method.count_ones" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.count_ones" class="fnname">count_ones</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits set to <code>1</code> in the bit-slice contents.</p>
<h6 id="examples-71"><a href="#examples-71">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>[.. <span class="number">2</span>].<span class="ident">count_ones</span>(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>[<span class="number">2</span> ..].<span class="ident">count_ones</span>(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].<span class="ident">count_ones</span>(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.count_zeros" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1090-1109">source</a></span><a href="#method.count_zeros" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.count_zeros" class="fnname">count_zeros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits cleared to <code>0</code> in the bit-slice contents.</p>
<h6 id="examples-72"><a href="#examples-72">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>[.. <span class="number">2</span>].<span class="ident">count_zeros</span>(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>[<span class="number">2</span> ..].<span class="ident">count_zeros</span>(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].<span class="ident">count_zeros</span>(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.iter_ones" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1146-1148">source</a></span><a href="#method.iter_ones" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.iter_ones" class="fnname">iter_ones</a>(&amp;self) -&gt; <a class="struct" href="../slice/struct.IterOnes.html" title="struct bitvec::slice::IterOnes">IterOnes</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.IterOnes.html" title="struct bitvec::slice::IterOnes">IterOnes</a>&lt;'_, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.IterOnes.html" title="struct bitvec::slice::IterOnes">IterOnes</a>&lt;'_, T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Enumerates the index of each bit in a bit-slice set to <code>1</code>.</p>
<p>This is a shorthand for a <code>.enumerate().filter_map()</code> iterator that
selects the index of each <code>true</code> bit; however, its implementation is
eligible for optimizations that the individual-bit iterator is not.</p>
<p>Specializations for the <code>Lsb0</code> and <code>Msb0</code> orderings allow processors
with instructions that seek particular bits within an element to operate
on whole elements, rather than on each bit individually.</p>
<h6 id="examples-73"><a href="#examples-73">Examples</a></h6>
<p>This example uses <code>.iter_ones()</code>, a <code>.filter_map()</code> that finds the index
of each set bit, and the known indices, in order to show that they have
equivalent behavior.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];

<span class="kw">let</span> <span class="ident">iter_ones</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">iter_ones</span>();
<span class="kw">let</span> <span class="ident">known_indices</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>].<span class="ident">iter</span>().<span class="ident">copied</span>();
<span class="kw">let</span> <span class="ident">filter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">iter</span>()
  .<span class="ident">by_vals</span>()
  .<span class="ident">enumerate</span>()
  .<span class="ident">filter_map</span>(<span class="op">|</span>(<span class="ident">idx</span>, <span class="ident">bit</span>)<span class="op">|</span> <span class="kw">if</span> <span class="ident">bit</span> { <span class="prelude-val">Some</span>(<span class="ident">idx</span>) } <span class="kw">else</span> { <span class="prelude-val">None</span> });
<span class="kw">let</span> <span class="ident">all</span> <span class="op">=</span> <span class="ident">iter_ones</span>.<span class="ident">zip</span>(<span class="ident">known_indices</span>).<span class="ident">zip</span>(<span class="ident">filter</span>);

<span class="kw">for</span> ((<span class="ident">iter_one</span>, <span class="ident">known</span>), <span class="ident">filtered</span>) <span class="kw">in</span> <span class="ident">all</span> {
  <span class="macro">assert_eq!</span>(<span class="ident">iter_one</span>, <span class="ident">known</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">known</span>, <span class="ident">filtered</span>);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.iter_zeros" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1185-1187">source</a></span><a href="#method.iter_zeros" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.iter_zeros" class="fnname">iter_zeros</a>(&amp;self) -&gt; <a class="struct" href="../slice/struct.IterZeros.html" title="struct bitvec::slice::IterZeros">IterZeros</a>&lt;'_, T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../slice/struct.IterZeros.html" title="struct bitvec::slice::IterZeros">IterZeros</a>&lt;'_, T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a> for <a class="struct" href="../slice/struct.IterZeros.html" title="struct bitvec::slice::IterZeros">IterZeros</a>&lt;'_, T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></span><span class="where fmt-newline">    type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/iterator/trait.Iterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>;</span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Enumerates the index of each bit in a bit-slice cleared to <code>0</code>.</p>
<p>This is a shorthand for a <code>.enumerate().filter_map()</code> iterator that
selects the index of each <code>false</code> bit; however, its implementation is
eligible for optimizations that the individual-bit iterator is not.</p>
<p>Specializations for the <code>Lsb0</code> and <code>Msb0</code> orderings allow processors
with instructions that seek particular bits within an element to operate
on whole elements, rather than on each bit individually.</p>
<h6 id="examples-74"><a href="#examples-74">Examples</a></h6>
<p>This example uses <code>.iter_zeros()</code>, a <code>.filter_map()</code> that finds the
index of each cleared bit, and the known indices, in order to show that
they have equivalent behavior.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>];

<span class="kw">let</span> <span class="ident">iter_zeros</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">iter_zeros</span>();
<span class="kw">let</span> <span class="ident">known_indices</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>].<span class="ident">iter</span>().<span class="ident">copied</span>();
<span class="kw">let</span> <span class="ident">filter</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">iter</span>()
  .<span class="ident">by_vals</span>()
  .<span class="ident">enumerate</span>()
  .<span class="ident">filter_map</span>(<span class="op">|</span>(<span class="ident">idx</span>, <span class="ident">bit</span>)<span class="op">|</span> <span class="kw">if</span> <span class="op">!</span><span class="ident">bit</span> { <span class="prelude-val">Some</span>(<span class="ident">idx</span>) } <span class="kw">else</span> { <span class="prelude-val">None</span> });
<span class="kw">let</span> <span class="ident">all</span> <span class="op">=</span> <span class="ident">iter_zeros</span>.<span class="ident">zip</span>(<span class="ident">known_indices</span>).<span class="ident">zip</span>(<span class="ident">filter</span>);

<span class="kw">for</span> ((<span class="ident">iter_zero</span>, <span class="ident">known</span>), <span class="ident">filtered</span>) <span class="kw">in</span> <span class="ident">all</span> {
  <span class="macro">assert_eq!</span>(<span class="ident">iter_zero</span>, <span class="ident">known</span>);
  <span class="macro">assert_eq!</span>(<span class="ident">known</span>, <span class="ident">filtered</span>);
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.first_one" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1203-1205">source</a></span><a href="#method.first_one" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.first_one" class="fnname">first_one</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Finds the index of the first bit in the bit-slice set to <code>1</code>.</p>
<p>Returns <code>None</code> if there is no <code>true</code> bit in the bit-slice.</p>
<h6 id="examples-75"><a href="#examples-75">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].<span class="ident">first_one</span>().<span class="ident">is_none</span>());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].<span class="ident">first_one</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].<span class="ident">first_one</span>(), <span class="prelude-val">Some</span>(<span class="number">1</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.first_zero" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1221-1223">source</a></span><a href="#method.first_zero" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.first_zero" class="fnname">first_zero</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Finds the index of the first bit in the bit-slice cleared to <code>0</code>.</p>
<p>Returns <code>None</code> if there is no <code>false</code> bit in the bit-slice.</p>
<h6 id="examples-76"><a href="#examples-76">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].<span class="ident">first_zero</span>().<span class="ident">is_none</span>());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">1</span>].<span class="ident">first_zero</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>].<span class="ident">first_zero</span>(), <span class="prelude-val">Some</span>(<span class="number">1</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.last_one" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1239-1241">source</a></span><a href="#method.last_one" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.last_one" class="fnname">last_one</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Finds the index of the last bit in the bit-slice set to <code>1</code>.</p>
<p>Returns <code>None</code> if there is no <code>true</code> bit in the bit-slice.</p>
<h6 id="examples-77"><a href="#examples-77">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].<span class="ident">last_one</span>().<span class="ident">is_none</span>());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].<span class="ident">last_one</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>].<span class="ident">last_one</span>(), <span class="prelude-val">Some</span>(<span class="number">0</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.last_zero" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1257-1259">source</a></span><a href="#method.last_zero" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.last_zero" class="fnname">last_zero</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Finds the index of the last bit in the bit-slice cleared to <code>0</code>.</p>
<p>Returns <code>None</code> if there is no <code>false</code> bit in the bit-slice.</p>
<h6 id="examples-78"><a href="#examples-78">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="macro">bits!</span>[].<span class="ident">last_zero</span>().<span class="ident">is_none</span>());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">1</span>].<span class="ident">last_zero</span>().<span class="ident">is_none</span>());
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].<span class="ident">last_zero</span>(), <span class="prelude-val">Some</span>(<span class="number">0</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.leading_ones" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1276-1278">source</a></span><a href="#method.leading_ones" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.leading_ones" class="fnname">leading_ones</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the start of the bit-slice to the first
bit set to <code>0</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h6 id="examples-79"><a href="#examples-79">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].<span class="ident">leading_ones</span>(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].<span class="ident">leading_ones</span>(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>].<span class="ident">leading_ones</span>(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.leading_zeros" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1295-1297">source</a></span><a href="#method.leading_zeros" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.leading_zeros" class="fnname">leading_zeros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the start of the bit-slice to the first
bit set to <code>1</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h6 id="examples-80"><a href="#examples-80">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].<span class="ident">leading_zeros</span>(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>].<span class="ident">leading_zeros</span>(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].<span class="ident">leading_zeros</span>(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.trailing_ones" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1314-1317">source</a></span><a href="#method.trailing_ones" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trailing_ones" class="fnname">trailing_ones</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the end of the bit-slice to the last bit
set to <code>0</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h6 id="examples-81"><a href="#examples-81">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].<span class="ident">trailing_ones</span>(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>].<span class="ident">trailing_ones</span>(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].<span class="ident">trailing_ones</span>(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.trailing_zeros" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1334-1337">source</a></span><a href="#method.trailing_zeros" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.trailing_zeros" class="fnname">trailing_zeros</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Counts the number of bits from the end of the bit-slice to the last bit
set to <code>1</code>.</p>
<p>This returns <code>0</code> if the bit-slice is empty.</p>
<h6 id="examples-82"><a href="#examples-82">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[].<span class="ident">trailing_zeros</span>(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>].<span class="ident">trailing_zeros</span>(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>].<span class="ident">trailing_zeros</span>(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.any" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1353-1355">source</a></span><a href="#method.any" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.any" class="fnname">any</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if there is at least one bit set to <code>1</code> in the bit-slice.</p>
<p>Returns <code>false</code> when <code>self</code> is empty.</p>
<h6 id="examples-83"><a href="#examples-83">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="op">!</span><span class="macro">bits!</span>[].<span class="ident">any</span>());
<span class="macro">assert!</span>(<span class="op">!</span><span class="macro">bits!</span>[<span class="number">0</span>].<span class="ident">any</span>());
<span class="macro">assert!</span>(<span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].<span class="ident">any</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.all" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1371-1373">source</a></span><a href="#method.all" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.all" class="fnname">all</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if every bit is set to <code>1</code> in the bit-slice.</p>
<p>Returns <code>true</code> when <code>self</code> is empty.</p>
<h6 id="examples-84"><a href="#examples-84">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert!</span>( <span class="macro">bits!</span>[].<span class="ident">all</span>());
<span class="macro">assert!</span>(<span class="op">!</span><span class="macro">bits!</span>[<span class="number">0</span>].<span class="ident">all</span>());
<span class="macro">assert!</span>( <span class="macro">bits!</span>[<span class="number">1</span>].<span class="ident">all</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.not_any" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1389-1391">source</a></span><a href="#method.not_any" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.not_any" class="fnname">not_any</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if every bit is cleared to <code>0</code> in the bit-slice.</p>
<p>Returns <code>true</code> when <code>self</code> is empty.</p>
<h6 id="examples-85"><a href="#examples-85">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert!</span>( <span class="macro">bits!</span>[].<span class="ident">not_any</span>());
<span class="macro">assert!</span>(<span class="op">!</span><span class="macro">bits!</span>[<span class="number">1</span>].<span class="ident">not_any</span>());
<span class="macro">assert!</span>( <span class="macro">bits!</span>[<span class="number">0</span>].<span class="ident">not_any</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.not_all" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1407-1409">source</a></span><a href="#method.not_all" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.not_all" class="fnname">not_all</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if at least one bit is cleared to <code>0</code> in the bit-slice.</p>
<p>Returns <code>false</code> when <code>self</code> is empty.</p>
<h6 id="examples-86"><a href="#examples-86">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="op">!</span><span class="macro">bits!</span>[].<span class="ident">not_all</span>());
<span class="macro">assert!</span>(<span class="op">!</span><span class="macro">bits!</span>[<span class="number">1</span>].<span class="ident">not_all</span>());
<span class="macro">assert!</span>( <span class="macro">bits!</span>[<span class="number">0</span>].<span class="ident">not_all</span>());</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.some" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1427-1429">source</a></span><a href="#method.some" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.some" class="fnname">some</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Tests if at least one bit is set to <code>1</code>, and at least one bit is cleared
to <code>0</code>, in the bit-slice.</p>
<p>Returns <code>false</code> when <code>self</code> is empty.</p>
<h6 id="examples-87"><a href="#examples-87">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="macro">assert!</span>(<span class="op">!</span><span class="macro">bits!</span>[].<span class="ident">some</span>());
<span class="macro">assert!</span>(<span class="op">!</span><span class="macro">bits!</span>[<span class="number">0</span>].<span class="ident">some</span>());
<span class="macro">assert!</span>(<span class="op">!</span><span class="macro">bits!</span>[<span class="number">1</span>].<span class="ident">some</span>());
<span class="macro">assert!</span>( <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>].<span class="ident">some</span>());</code></pre></div>
</div></details></div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shift_left" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1474-1494">source</a></span><a href="#method.shift_left" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.shift_left" class="fnname">shift_left</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Shifts the contents of a bit-slice “left” (towards the zero-index),
clearing the “right” bits to <code>0</code>.</p>
<p>This is a strictly-worse analogue to taking <code>bits = &amp;bits[by ..]</code>: it
has to modify the entire memory region that <code>bits</code> governs, and destroys
contained information. Unless the actual memory layout and contents of
your bit-slice matters to your program, you should <em>probably</em> prefer to
munch your way forward through a bit-slice handle.</p>
<p>Note also that the “left” here is semantic only, and <strong>does not</strong>
necessarily correspond to a left-shift instruction applied to the
underlying integer storage.</p>
<p>This has no effect when <code>by</code> is <code>0</code>. When <code>by</code> is <code>self.len()</code>, the
bit-slice is entirely cleared to <code>0</code>.</p>
<h6 id="panics-19"><a href="#panics-19">Panics</a></h6>
<p>This panics if <code>by</code> is not less than <code>self.len()</code>.</p>
<h6 id="examples-88"><a href="#examples-88">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="comment">// these bits are retained ^--------------------------^</span>
<span class="ident">bits</span>.<span class="ident">shift_left</span>(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]);
<span class="comment">// and move here       ^--------------------------^</span>

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">1</span>; <span class="number">2</span>];
<span class="ident">bits</span>.<span class="ident">shift_left</span>(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.shift_right" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1532-1552">source</a></span><a href="#method.shift_right" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.shift_right" class="fnname">shift_right</a>(&amp;mut self, by: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>)</h4></section></summary><div class="docblock"><p>Shifts the contents of a bit-slice “right” (away from the zero-index),
clearing the “left” bits to <code>0</code>.</p>
<p>This is a strictly-worse analogue to taking `bits = &amp;bits[.. bits.len()</p>
<ul>
<li>by]<code>: it must modify the entire memory region that </code>bits` governs, and
destroys contained information. Unless the actual memory layout and
contents of your bit-slice matters to your program, you should
<em>probably</em> prefer to munch your way backward through a bit-slice handle.</li>
</ul>
<p>Note also that the “right” here is semantic only, and <strong>does not</strong>
necessarily correspond to a right-shift instruction applied to the
underlying integer storage.</p>
<p>This has no effect when <code>by</code> is <code>0</code>. When <code>by</code> is <code>self.len()</code>, the
bit-slice is entirely cleared to <code>0</code>.</p>
<h6 id="panics-20"><a href="#panics-20">Panics</a></h6>
<p>This panics if <code>by</code> is not less than <code>self.len()</code>.</p>
<h6 id="examples-89"><a href="#examples-89">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>];
<span class="comment">// these bits stay   ^--------------------------^</span>
<span class="ident">bits</span>.<span class="ident">shift_right</span>(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>]);
<span class="comment">// and move here             ^--------------------------^</span>

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="kw-2">mut</span> <span class="number">1</span>; <span class="number">2</span>];
<span class="ident">bits</span>.<span class="ident">shift_right</span>(<span class="number">2</span>);
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">0</span>; <span class="number">2</span>]);</code></pre></div>
</div></details></div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_aliased" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1674-1679">source</a></span><a href="#method.set_aliased" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.set_aliased" class="fnname">set_aliased</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Writes a new value into a single bit, using alias-safe operations.</p>
<p>This is equivalent to <a href="../slice/struct.BitSlice.html#method.set"><code>.set()</code></a>, except that it does not require an
<code>&amp;mut</code> reference, and allows bit-slices with alias-safe storage to share
write permissions.</p>
<h6 id="parameters-3"><a href="#parameters-3">Parameters</a></h6>
<ul>
<li><code>&amp;self</code>: This method only exists on bit-slices with alias-safe
storage, and so does not require exclusive access.</li>
<li><code>index</code>: The bit index to set. It must be in <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The new bit-value to write into the bit at <code>index</code>.</li>
</ul>
<h6 id="panics-21"><a href="#panics-21">Panics</a></h6>
<p>This panics if <code>index</code> is out of bounds.</p>
<h6 id="examples-90"><a href="#examples-90">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">core::cell::Cell</span>;

<span class="kw">let</span> <span class="ident">bits</span>: <span class="kw-2">&amp;</span><span class="ident">BitSlice</span><span class="op">&lt;</span><span class="kw">_</span>, <span class="kw">_</span><span class="op">&gt;</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="ident">Cell</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span>, <span class="ident">Lsb0</span>; <span class="number">0</span>, <span class="number">1</span>];
<span class="ident">bits</span>.<span class="ident">set_aliased</span>(<span class="number">0</span>, <span class="bool-val">true</span>);
<span class="ident">bits</span>.<span class="ident">set_aliased</span>(<span class="number">1</span>, <span class="bool-val">false</span>);

<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="macro">bits!</span>[<span class="number">1</span>, <span class="number">0</span>]);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_aliased_unchecked" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1715-1717">source</a></span><a href="#method.set_aliased_unchecked" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.set_aliased_unchecked" class="fnname">set_aliased_unchecked</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a>, value: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a>)</h4></section></summary><div class="docblock"><p>Writes a new value into a single bit, using alias-safe operations and
without bounds checking.</p>
<p>This is equivalent to <a href="../slice/struct.BitSlice.html#method.set_unchecked"><code>.set_unchecked()</code></a>, except that it does not
require an <code>&amp;mut</code> reference, and allows bit-slices with alias-safe
storage to share write permissions.</p>
<h6 id="parameters-4"><a href="#parameters-4">Parameters</a></h6>
<ul>
<li><code>&amp;self</code>: This method only exists on bit-slices with alias-safe
storage, and so does not require exclusive access.</li>
<li><code>index</code>: The bit index to set. It must be in <code>0 .. self.len()</code>.</li>
<li><code>value</code>: The new bit-value to write into the bit at <code>index</code>.</li>
</ul>
<h6 id="safety-12"><a href="#safety-12">Safety</a></h6>
<p>The caller must ensure that <code>index</code> is not out of bounds.</p>
<h6 id="examples-91"><a href="#examples-91">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">core::cell::Cell</span>;

<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="ident">Cell::new</span>(<span class="number">0u8</span>);
<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">data</span>.<span class="ident">view_bits</span>::<span class="op">&lt;</span><span class="ident">Lsb0</span><span class="op">&gt;</span>()[.. <span class="number">2</span>];
<span class="kw">unsafe</span> {
  <span class="ident">bits</span>.<span class="ident">set_aliased_unchecked</span>(<span class="number">3</span>, <span class="bool-val">true</span>);
}
<span class="macro">assert_eq!</span>(<span class="ident">data</span>.<span class="ident">get</span>(), <span class="number">8</span>);</code></pre></div>
</div></details></div><div class="impl-items"><section id="associatedconstant.MAX_BITS" class="associatedconstant has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1735">source</a></span><a href="#associatedconstant.MAX_BITS" class="anchor"></a><h4 class="code-header">pub const <a href="#associatedconstant.MAX_BITS" class="constant">MAX_BITS</a>: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a> = 2_305_843_009_213_693_951usize</h4></section><section id="associatedconstant.MAX_ELTS" class="associatedconstant has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1751">source</a></span><a href="#associatedconstant.MAX_ELTS" class="anchor"></a><h4 class="code-header">pub const <a href="#associatedconstant.MAX_ELTS" class="constant">MAX_ELTS</a>: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.usize.html">usize</a> = BitSpan::<Const, T, O>::REGION_MAX_ELTS</h4></section></div><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_bitvec" class="method has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/slice.rs.html#1783-1792">source</a></span><a href="#method.to_bitvec" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.to_bitvec" class="fnname">to_bitvec</a>(&amp;self) -&gt; <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T::<a class="associatedtype" href="../store/trait.BitStore.html#associatedtype.Unalias" title="type bitvec::store::BitStore::Unalias">Unalias</a>, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span></code></span></span></span></span></h4></section></summary><div class="docblock"><p>Copies a bit-slice into an owned bit-vector.</p>
<p>Since the new vector is freshly owned, this gets marked as <code>::Unalias</code>
to remove any guards that may have been inserted by the bit-slice’s
history.</p>
<p>It does <em>not</em> use the underlying memory type, so that a <code>BitSlice&lt;_, Cell&lt;_&gt;&gt;</code> will produce a <code>BitVec&lt;_, Cell&lt;_&gt;&gt;</code>.</p>
<h6 id="original-65"><a href="#original-65">Original</a></h6>
<p><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.to_vec"><code>slice::to_vec</code></a></p>
<h6 id="examples-92"><a href="#examples-92">Examples</a></h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">bitvec::prelude</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">bits</span> <span class="op">=</span> <span class="macro">bits!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let</span> <span class="ident">bv</span> <span class="op">=</span> <span class="ident">bits</span>.<span class="ident">to_bitvec</span>();
<span class="macro">assert_eq!</span>(<span class="ident">bits</span>, <span class="ident">bv</span>);</code></pre></div>
</div></details></div></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsMut%3CBitSlice%3CT%2C%20O%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#218-227">source</a></span><a href="#impl-AsMut%3CBitSlice%3CT%2C%20O%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#224-226">source</a></span><a href="#method.as_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.AsMut.html#tymethod.as_mut" class="fnname">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'><p>Converts this type into a mutable reference of the (usually inferred) input type.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#206-215">source</a></span><a href="#impl-AsRef%3CBitSlice%3CT%2C%20O%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_ref" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#212-214">source</a></span><a href="#method.as_ref" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.AsRef.html#tymethod.as_ref" class="fnname">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'><p>Converts this type into a shared reference of the (usually inferred) input type.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Binary" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#335-343">source</a></span><a href="#impl-Binary" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Binary.html" title="trait core::fmt::Binary">Binary</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#335-343">source</a></span><a href="#method.fmt-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Binary.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.63.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.63.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'><p>Formats the value using the given formatter.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitAnd%3CRhs%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#51-64">source</a></span><a href="#impl-BitAnd%3CRhs%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitAnd.html" title="trait core::ops::bit::BitAnd">BitAnd</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;Rhs&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitAnd.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'><p>The resulting type after applying the <code>&amp;</code> operator.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitand" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#60-63">source</a></span><a href="#method.bitand" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitAnd.html#tymethod.bitand" class="fnname">bitand</a>(self, rhs: Rhs) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitAnd.html#associatedtype.Output" title="type core::ops::bit::BitAnd::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the <code>&amp;</code> operation. <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitAnd.html#tymethod.bitand">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitAndAssign%3C%26BitBox%3CT%2C%20O%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#40-49">source</a></span><a href="#impl-BitAndAssign%3C%26BitBox%3CT%2C%20O%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;&amp;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;&gt; for <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitand_assign-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#46-48">source</a></span><a href="#method.bitand_assign-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign" class="fnname">bitand_assign</a>(&amp;mut self, rhs: &amp;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'><p>Performs the <code>&amp;=</code> operation. <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitAndAssign%3CBitBox%3CT%2C%20O%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#28-37">source</a></span><a href="#impl-BitAndAssign%3CBitBox%3CT%2C%20O%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;&gt; for <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitand_assign" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#34-36">source</a></span><a href="#method.bitand_assign" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign" class="fnname">bitand_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'><p>Performs the <code>&amp;=</code> operation. <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitAndAssign%3CRhs%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#66-76">source</a></span><a href="#impl-BitAndAssign%3CRhs%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitAndAssign.html" title="trait core::ops::bit::BitAndAssign">BitAndAssign</a>&lt;Rhs&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitand_assign-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#73-75">source</a></span><a href="#method.bitand_assign-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign" class="fnname">bitand_assign</a>(&amp;mut self, rhs: Rhs)</h4></section></summary><div class='docblock'><p>Performs the <code>&amp;=</code> operation. <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitAndAssign.html#tymethod.bitand_assign">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitField" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/field.rs.html#445-474">source</a></span><a href="#impl-BitField" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.load_le" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/field.rs.html#452-455">source</a></span><a href="#method.load_le" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.load_le" class="fnname">load_le</a>&lt;I&gt;(&amp;self) -&gt; I <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../funty/trait.Integral.html" title="trait funty::Integral">Integral</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Little-Endian Integer Loading <a href="../field/trait.BitField.html#tymethod.load_le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.load_be" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/field.rs.html#458-461">source</a></span><a href="#method.load_be" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.load_be" class="fnname">load_be</a>&lt;I&gt;(&amp;self) -&gt; I <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../funty/trait.Integral.html" title="trait funty::Integral">Integral</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Big-Endian Integer Loading <a href="../field/trait.BitField.html#tymethod.load_be">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.store_le" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/field.rs.html#464-467">source</a></span><a href="#method.store_le" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.store_le" class="fnname">store_le</a>&lt;I&gt;(&amp;mut self, value: I) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../funty/trait.Integral.html" title="trait funty::Integral">Integral</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Little-Endian Integer Storing <a href="../field/trait.BitField.html#tymethod.store_le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.store_be" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/field.rs.html#470-473">source</a></span><a href="#method.store_be" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#tymethod.store_be" class="fnname">store_be</a>&lt;I&gt;(&amp;mut self, value: I) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../funty/trait.Integral.html" title="trait funty::Integral">Integral</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Big-Endian Integer Storing <a href="../field/trait.BitField.html#tymethod.store_be">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.load" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/field.rs.html#46-67">source</a></span><a href="#method.load" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#method.load" class="fnname">load</a>&lt;I&gt;(&amp;self) -&gt; I <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../funty/trait.Integral.html" title="trait funty::Integral">Integral</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Integer Loading <a href="../field/trait.BitField.html#method.load">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.store" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/field.rs.html#72-93">source</a></span><a href="#method.store" class="anchor"></a><h4 class="code-header">fn <a href="../field/trait.BitField.html#method.store" class="fnname">store</a>&lt;I&gt;(&amp;mut self, value: I) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;I: <a class="trait" href="../../funty/trait.Integral.html" title="trait funty::Integral">Integral</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Integer Storing <a href="../field/trait.BitField.html#method.store">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitOr%3CRhs%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#102-115">source</a></span><a href="#impl-BitOr%3CRhs%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitOr.html" title="trait core::ops::bit::BitOr">BitOr</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;Rhs&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitOr.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'><p>The resulting type after applying the <code>|</code> operator.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitor" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#111-114">source</a></span><a href="#method.bitor" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitOr.html#tymethod.bitor" class="fnname">bitor</a>(self, rhs: Rhs) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitOr.html#associatedtype.Output" title="type core::ops::bit::BitOr::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the <code>|</code> operation. <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitOr.html#tymethod.bitor">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitOrAssign%3C%26BitBox%3CT%2C%20O%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#91-100">source</a></span><a href="#impl-BitOrAssign%3C%26BitBox%3CT%2C%20O%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;&amp;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;&gt; for <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitor_assign-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#97-99">source</a></span><a href="#method.bitor_assign-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign" class="fnname">bitor_assign</a>(&amp;mut self, rhs: &amp;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'><p>Performs the <code>|=</code> operation. <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitOrAssign%3CBitBox%3CT%2C%20O%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#79-88">source</a></span><a href="#impl-BitOrAssign%3CBitBox%3CT%2C%20O%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;&gt; for <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitor_assign" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#85-87">source</a></span><a href="#method.bitor_assign" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign" class="fnname">bitor_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'><p>Performs the <code>|=</code> operation. <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitOrAssign%3CRhs%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#117-127">source</a></span><a href="#impl-BitOrAssign%3CRhs%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitOrAssign.html" title="trait core::ops::bit::BitOrAssign">BitOrAssign</a>&lt;Rhs&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitor_assign-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#124-126">source</a></span><a href="#method.bitor_assign-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign" class="fnname">bitor_assign</a>(&amp;mut self, rhs: Rhs)</h4></section></summary><div class='docblock'><p>Performs the <code>|=</code> operation. <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitOrAssign.html#tymethod.bitor_assign">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitXor%3CRhs%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#153-166">source</a></span><a href="#impl-BitXor%3CRhs%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitXor.html" title="trait core::ops::bit::BitXor">BitXor</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;Rhs&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-2" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-2" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitXor.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'><p>The resulting type after applying the <code>^</code> operator.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitxor" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#162-165">source</a></span><a href="#method.bitxor" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitXor.html#tymethod.bitxor" class="fnname">bitxor</a>(self, rhs: Rhs) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitXor.html#associatedtype.Output" title="type core::ops::bit::BitXor::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the <code>^</code> operation. <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitXor.html#tymethod.bitxor">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitXorAssign%3C%26BitBox%3CT%2C%20O%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#142-151">source</a></span><a href="#impl-BitXorAssign%3C%26BitBox%3CT%2C%20O%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;&amp;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;&gt; for <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitxor_assign-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#148-150">source</a></span><a href="#method.bitxor_assign-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign" class="fnname">bitxor_assign</a>(&amp;mut self, rhs: &amp;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'><p>Performs the <code>^=</code> operation. <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitXorAssign%3CBitBox%3CT%2C%20O%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#130-139">source</a></span><a href="#impl-BitXorAssign%3CBitBox%3CT%2C%20O%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;&gt; for <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitxor_assign" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#136-138">source</a></span><a href="#method.bitxor_assign" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign" class="fnname">bitxor_assign</a>(&amp;mut self, rhs: <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;)</h4></section></summary><div class='docblock'><p>Performs the <code>^=</code> operation. <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BitXorAssign%3CRhs%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#168-178">source</a></span><a href="#impl-BitXorAssign%3CRhs%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitXorAssign.html" title="trait core::ops::bit::BitXorAssign">BitXorAssign</a>&lt;Rhs&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.bitxor_assign-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#175-177">source</a></span><a href="#method.bitxor_assign-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign" class="fnname">bitxor_assign</a>(&amp;mut self, rhs: Rhs)</h4></section></summary><div class='docblock'><p>Performs the <code>^=</code> operation. <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.BitXorAssign.html#tymethod.bitxor_assign">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Borrow%3CBitSlice%3CT%2C%20O%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#40-49">source</a></span><a href="#impl-Borrow%3CBitSlice%3CT%2C%20O%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#46-48">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-BorrowMut%3CBitSlice%3CT%2C%20O%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#52-61">source</a></span><a href="#impl-BorrowMut%3CBitSlice%3CT%2C%20O%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#58-60">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;<span class="notable-traits"><span class="notable-traits-tooltip">ⓘ<span class="notable-traits-tooltiptext"><span class="docblock"><span class="notable">Notable traits for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</span><code class="content"><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Read.html" title="trait std::io::Read">Read</a> for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span><span class="where fmt-newline">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/std/io/trait.Write.html" title="trait std::io::Write">Write</a> for &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="../field/trait.BitField.html" title="trait bitvec::field::BitField">BitField</a>,&nbsp;</span></span></code></span></span></span></span></h4></section></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Clone" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#64-73">source</a></span><a href="#impl-Clone" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#70-72">source</a></span><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; Self</h4></section></summary><div class='docblock'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/1.63.0/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/clone.rs.html#133-135">source</a></span><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Self)</h4></section></summary><div class='docblock'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/1.63.0/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#322-333">source</a></span><a href="#impl-Debug" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#328-332">source</a></span><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.63.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.63.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Default" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#311-320">source</a></span><a href="#impl-Default" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/default/trait.Default.html" title="trait core::default::Default">Default</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.default" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#317-319">source</a></span><a href="#method.default" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/default/trait.Default.html#tymethod.default" class="fnname">default</a>() -&gt; Self</h4></section></summary><div class='docblock'><p>Returns the “default value” for a type. <a href="https://doc.rust-lang.org/1.63.0/core/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Deref" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#180-191">source</a></span><a href="#impl-Deref" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Target" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Target" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.63.0/core/ops/deref/trait.Deref.html#associatedtype.Target" class="associatedtype">Target</a> = <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'><p>The resulting type after dereferencing.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#188-190">source</a></span><a href="#method.deref" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/ops/deref/trait.Deref.html#tymethod.deref" class="fnname">deref</a>(&amp;self) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a></h4></section></summary><div class='docblock'><p>Dereferences the value.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-DerefMut" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#193-202">source</a></span><a href="#impl-DerefMut" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#199-201">source</a></span><a href="#method.deref_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/ops/deref/trait.DerefMut.html#tymethod.deref_mut" class="fnname">deref_mut</a>(&amp;mut self) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/ops/deref/trait.Deref.html#associatedtype.Target" title="type core::ops::deref::Deref::Target">Target</a></h4></section></summary><div class='docblock'><p>Mutably dereferences the value.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Display" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#335-343">source</a></span><a href="#impl-Display" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#335-343">source</a></span><a href="#method.fmt-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Display.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.63.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.63.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Display.html#tymethod.fmt">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Drop" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#204-213">source</a></span><a href="#impl-Drop" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#210-212">source</a></span><a href="#method.drop" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/ops/drop/trait.Drop.html#tymethod.drop" class="fnname">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'><p>Executes the destructor for this type. <a href="https://doc.rust-lang.org/1.63.0/core/ops/drop/trait.Drop.html#tymethod.drop">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3C%26BitSlice%3CT%2C%20O%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#229-238">source</a></span><a href="#impl-From%3C%26BitSlice%3CT%2C%20O%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;&amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#235-237">source</a></span><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(slice: &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;) -&gt; Self</h4></section></summary><div class='docblock'><p>Converts to this type from the input type.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CBitArray%3CA%2C%20O%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#240-249">source</a></span><a href="#impl-From%3CBitArray%3CA%2C%20O%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;A, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;A::<a class="associatedtype" href="../view/trait.BitView.html#associatedtype.Store" title="type bitvec::view::BitView::Store">Store</a>, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: <a class="trait" href="../view/trait.BitViewSized.html" title="trait bitvec::view::BitViewSized">BitViewSized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#246-248">source</a></span><a href="#method.from-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(array: <a class="struct" href="../array/struct.BitArray.html" title="struct bitvec::array::BitArray">BitArray</a>&lt;A, O&gt;) -&gt; Self</h4></section></summary><div class='docblock'><p>Converts to this type from the input type.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CBitBox%3CT%2C%20O%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#287-296">source</a></span><a href="#impl-From%3CBitBox%3CT%2C%20O%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;&gt; for <a class="struct" href="https://doc.rust-lang.org/1.63.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.slice.html">[T]</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-5" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#293-295">source</a></span><a href="#method.from-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(bb: <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;) -&gt; Self</h4></section></summary><div class='docblock'><p>Converts to this type from the input type.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CBitBox%3CT%2C%20O%3E%3E-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#290-299">source</a></span><a href="#impl-From%3CBitBox%3CT%2C%20O%3E%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;&gt; for <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-6" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/vec/traits.rs.html#296-298">source</a></span><a href="#method.from-6" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(boxed: <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;) -&gt; Self</h4></section></summary><div class='docblock'><p>Converts to this type from the input type.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CBitVec%3CT%2C%20O%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#276-285">source</a></span><a href="#impl-From%3CBitVec%3CT%2C%20O%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-4" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#282-284">source</a></span><a href="#method.from-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(bv: <a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;) -&gt; Self</h4></section></summary><div class='docblock'><p>Converts to this type from the input type.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CBox%3CT%2C%20Global%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#251-263">source</a></span><a href="#impl-From%3CBox%3CT%2C%20Global%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.63.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;T, <a class="struct" href="https://doc.rust-lang.org/1.63.0/alloc/alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt;&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#257-262">source</a></span><a href="#method.from-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(elem: <a class="struct" href="https://doc.rust-lang.org/1.63.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;T&gt;) -&gt; Self</h4></section></summary><div class='docblock'><p>Converts to this type from the input type.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CCow%3C%27a%2C%20BitSlice%3CT%2C%20O%3E%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#265-274">source</a></span><a href="#impl-From%3CCow%3C%27a%2C%20BitSlice%3CT%2C%20O%3E%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.63.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt;&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#271-273">source</a></span><a href="#method.from-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(cow: <a class="enum" href="https://doc.rust-lang.org/1.63.0/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt;) -&gt; Self</h4></section></summary><div class='docblock'><p>Converts to this type from the input type.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-FromIterator%3CI%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#346-357">source</a></span><a href="#impl-FromIterator%3CI%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O, I&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;I&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../vec/struct.BitVec.html" title="struct bitvec::vec::BitVec">BitVec</a>&lt;T, O&gt;: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/collect/trait.FromIterator.html" title="trait core::iter::traits::collect::FromIterator">FromIterator</a>&lt;I&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from_iter" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#353-356">source</a></span><a href="#method.from_iter" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter" class="fnname">from_iter</a>&lt;II&gt;(iter: II) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;II: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&lt;Item = I&gt;,&nbsp;</span></h4></section></summary><div class='docblock'><p>Creates a value from an iterator. <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/collect/trait.FromIterator.html#tymethod.from_iter">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Hash" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#360-370">source</a></span><a href="#impl-Hash" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/hash/trait.Hash.html" title="trait core::hash::Hash">Hash</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#366-369">source</a></span><a href="#method.hash" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/hash/trait.Hash.html#tymethod.hash" class="fnname">hash</a>&lt;H&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Feeds this value into the given <a href="https://doc.rust-lang.org/1.63.0/core/hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.63.0/core/hash/trait.Hash.html#tymethod.hash">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/hash/mod.rs.html#237-239">source</a></span><a href="#method.hash_slice" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/hash/trait.Hash.html#method.hash_slice" class="fnname">hash_slice</a>&lt;H&gt;(data: &amp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.slice.html">[Self]</a>, state: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>H) <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/hash/trait.Hasher.html" title="trait core::hash::Hasher">Hasher</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Feeds a slice of this type into the given <a href="https://doc.rust-lang.org/1.63.0/core/hash/trait.Hasher.html" title="Hasher"><code>Hasher</code></a>. <a href="https://doc.rust-lang.org/1.63.0/core/hash/trait.Hash.html#method.hash_slice">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Index%3CIdx%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#216-228">source</a></span><a href="#impl-Index%3CIdx%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O, Idx&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;Idx&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;Idx&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-3" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-3" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.63.0/core/ops/index/trait.Index.html#associatedtype.Output" class="associatedtype">Output</a> = &lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt; as <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/index/trait.Index.html" title="trait core::ops::index::Index">Index</a>&lt;Idx&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'><p>The returned type after indexing.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#225-227">source</a></span><a href="#method.index" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/ops/index/trait.Index.html#tymethod.index" class="fnname">index</a>(&amp;self, index: Idx) -&gt; &amp;Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.63.0/core/ops/index/trait.Index.html#tymethod.index">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IndexMut%3CIdx%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#231-241">source</a></span><a href="#impl-IndexMut%3CIdx%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O, Idx&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;Idx&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/index/trait.IndexMut.html" title="trait core::ops::index::IndexMut">IndexMut</a>&lt;Idx&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.index_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#238-240">source</a></span><a href="#method.index_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut" class="fnname">index_mut</a>(&amp;mut self, index: Idx) -&gt; &amp;mut Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/ops/index/trait.Index.html#associatedtype.Output" title="type core::ops::index::Index::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the mutable indexing (<code>container[index]</code>) operation. <a href="https://doc.rust-lang.org/1.63.0/core/ops/index/trait.IndexMut.html#tymethod.index_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-IntoIterator" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/iter.rs.html#24-36">source</a></span><a href="#impl-IntoIterator" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="docblock"><p><a href="https://doc.rust-lang.org/1.63.0/alloc/vec/into_iter/struct.IntoIter.html">Original</a></p>
</div><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.IntoIter" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.IntoIter" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" class="associatedtype">IntoIter</a> = <a class="struct" href="struct.IntoIter.html" title="struct bitvec::boxed::IntoIter">IntoIter</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'><p>Which kind of iterator are we turning this into?</p>
</div></details><details class="rustdoc-toggle" open><summary><section id="associatedtype.Item" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Item" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" class="associatedtype">Item</a> = <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>The type of the elements being iterated over.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into_iter" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/iter.rs.html#33-35">source</a></span><a href="#method.into_iter" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter" class="fnname">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.IntoIter" title="type core::iter::traits::collect::IntoIterator::IntoIter">IntoIter</a></h4></section></summary><div class='docblock'><p>Creates an iterator from a value. <a href="https://doc.rust-lang.org/1.63.0/core/iter/traits/collect/trait.IntoIterator.html#tymethod.into_iter">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-LowerHex" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#335-343">source</a></span><a href="#impl-LowerHex" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.LowerHex.html" title="trait core::fmt::LowerHex">LowerHex</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#335-343">source</a></span><a href="#method.fmt-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.LowerHex.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.63.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.63.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'><p>Formats the value using the given formatter.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Not" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#243-257">source</a></span><a href="#impl-Not" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.Not.html" title="trait core::ops::bit::Not">Not</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Output-4" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Output-4" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.Not.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt;</h4></section></summary><div class='docblock'><p>The resulting type after applying the <code>!</code> operator.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.not" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/ops.rs.html#251-256">source</a></span><a href="#method.not" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.Not.html#tymethod.not" class="fnname">not</a>(self) -&gt; Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.Not.html#associatedtype.Output" title="type core::ops::bit::Not::Output">Output</a></h4></section></summary><div class='docblock'><p>Performs the unary <code>!</code> operation. <a href="https://doc.rust-lang.org/1.63.0/core/ops/bit/trait.Not.html#tymethod.not">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Octal" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#335-343">source</a></span><a href="#impl-Octal" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Octal.html" title="trait core::fmt::Octal">Octal</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-4" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#335-343">source</a></span><a href="#method.fmt-4" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Octal.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.63.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.63.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'><p>Formats the value using the given formatter.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Ord" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#84-93">source</a></span><a href="#impl-Ord" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.Ord.html" title="trait core::cmp::Ord">Ord</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#90-92">source</a></span><a href="#method.cmp" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.Ord.html#tymethod.cmp" class="fnname">cmp</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a></h4></section></summary><div class='docblock'><p>This method returns an <a href="https://doc.rust-lang.org/1.63.0/core/cmp/enum.Ordering.html" title="Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.Ord.html#tymethod.cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.max" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#797-799">source</a></span><a href="#method.max" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.Ord.html#method.max" class="fnname">max</a>(self, other: Self) -&gt; Self</h4></section></summary><div class='docblock'><p>Compares and returns the maximum of two values. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.Ord.html#method.max">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.min" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#817-819">source</a></span><a href="#method.min" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.Ord.html#method.min" class="fnname">min</a>(self, other: Self) -&gt; Self</h4></section></summary><div class='docblock'><p>Compares and returns the minimum of two values. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.Ord.html#method.min">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#842-844">source</a></span><a href="#method.clamp" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.Ord.html#method.clamp" class="fnname">clamp</a>(self, min: Self, max: Self) -&gt; Self</h4></section></summary><div class='docblock'><p>Restrict a value to a certain interval. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.Ord.html#method.clamp">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitBox%3CT2%2C%20O2%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#96-107">source</a></span><a href="#impl-PartialEq%3CBitBox%3CT2%2C%20O2%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;&gt; for <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#104-106">source</a></span><a href="#method.eq" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#231">source</a></span><a href="#method.ne" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitBox%3CT2%2C%20O2%3E%3E-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#110-121">source</a></span><a href="#impl-PartialEq%3CBitBox%3CT2%2C%20O2%3E%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;&gt; for &amp;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#118-120">source</a></span><a href="#method.eq-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#231">source</a></span><a href="#method.ne-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CBitBox%3CT2%2C%20O2%3E%3E-2" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#124-135">source</a></span><a href="#impl-PartialEq%3CBitBox%3CT2%2C%20O2%3E%3E-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;&gt; for &amp;mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#132-134">source</a></span><a href="#method.eq-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#231">source</a></span><a href="#method.ne-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CRhs%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#138-148">source</a></span><a href="#impl-PartialEq%3CRhs%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Rhs: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq">PartialEq</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#145-147">source</a></span><a href="#method.eq-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html#tymethod.eq" class="fnname">eq</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#231">source</a></span><a href="#method.ne-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialEq.html#method.ne" class="fnname">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests for <code>!=</code>.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitBox%3CT2%2C%20O2%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#151-162">source</a></span><a href="#impl-PartialOrd%3CBitBox%3CT2%2C%20O2%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;&gt; for <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#159-161">source</a></span><a href="#method.partial_cmp" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.63.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#1102">source</a></span><a href="#method.lt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#1122">source</a></span><a href="#method.le" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#1145">source</a></span><a href="#method.gt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#1165">source</a></span><a href="#method.ge" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitBox%3CT2%2C%20O2%3E%3E-1" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#178-189">source</a></span><a href="#impl-PartialOrd%3CBitBox%3CT2%2C%20O2%3E%3E-1" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;&gt; for &amp;'a <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-2" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#186-188">source</a></span><a href="#method.partial_cmp-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.63.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#1102">source</a></span><a href="#method.lt-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#1122">source</a></span><a href="#method.le-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#1145">source</a></span><a href="#method.gt-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-2" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#1165">source</a></span><a href="#method.ge-2" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CBitBox%3CT2%2C%20O2%3E%3E-2" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#192-203">source</a></span><a href="#impl-PartialOrd%3CBitBox%3CT2%2C%20O2%3E%3E-2" class="anchor"></a><h3 class="code-header in-band">impl&lt;'a, O1, O2, T1, T2&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;&gt; for &amp;'a mut <a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T1, O1&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O1: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O2: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T1: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T2: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-3" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#200-202">source</a></span><a href="#method.partial_cmp-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T2, O2&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.63.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#1102">source</a></span><a href="#method.lt-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#1122">source</a></span><a href="#method.le-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#1145">source</a></span><a href="#method.gt-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-3" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#1165">source</a></span><a href="#method.ge-3" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CRhs%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#165-175">source</a></span><a href="#impl-PartialOrd%3CRhs%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O, Rhs&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;Rhs&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Rhs: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> + <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html" title="trait core::cmp::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="../slice/struct.BitSlice.html" title="struct bitvec::slice::BitSlice">BitSlice</a>&lt;T, O&gt;&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.partial_cmp-1" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#172-174">source</a></span><a href="#method.partial_cmp-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp" class="fnname">partial_cmp</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.63.0/core/cmp/enum.Ordering.html" title="enum core::cmp::Ordering">Ordering</a>&gt;</h4></section></summary><div class='docblock'><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.lt-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#1102">source</a></span><a href="#method.lt-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.lt" class="fnname">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.le-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#1122">source</a></span><a href="#method.le-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.le" class="fnname">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.gt-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#1145">source</a></span><a href="#method.gt-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.gt" class="fnname">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ge-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/cmp.rs.html#1165">source</a></span><a href="#method.ge-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.ge" class="fnname">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Rhs) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator. <a href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Pointer" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#335-343">source</a></span><a href="#impl-Pointer" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Pointer.html" title="trait core::fmt::Pointer">Pointer</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-5" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#335-343">source</a></span><a href="#method.fmt-5" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Pointer.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.63.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.63.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'><p>Formats the value using the given formatter.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-TryFrom%3CBox%3C%5BT%5D%2C%20Global%3E%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#298-309">source</a></span><a href="#impl-TryFrom%3CBox%3C%5BT%5D%2C%20Global%3E%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;<a class="struct" href="https://doc.rust-lang.org/1.63.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.slice.html">[T]</a>, <a class="struct" href="https://doc.rust-lang.org/1.63.0/alloc/alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt;&gt; for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="struct" href="https://doc.rust-lang.org/1.63.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.slice.html">[T]</a>, <a class="struct" href="https://doc.rust-lang.org/1.63.0/alloc/alloc/struct.Global.html" title="struct alloc::alloc::Global">Global</a>&gt;</h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#306-308">source</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(boxed: <a class="struct" href="https://doc.rust-lang.org/1.63.0/alloc/boxed/struct.Box.html" title="struct alloc::boxed::Box">Box</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.slice.html">[T]</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-UpperHex" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#335-343">source</a></span><a href="#impl-UpperHex" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.UpperHex.html" title="trait core::fmt::UpperHex">UpperHex</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-6" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#335-343">source</a></span><a href="#method.fmt-6" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.UpperHex.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, fmt: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.63.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.63.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'><p>Formats the value using the given formatter.</p>
</div></details></div></details><section id="impl-Eq" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#76-81">source</a></span><a href="#impl-Eq" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/cmp/trait.Eq.html" title="trait core::cmp::Eq">Eq</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section><section id="impl-Send" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#372-377">source</a></span><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section><section id="impl-Sync" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#379-384">source</a></span><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section><section id="impl-Unpin" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/bitvec/boxed/traits.rs.html#386-391">source</a></span><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="../store/trait.BitStore.html" title="trait bitvec::store::BitStore">BitStore</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="../order/trait.BitOrder.html" title="trait bitvec::order::BitOrder">BitOrder</a>,&nbsp;</span></h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe" class="impl has-srclink"><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></h3></section><section id="impl-UnwindSafe" class="impl has-srclink"><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, O&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.BitBox.html" title="struct bitvec::boxed::BitBox">BitBox</a>&lt;T, O&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;O: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a>,&nbsp;</span></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/any.rs.html#203-207">source</a></span><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/any.rs.html#204">source</a></span><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.63.0/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/1.63.0/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/borrow.rs.html#209-214">source</a></span><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/borrow.rs.html#211">source</a></span><a href="#method.borrow-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/borrow.rs.html#218-222">source</a></span><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/borrow.rs.html#219">source</a></span><a href="#method.borrow_mut-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Conv" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/conv.rs.html#58">source</a></span><a href="#impl-Conv" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../tap/conv/trait.Conv.html" title="trait tap::conv::Conv">Conv</a> for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.conv" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/conv.rs.html#49-52">source</a></span><a href="#method.conv" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/conv/trait.Conv.html#method.conv" class="fnname">conv</a>&lt;T&gt;(self) -&gt; T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h4></section></summary><div class='docblock'><p>Converts <code>self</code> into <code>T</code> using <code>Into&lt;T&gt;</code>. <a href="../../tap/conv/trait.Conv.html#method.conv">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-FmtForward" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/wyz/fmt.rs.html#242-243">source</a></span><a href="#impl-FmtForward" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../wyz/fmt/trait.FmtForward.html" title="trait wyz::fmt::FmtForward">FmtForward</a> for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_binary" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/wyz/fmt.rs.html#54-55">source</a></span><a href="#method.fmt_binary" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_binary" class="fnname">fmt_binary</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtBinary.html" title="struct wyz::fmt::FmtBinary">FmtBinary</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Binary.html" title="trait core::fmt::Binary">Binary</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Causes <code>self</code> to use its <code>Binary</code> implementation when <code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_binary">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_display" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/wyz/fmt.rs.html#85-86">source</a></span><a href="#method.fmt_display" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_display" class="fnname">fmt_display</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtDisplay.html" title="struct wyz::fmt::FmtDisplay">FmtDisplay</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Causes <code>self</code> to use its <code>Display</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_display">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_lower_exp" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/wyz/fmt.rs.html#106-107">source</a></span><a href="#method.fmt_lower_exp" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_exp" class="fnname">fmt_lower_exp</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtLowerExp.html" title="struct wyz::fmt::FmtLowerExp">FmtLowerExp</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.LowerExp.html" title="trait core::fmt::LowerExp">LowerExp</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Causes <code>self</code> to use its <code>LowerExp</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_exp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_lower_hex" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/wyz/fmt.rs.html#127-128">source</a></span><a href="#method.fmt_lower_hex" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_hex" class="fnname">fmt_lower_hex</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtLowerHex.html" title="struct wyz::fmt::FmtLowerHex">FmtLowerHex</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.LowerHex.html" title="trait core::fmt::LowerHex">LowerHex</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Causes <code>self</code> to use its <code>LowerHex</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_lower_hex">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_octal" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/wyz/fmt.rs.html#147-148">source</a></span><a href="#method.fmt_octal" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_octal" class="fnname">fmt_octal</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtOctal.html" title="struct wyz::fmt::FmtOctal">FmtOctal</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Octal.html" title="trait core::fmt::Octal">Octal</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Causes <code>self</code> to use its <code>Octal</code> implementation when <code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_octal">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_pointer" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/wyz/fmt.rs.html#168-169">source</a></span><a href="#method.fmt_pointer" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_pointer" class="fnname">fmt_pointer</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtPointer.html" title="struct wyz::fmt::FmtPointer">FmtPointer</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Pointer.html" title="trait core::fmt::Pointer">Pointer</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Causes <code>self</code> to use its <code>Pointer</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_pointer">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_upper_exp" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/wyz/fmt.rs.html#189-190">source</a></span><a href="#method.fmt_upper_exp" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_exp" class="fnname">fmt_upper_exp</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtUpperExp.html" title="struct wyz::fmt::FmtUpperExp">FmtUpperExp</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.UpperExp.html" title="trait core::fmt::UpperExp">UpperExp</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Causes <code>self</code> to use its <code>UpperExp</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_exp">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_upper_hex" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/wyz/fmt.rs.html#210-211">source</a></span><a href="#method.fmt_upper_hex" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_hex" class="fnname">fmt_upper_hex</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtUpperHex.html" title="struct wyz::fmt::FmtUpperHex">FmtUpperHex</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.UpperHex.html" title="trait core::fmt::UpperHex">UpperHex</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Causes <code>self</code> to use its <code>UpperHex</code> implementation when
<code>Debug</code>-formatted. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_upper_hex">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt_list" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/wyz/fmt.rs.html#236-237">source</a></span><a href="#method.fmt_list" class="anchor"></a><h4 class="code-header">fn <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_list" class="fnname">fmt_list</a>(self) -&gt; <a class="struct" href="../../wyz/fmt/struct.FmtList.html" title="struct wyz::fmt::FmtList">FmtList</a>&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;'a </a>Self: for&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Formats each item in a sequence. <a href="../../wyz/fmt/trait.FmtForward.html#method.fmt_list">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#557-562">source</a></span><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-7" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#559">source</a></span><a href="#method.from-7" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#541-552">source</a></span><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#549">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Pipe" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/pipe.rs.html#234">source</a></span><a href="#impl-Pipe" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../tap/pipe/trait.Pipe.html" title="trait tap::pipe::Pipe">Pipe</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/pipe.rs.html#73-76">source</a></span><a href="#method.pipe" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe" class="fnname">pipe</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(Self) -&gt; R) -&gt; R</h4></section></summary><div class='docblock'><p>Pipes by value. This is generally the method you want to use. <a href="../../tap/pipe/trait.Pipe.html#method.pipe">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_ref" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/pipe.rs.html#97-99">source</a></span><a href="#method.pipe_ref" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref" class="fnname">pipe_ref</a>&lt;'a, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;'a </a>Self) -&gt; R) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></h4></section></summary><div class='docblock'><p>Borrows <code>self</code> and passes that borrow into the pipe function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_ref_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/pipe.rs.html#122-127">source</a></span><a href="#method.pipe_ref_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref_mut" class="fnname">pipe_ref_mut</a>&lt;'a, R&gt;(&amp;'a mut self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;'a mut </a>Self) -&gt; R) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></h4></section></summary><div class='docblock'><p>Mutably borrows <code>self</code> and passes that borrow into the pipe function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_ref_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_borrow" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/pipe.rs.html#145-149">source</a></span><a href="#method.pipe_borrow" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow" class="fnname">pipe_borrow</a>&lt;'a, B, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;'a </a>B) -&gt; R) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></h4></section></summary><div class='docblock'><p>Borrows <code>self</code>, then passes <code>self.borrow()</code> into the pipe function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/pipe.rs.html#169-176">source</a></span><a href="#method.pipe_borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow_mut" class="fnname">pipe_borrow_mut</a>&lt;'a, B, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;'a mut </a>B) -&gt; R<br>) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></h4></section></summary><div class='docblock'><p>Mutably borrows <code>self</code>, then passes <code>self.borrow_mut()</code> into the pipe
function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_borrow_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_as_ref" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/pipe.rs.html#183-187">source</a></span><a href="#method.pipe_as_ref" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_as_ref" class="fnname">pipe_as_ref</a>&lt;'a, U, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;'a </a>U) -&gt; R) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;U&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></h4></section></summary><div class='docblock'><p>Borrows <code>self</code>, then passes <code>self.as_ref()</code> into the pipe function.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_as_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/pipe.rs.html#195-202">source</a></span><a href="#method.pipe_as_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_as_mut" class="fnname">pipe_as_mut</a>&lt;'a, U, R&gt;(&amp;'a mut self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;'a mut </a>U) -&gt; R) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;U&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></h4></section></summary><div class='docblock'><p>Mutably borrows <code>self</code>, then passes <code>self.as_mut()</code> into the pipe
function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_as_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_deref" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/pipe.rs.html#209-213">source</a></span><a href="#method.pipe_deref" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_deref" class="fnname">pipe_deref</a>&lt;'a, T, R&gt;(&amp;'a self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;'a </a>T) -&gt; R) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></h4></section></summary><div class='docblock'><p>Borrows <code>self</code>, then passes <code>self.deref()</code> into the pipe function.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.pipe_deref_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/pipe.rs.html#221-228">source</a></span><a href="#method.pipe_deref_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/pipe/trait.Pipe.html#method.pipe_deref_mut" class="fnname">pipe_deref_mut</a>&lt;'a, T, R&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;'a mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;'a mut </a>T) -&gt; R<br>) -&gt; R <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>&lt;Target = T&gt; + <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'a + ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: 'a,&nbsp;</span></h4></section></summary><div class='docblock'><p>Mutably borrows <code>self</code>, then passes <code>self.deref_mut()</code> into the pipe
function. <a href="../../tap/pipe/trait.Pipe.html#method.pipe_deref_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Tap" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/tap.rs.html#329">source</a></span><a href="#impl-Tap" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../tap/tap/trait.Tap.html" title="trait tap::tap::Tap">Tap</a> for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/tap.rs.html#78">source</a></span><a href="#method.tap" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap" class="fnname">tap</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Self)) -&gt; Self</h4></section></summary><div class='docblock'><p>Immutable access to a value. <a href="../../tap/tap/trait.Tap.html#method.tap">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/tap.rs.html#116">source</a></span><a href="#method.tap_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_mut" class="fnname">tap_mut</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>Self)) -&gt; Self</h4></section></summary><div class='docblock'><p>Mutable access to a value. <a href="../../tap/tap/trait.Tap.html#method.tap_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_borrow" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/tap.rs.html#129-132">source</a></span><a href="#method.tap_borrow" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow" class="fnname">tap_borrow</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>B)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Immutable access to the <code>Borrow&lt;B&gt;</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_borrow">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/tap.rs.html#146-149">source</a></span><a href="#method.tap_borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut" class="fnname">tap_borrow_mut</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>B)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Mutable access to the <code>BorrowMut&lt;B&gt;</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_ref" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/tap.rs.html#163-166">source</a></span><a href="#method.tap_ref" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref" class="fnname">tap_ref</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>R)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;R&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Immutable access to the <code>AsRef&lt;R&gt;</code> view of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_ref">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_ref_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/tap.rs.html#180-183">source</a></span><a href="#method.tap_ref_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut" class="fnname">tap_ref_mut</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>R)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;R&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Mutable access to the <code>AsMut&lt;R&gt;</code> view of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_deref" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/tap.rs.html#197-200">source</a></span><a href="#method.tap_deref" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref" class="fnname">tap_deref</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>T)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Immutable access to the <code>Deref::Target</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_deref">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_deref_mut" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/tap.rs.html#214-217">source</a></span><a href="#method.tap_deref_mut" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut" class="fnname">tap_deref_mut</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>T)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>&lt;Target = T&gt; + <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Mutable access to the <code>Deref::Target</code> of a value. <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_dbg" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/tap.rs.html#227">source</a></span><a href="#method.tap_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_dbg" class="fnname">tap_dbg</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>Self)) -&gt; Self</h4></section></summary><div class='docblock'><p>Calls <code>.tap()</code> only in debug builds, and is erased in release builds.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_mut_dbg" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/tap.rs.html#237">source</a></span><a href="#method.tap_mut_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_mut_dbg" class="fnname">tap_mut_dbg</a>(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>Self)) -&gt; Self</h4></section></summary><div class='docblock'><p>Calls <code>.tap_mut()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_mut_dbg">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_borrow_dbg" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/tap.rs.html#247-250">source</a></span><a href="#method.tap_borrow_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_dbg" class="fnname">tap_borrow_dbg</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>B)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Calls <code>.tap_borrow()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_dbg">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_borrow_mut_dbg" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/tap.rs.html#261-264">source</a></span><a href="#method.tap_borrow_mut_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut_dbg" class="fnname">tap_borrow_mut_dbg</a>&lt;B&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>B)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;B&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;B: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Calls <code>.tap_borrow_mut()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_borrow_mut_dbg">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_ref_dbg" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/tap.rs.html#275-278">source</a></span><a href="#method.tap_ref_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref_dbg" class="fnname">tap_ref_dbg</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>R)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;R&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Calls <code>.tap_ref()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_ref_dbg">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_ref_mut_dbg" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/tap.rs.html#289-292">source</a></span><a href="#method.tap_ref_mut_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut_dbg" class="fnname">tap_ref_mut_dbg</a>&lt;R&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>R)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.AsMut.html" title="trait core::convert::AsMut">AsMut</a>&lt;R&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;R: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Calls <code>.tap_ref_mut()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_ref_mut_dbg">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_deref_dbg" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/tap.rs.html#303-306">source</a></span><a href="#method.tap_deref_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref_dbg" class="fnname">tap_deref_dbg</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;</a>T)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = T&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Calls <code>.tap_deref()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_deref_dbg">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.tap_deref_mut_dbg" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/tap.rs.html#317-320">source</a></span><a href="#method.tap_deref_mut_dbg" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut_dbg" class="fnname">tap_deref_mut_dbg</a>&lt;T&gt;(self, func: impl <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>T)) -&gt; Self <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/deref/trait.DerefMut.html" title="trait core::ops::deref::DerefMut">DerefMut</a>&lt;Target = T&gt; + <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h4></section></summary><div class='docblock'><p>Calls <code>.tap_deref_mut()</code> only in debug builds, and is erased in release
builds. <a href="../../tap/tap/trait.Tap.html#method.tap_deref_mut_dbg">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-ToOwned" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/alloc/borrow.rs.html#83-95">source</a></span><a href="#impl-ToOwned" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.63.0/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/alloc/borrow.rs.html#88">source</a></span><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/1.63.0/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/alloc/borrow.rs.html#92">source</a></span><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/1.63.0/std/primitive.reference.html">&amp;mut </a>T)</h4></section></summary><div class='docblock'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/1.63.0/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-ToString" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/alloc/string.rs.html#2479-2493">source</a></span><a href="#impl-ToString" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/alloc/string/trait.ToString.html" title="trait alloc::string::ToString">ToString</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a> + ?<a class="trait" href="https://doc.rust-lang.org/1.63.0/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/alloc/string.rs.html#2485">source</a></span><a href="#method.to_string" class="anchor"></a><h4 class="code-header">default fn <a href="https://doc.rust-lang.org/1.63.0/alloc/string/trait.ToString.html#tymethod.to_string" class="fnname">to_string</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/1.63.0/alloc/string/struct.String.html" title="struct alloc::string::String">String</a></h4></section></summary><div class='docblock'><p>Converts the given value to a <code>String</code>. <a href="https://doc.rust-lang.org/1.63.0/alloc/string/trait.ToString.html#tymethod.to_string">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryConv" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/conv.rs.html#87">source</a></span><a href="#impl-TryConv" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="../../tap/conv/trait.TryConv.html" title="trait tap::conv::TryConv">TryConv</a> for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_conv" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../../src/tap/conv.rs.html#78-81">source</a></span><a href="#method.try_conv" class="anchor"></a><h4 class="code-header">fn <a href="../../tap/conv/trait.TryConv.html#method.try_conv" class="fnname">try_conv</a>&lt;T&gt;(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, Self::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryInto.html#associatedtype.Error" title="type core::convert::TryInto::Error">Error</a>&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;T&gt;,&nbsp;</span></h4></section></summary><div class='docblock'><p>Attempts to convert <code>self</code> into <code>T</code> using <code>TryInto&lt;T&gt;</code>. <a href="../../tap/conv/trait.TryConv.html#method.try_conv">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#598-607">source</a></span><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from-1" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#604">source</a></span><a href="#method.try_from-1" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#583-592">source</a></span><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-2" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-2" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/1.63.0/src/core/convert/mod.rs.html#589">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.63.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/1.63.0/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></div></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="bitvec" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.63.0 (4b91a6ea7 2022-08-08)" ></div>
</body></html>